{"version":3,"file":"slimdom.mjs","sources":["../lib/mutation-observer/RegisteredObserver.js","../lib/mutation-observer/RegisteredObservers.js","../lib/mutation-observer/NotifyList.js","../lib/context/Context.js","../lib/util/NodeType.js","../lib/util/treeHelpers.js","../lib/util/cloneNode.js","../lib/util/errorHelpers.js","../lib/mixins.js","../lib/util/treeMutations.js","../lib/mutation-observer/MutationRecord.js","../lib/mutation-observer/queueMutationRecord.js","../lib/util/mutationAlgorithms.js","../lib/util/typeHelpers.js","../lib/Node.js","../lib/util/attrMutations.js","../lib/Attr.js","../lib/CharacterData.js","../lib/Text.js","../lib/CDATASection.js","../lib/Comment.js","../lib/DocumentType.js","../lib/util/namespaceHelpers.js","../lib/dom-parsing/NamespacePrefixMap.js","../lib/dom-parsing/serializationAlgorithms.js","../lib/Element.js","../lib/util/createElementNS.js","../lib/DOMImplementation.js","../lib/Document.js","../lib/DocumentFragment.js","../lib/ProcessingInstruction.js","../lib/Range.js","../lib/XMLDocument.js","../lib/dom-parsing/XMLSerializer.js","../lib/mutation-observer/MutationObserver.js","../lib/unsafe.js","../lib/index.js"],"sourcesContent":["/**\n * A registered observer consists of an observer (a MutationObserver object) and options (a\n * MutationObserverInit dictionary).\n *\n * A transient registered observer is a registered observer that also consists of a source (a\n * registered observer).\n *\n * Transient registered observers are used to track mutations within a given node’s descendants\n * after node has been removed so they do not get lost when subtree is set to true on node’s parent.\n */\nvar RegisteredObserver = /** @class */ (function () {\n    /**\n     * @param observer The observer being registered\n     * @param node     The node being observed\n     * @param options  Options for the registration\n     * @param source   If not null, creates a transient registered observer for the given registered\n     *                 observer\n     */\n    function RegisteredObserver(observer, node, options, source) {\n        /**\n         * A transient observer is an observer that has a source which is an observer.\n         */\n        this.source = null;\n        this.observer = observer;\n        this.node = node;\n        this.options = options;\n        this.source = source || null;\n        if (source) {\n            observer._transients.push(this);\n        }\n    }\n    /**\n     * Adds the given mutationRecord to the NotifyList of the registered MutationObserver. It only\n     * adds the record when it's type isn't blocked by one of the flags of this registered\n     * MutationObserver options (formally the MutationObserverInit object).\n     *\n     * @param type                The type of mutation record to queue\n     * @param target              The target node\n     * @param data                The data for the mutation record\n     * @param interestedObservers Array of mutation observer objects to append to\n     * @param pairedStrings       Paired strings for the mutation observer objects\n     */\n    RegisteredObserver.prototype.collectInterestedObservers = function (type, target, data, interestedObservers, pairedStrings) {\n        // (continued from RegisteredObservers#queueMutationRecord)\n        // 3.1. Let options be registered's options.\n        // 3.2. If none of the following are true\n        // node is not target and options’ subtree is false\n        if (this.node !== target && !this.options.subtree) {\n            return;\n        }\n        // type is \"attributes\" and options’ attributes is not true\n        if (type === 'attributes' && !this.options.attributes) {\n            return;\n        }\n        // type is \"attributes\", options’ attributeFilter is present, and options’ attributeFilter\n        // does not contain name or namespace is non-null\n        // (attributeFilter not implemented)\n        // type is \"characterData\" and options’ characterData is not true\n        if (type === 'characterData' && !this.options.characterData) {\n            return;\n        }\n        // type is \"childList\" and options’ childList is false\n        if (type === 'childList' && !this.options.childList) {\n            return;\n        }\n        // then:\n        // 3.2.1. Let mo be registered's observer.\n        // 3.2.2. If interestedObservers[mo] does not exist, then set interestedObservers[mo] to\n        // null\n        var index = interestedObservers.indexOf(this.observer);\n        if (index < 0) {\n            index = interestedObservers.length;\n            interestedObservers.push(this.observer);\n            pairedStrings.push(undefined);\n        }\n        // 3.2.3. If either type is \"attributes\" and options’ attributeOldValue is true, or type is\n        // \"characterData\" and options’ characterDataOldValue is true, then set\n        // interestedObservers[mo] to oldValue.\n        if ((type === 'attributes' && this.options.attributeOldValue) ||\n            (type === 'characterData' && this.options.characterDataOldValue)) {\n            pairedStrings[index] = data.oldValue;\n        }\n    };\n    return RegisteredObserver;\n}());\nexport default RegisteredObserver;\n//# sourceMappingURL=RegisteredObserver.js.map","import RegisteredObserver from './RegisteredObserver';\n/**\n * Each node has an associated list of registered observers.\n */\nvar RegisteredObservers = /** @class */ (function () {\n    /**\n     * @param node Node for which this instance holds RegisteredObserver instances.\n     */\n    function RegisteredObservers(node) {\n        this._registeredObservers = [];\n        this._node = node;\n    }\n    /**\n     * Registers a given MutationObserver with the given options.\n     *\n     * @param observer Observer to create a registration for\n     * @param options  Options for the registration\n     */\n    RegisteredObservers.prototype.register = function (observer, options) {\n        // (continuing from MutationObserver#observe)\n        // 7. For each registered registered of target’s registered observer list, if registered's\n        // observer is the context object:\n        var registeredObservers = this._registeredObservers;\n        var hasRegisteredObserverForObserver = false;\n        registeredObservers.forEach(function (registered) {\n            if (registered.observer !== observer) {\n                return;\n            }\n            hasRegisteredObserverForObserver = true;\n            // 7.1. For each node of the context object's node list, remove all transient registered\n            // observers whose source is registered from node's registered observer list.\n            removeTransientRegisteredObserversForSource(registered);\n            // 7.2. Set registered’s options to options.\n            registered.options = options;\n        });\n        // 8. Otherwise:\n        if (!hasRegisteredObserverForObserver) {\n            // 8.1. Append a new registered observer whose observer is the context object and\n            // options is options to target's registered observer list.\n            this._registeredObservers.push(new RegisteredObserver(observer, this._node, options));\n            // 8.2. Append target to the context object's node list.\n            observer._nodes.push(this._node);\n        }\n    };\n    /**\n     * Removes the given transient registered observer.\n     *\n     * Transient registered observers never have a corresponding entry in the observer's list of\n     * nodes. They are guaranteed to be present in the array, as MutationObserver#_transients and\n     * RegisteredObservers#_registeredObservers are kept in sync.\n     *\n     * @param transientRegisteredObserver The registered observer to remove\n     */\n    RegisteredObservers.prototype.removeTransientRegisteredObserver = function (transientRegisteredObserver) {\n        this._registeredObservers.splice(this._registeredObservers.indexOf(transientRegisteredObserver), 1);\n    };\n    /**\n     * Remove any registered observer on the associated node for which observer is the observer.\n     *\n     * As this only occurs for all nodes at once, it is the caller's responsibility to remove the\n     * associated node from the observer's list of nodes.\n     *\n     * @param observer Observer for which to remove the registration\n     */\n    RegisteredObservers.prototype.removeForObserver = function (observer) {\n        // Filter the array in-place\n        var write = 0;\n        for (var read = 0, l = this._registeredObservers.length; read < l; ++read) {\n            var registered = this._registeredObservers[read];\n            if (registered.observer === observer) {\n                continue;\n            }\n            if (read !== write) {\n                this._registeredObservers[write] = registered;\n            }\n            ++write;\n        }\n        this._registeredObservers.length = write;\n    };\n    /**\n     * Determines interested observers for the given record.\n     *\n     * @param type                The type of mutation record to queue\n     * @param target              The target node\n     * @param data                The data for the mutation record\n     * @param interestedObservers Array of mutation observer objects to append to\n     * @param pairedStrings       Paired strings for the mutation observer objects\n     */\n    RegisteredObservers.prototype.collectInterestedObservers = function (type, target, data, interestedObservers, pairedStrings) {\n        // (continuing from queueMutationRecord)\n        // 3. ...and then for each registered of node's registered observer list:\n        this._registeredObservers.forEach(function (registeredObserver) {\n            registeredObserver.collectInterestedObservers(type, target, data, interestedObservers, pairedStrings);\n        });\n    };\n    /**\n     * Append transient registered observers for any registered observers whose options' subtree is\n     * true.\n     *\n     * @param node Node to append the transient registered observers to\n     */\n    RegisteredObservers.prototype.appendTransientRegisteredObservers = function (node) {\n        this._registeredObservers.forEach(function (registeredObserver) {\n            if (registeredObserver.options.subtree) {\n                node._registeredObservers.registerTransient(registeredObserver);\n            }\n        });\n    };\n    /**\n     * Appends a transient registered observer for the given registered observer.\n     *\n     * @param source The source registered observer\n     */\n    RegisteredObservers.prototype.registerTransient = function (source) {\n        this._registeredObservers.push(new RegisteredObserver(source.observer, this._node, source.options, source));\n        // Note that node is not added to the transient observer's observer's list of nodes.\n    };\n    return RegisteredObservers;\n}());\nexport default RegisteredObservers;\n/**\n * Removes all transient registered observers whose observer is observer.\n *\n * @param observer The mutation observer object to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForObserver(observer) {\n    observer._transients.forEach(function (transientRegisteredObserver) {\n        transientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(transientRegisteredObserver);\n    });\n    observer._transients.length = 0;\n}\n/**\n * Removes all transient registered observer whose source is source.\n *\n * @param source The registered observer to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForSource(source) {\n    for (var i = source.observer._transients.length - 1; i >= 0; --i) {\n        var transientRegisteredObserver = source.observer._transients[i];\n        if (transientRegisteredObserver.source !== source) {\n            return;\n        }\n        transientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(transientRegisteredObserver);\n        source.observer._transients.splice(i, 1);\n    }\n}\n//# sourceMappingURL=RegisteredObservers.js.map","import { removeTransientRegisteredObserversForObserver } from './RegisteredObservers';\nfunction queueCompoundMicrotask(callback, thisArg) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    Promise.resolve().then(function () { return callback.apply(thisArg, args); });\n}\n/**\n * Tracks MutationObserver instances which have a non-empty record queue and schedules their\n * callbacks to be called.\n */\nvar NotifyList = /** @class */ (function () {\n    function NotifyList() {\n        this._notifyList = [];\n        this._compoundMicrotaskQueued = false;\n    }\n    /**\n     * Appends a given MutationRecord to the recordQueue of the given MutationObserver and schedules\n     * it for reporting.\n     *\n     * @param observer The observer for which to enqueue the record\n     * @param record   The record to enqueue\n     */\n    NotifyList.prototype.appendRecord = function (observer, record) {\n        observer._recordQueue.push(record);\n        this._notifyList.push(observer);\n    };\n    /**\n     * To queue a mutation observer compound microtask, run these steps:\n     */\n    NotifyList.prototype.queueMutationObserverCompoundMicrotask = function () {\n        var _this = this;\n        // 1. If mutation observer compound microtask queued flag is set, then return.\n        if (this._compoundMicrotaskQueued) {\n            return;\n        }\n        // 2. Set mutation observer compound microtask queued flag.\n        // 3. Queue a compound microtask to notify mutation observers.\n        this._compoundMicrotaskQueued = true;\n        queueCompoundMicrotask(function () {\n            _this._notifyMutationObservers();\n        }, this);\n    };\n    /**\n     * To notify mutation observers, run these steps:\n     */\n    NotifyList.prototype._notifyMutationObservers = function () {\n        var _this = this;\n        // 1. Unset mutation observer compound microtask queued flag.\n        this._compoundMicrotaskQueued = false;\n        // 2. Let notify list be a clone of unit of related similar-origin browsing contexts' list\n        // of MutationObserver objects.\n        var notifyList = this._notifyList.concat();\n        // Clear the notify list - for efficiency this list only tracks observers that have a\n        // non-empty queue\n        this._notifyList.length = 0;\n        // 3. Let signalList be a copy of unit of related similar-origin browsing contexts' signal\n        // slot list.\n        // 4. Empty unit of related similar-origin browsing contexts' signal slot list.\n        // (shadow dom not implemented)\n        // 5. For each MutationObserver object mo in notify list, execute a compound microtask\n        // subtask to run these steps: [HTML]\n        notifyList.forEach(function (mo) {\n            queueCompoundMicrotask(function (mo) {\n                // 5.1. Let queue be a copy of mo’s record queue.\n                // 5.2. Empty mo’s record queue.\n                var queue = mo.takeRecords();\n                // 5.3. For each node of mo's node list, remove all transient registered\n                // observers whose observer is mo from node's registered observer list.\n                removeTransientRegisteredObserversForObserver(mo);\n                // 5.4. If records is not empty, then invoke mo’s callback with « records, mo »,\n                // and mo. If this throws an exception, then report the exception.\n                if (queue.length) {\n                    mo._callback(queue, mo);\n                }\n            }, _this, mo);\n        });\n        // 6. For each slot slot in signalList, in order, fire an event named slotchange, with its\n        // bubbles attribute set to true, at slot.\n        // (shadow dom not implemented)\n    };\n    return NotifyList;\n}());\nexport default NotifyList;\n//# sourceMappingURL=NotifyList.js.map","import NotifyList from '../mutation-observer/NotifyList';\n/**\n * The DefaultContext is comparable to the global object in that it tracks its associated document.\n * It also serves as a way to inject the constructors for the constructable types, avoiding cyclic\n * dependencies.\n */\nvar DefaultContext = /** @class */ (function () {\n    function DefaultContext() {\n        /**\n         * The NotifyList instance is shared between all MutationObserver objects. It holds references\n         * to all MutationObserver instances that have collected records, and is responsible for\n         * invoking their callbacks when control returns to the event loop.\n         */\n        this._notifyList = new NotifyList();\n        this._ranges = [];\n    }\n    return DefaultContext;\n}());\nexport { DefaultContext };\n// TODO: make it possible to create multiple contexts by binding constructors to each instance\nexport var defaultContext = new DefaultContext();\nexport function getContext(instance) {\n    return defaultContext;\n}\n//# sourceMappingURL=Context.js.map","/**\n * Checks whether the given node's nodeType is one of the specified values\n *\n * @param node  The node to test\n * @param types Possible nodeTypes for node\n *\n * @return Whether node.nodeType is one of the specified values\n */\nexport function isNodeOfType(node) {\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        types[_i - 1] = arguments[_i];\n    }\n    return types.some(function (t) { return node.nodeType === t; });\n}\n//# sourceMappingURL=NodeType.js.map","import { isNodeOfType } from './NodeType';\n/**\n * 3.2. Node Tree: to determine the length of a node, switch on node:\n *\n * @param node The node to determine the length of\n *\n * @return The length of the node\n */\nexport function determineLengthOfNode(node) {\n    switch (node.nodeType) {\n        // DocumentType: Zero.\n        // (not necessary, as doctypes never have children)\n        // Text, ProcessingInstruction, Comment: The number of code units in its data.\n        case 3 /* TEXT_NODE */:\n        case 7 /* PROCESSING_INSTRUCTION_NODE */:\n        case 8 /* COMMENT_NODE */:\n            return node.data.length;\n        // Any other node: Its number of children.\n        default:\n            return node.childNodes.length;\n    }\n}\n/**\n * Get inclusive ancestors of the given node.\n *\n * @param node Node to get inclusive ancestors of\n *\n * @return Node's inclusive ancestors, in tree order\n */\nexport function getInclusiveAncestors(node) {\n    var ancestor = node;\n    var ancestors = [];\n    while (ancestor) {\n        ancestors.unshift(ancestor);\n        ancestor = ancestor.parentNode;\n    }\n    return ancestors;\n}\n/**\n * Get the node document associated with the given node.\n *\n * @param node The node to get the node document for\n *\n * @return The node document for node\n */\nexport function getNodeDocument(node) {\n    if (isNodeOfType(node, 9 /* DOCUMENT_NODE */)) {\n        return node;\n    }\n    return node.ownerDocument;\n}\n/**\n * Determine the index of the given node among its siblings.\n *\n * @param node Node to determine the index of\n *\n * @return The index of node in its parent's children\n */\nexport function getNodeIndex(node) {\n    return node.parentNode.childNodes.indexOf(node);\n}\n/**\n * The root of an object is itself, if its parent is null, or else it is the root of its parent.\n *\n * @param node Node to get the root of\n *\n * @return The root of node\n */\nexport function getRootOfNode(node) {\n    while (node.parentNode) {\n        node = node.parentNode;\n    }\n    return node;\n}\n/**\n * Invokes callback on each inclusive descendant of node, in tree order\n *\n * @param node     Root of the subtree to process\n * @param callback Callback to invoke for each descendant, should not modify node's position in the\n *                 tree\n */\nexport function forEachInclusiveDescendant(node, callback) {\n    callback(node);\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n        forEachInclusiveDescendant(child, callback);\n    }\n}\n//# sourceMappingURL=treeHelpers.js.map","import { getNodeDocument } from './treeHelpers';\n// 3.4. Interface Node\n/**\n * To clone a node, with an optional document and clone children flag, run these steps:\n *\n * @param node          The node to clone\n * @param cloneChildren Whether to also clone node's descendants\n * @param document      The document used to create the copy\n */\nexport default function cloneNode(node, cloneChildren, document) {\n    // 1. If document is not given, let document be node’s node document.\n    if (!document) {\n        document = getNodeDocument(node);\n    }\n    // 2. If node is an element, then:\n    // 2.1. Let copy be the result of creating an element, given document, node’s local name, node’s\n    // namespace, node’s namespace prefix, and node’s is value, with the synchronous custom elements\n    // flag unset.\n    // 2.2. For each attribute in node’s attribute list:\n    // 2.2.1. Let copyAttribute be a clone of attribute.\n    // 2.2.2. Append copyAttribute to copy.\n    // 3. Otherwise, let copy be a node that implements the same interfaces as node, and fulfills\n    // these additional requirements, switching on node:\n    // Document: Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n    // DocumentType: Set copy’s name, public ID, and system ID, to those of node.\n    // Attr: Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n    // Text, Comment: Set copy’s data, to that of node.\n    // ProcessingInstruction: Set copy’s target and data to those of node.\n    // Any other node: —\n    // 4. Set copy’s node document and document to copy, if copy is a document, and set copy’s node\n    // document to document otherwise.\n    // (all handled by _copy method)\n    var copy = node._copy(document);\n    // 5. Run any cloning steps defined for node in other applicable specifications and pass copy,\n    // node, document and the clone children flag if set, as parameters.\n    // (cloning steps not implemented)\n    // 6. If the clone children flag is set, clone all the children of node and append them to copy,\n    // with document as specified and the clone children flag being set.\n    if (cloneChildren) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n            copy.appendChild(cloneNode(child, true, document));\n        }\n    }\n    // 7. Return copy.\n    return copy;\n}\n//# sourceMappingURL=cloneNode.js.map","export function expectArity(args, minArity) {\n    // According to WebIDL overload resolution semantics, only a lower bound applies to the number\n    // of arguments provided\n    if (args.length < minArity) {\n        throw new TypeError(\"Function should be called with at least \" + minArity + \" arguments\");\n    }\n}\nexport function expectObject(value, Constructor) {\n    if (!(value instanceof Constructor)) {\n        throw new TypeError(\"Value should be an instance of \" + Constructor.name);\n    }\n}\nfunction createDOMException(name, code, message) {\n    var err = new Error(name + \": \" + message);\n    err.name = name;\n    err.code = code;\n    return err;\n}\nexport function throwHierarchyRequestError(message) {\n    throw createDOMException('HierarchyRequestError', 3, message);\n}\nexport function throwIndexSizeError(message) {\n    throw createDOMException('IndexSizeError', 1, message);\n}\nexport function throwInUseAttributeError(message) {\n    throw createDOMException('InUseAttributeError', 10, message);\n}\nexport function throwInvalidCharacterError(message) {\n    throw createDOMException('InvalidCharacterError', 5, message);\n}\nexport function throwInvalidNodeTypeError(message) {\n    throw createDOMException('InvalidNodeTypeError', 24, message);\n}\nexport function throwInvalidStateError(message) {\n    throw createDOMException('InvalidStateError', 11, message);\n}\nexport function throwNamespaceError(message) {\n    throw createDOMException('NamespaceError', 14, message);\n}\nexport function throwNotFoundError(message) {\n    throw createDOMException('NotFoundError', 8, message);\n}\nexport function throwNotSupportedError(message) {\n    throw createDOMException('NotSupportedError', 9, message);\n}\nexport function throwWrongDocumentError(message) {\n    throw createDOMException('WrongDocumentError', 4, message);\n}\n//# sourceMappingURL=errorHelpers.js.map","import { isNodeOfType } from './util/NodeType';\n// Document implements ParentNode;\n// DocumentFragment implements ParentNode;\n// Element implements ParentNode;\nexport function asParentNode(node) {\n    // This is only called from treeMutations.js, where node can never be anything other than these\n    /* istanbul ignore else */\n    if (isNodeOfType(node, 1 /* ELEMENT_NODE */, 9 /* DOCUMENT_NODE */, 11 /* DOCUMENT_FRAGMENT_NODE */)) {\n        return node;\n    }\n    /* istanbul ignore next */\n    return null;\n}\n/**\n * Returns the element children of node.\n *\n * (Non-standard) According to the spec, the children getter should return a live HTMLCollection.\n * This implementation returns a static array instead.\n *\n * @param node The node to get element children of\n *\n * @return The\n */\nexport function getChildren(node) {\n    var elements = [];\n    for (var child = node.firstElementChild; child; child = child.nextElementSibling) {\n        elements.push(child);\n    }\n    return elements;\n}\n// Element implements NonDocumentTypeChildNode;\n// CharacterData implements NonDocumentTypeChildNode;\nexport function asNonDocumentTypeChildNode(node) {\n    if (isNodeOfType(node, 1 /* ELEMENT_NODE */, 8 /* COMMENT_NODE */, 7 /* PROCESSING_INSTRUCTION_NODE */, 3 /* TEXT_NODE */, 4 /* CDATA_SECTION_NODE */)) {\n        return node;\n    }\n    return null;\n}\nexport function getPreviousElementSibling(node) {\n    for (var sibling = node.previousSibling; sibling; sibling = sibling.previousSibling) {\n        if (isNodeOfType(sibling, 1 /* ELEMENT_NODE */)) {\n            return sibling;\n        }\n    }\n    return null;\n}\nexport function getNextElementSibling(node) {\n    for (var sibling = node.nextSibling; sibling; sibling = sibling.nextSibling) {\n        if (isNodeOfType(sibling, 1 /* ELEMENT_NODE */)) {\n            return sibling;\n        }\n    }\n    return null;\n}\n// DocumentType implements ChildNode;\n// Element implements ChildNode;\n// CharacterData implements ChildNode;\n//# sourceMappingURL=mixins.js.map","import { asParentNode, asNonDocumentTypeChildNode } from '../mixins';\nimport { isNodeOfType } from './NodeType';\n/**\n * Insert node into parent's children before referenceNode.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node           Node to insert\n * @param parent         Parent to insert under\n * @param referenceChild Child to insert before\n */\nexport function insertIntoChildren(node, parent, referenceChild) {\n    // Node\n    node.parentNode = parent;\n    var previousSibling = referenceChild === null ? parent.lastChild : referenceChild.previousSibling;\n    var nextSibling = referenceChild === null ? null : referenceChild;\n    node.previousSibling = previousSibling;\n    node.nextSibling = nextSibling;\n    if (previousSibling) {\n        previousSibling.nextSibling = node;\n    }\n    else {\n        parent.firstChild = node;\n    }\n    if (nextSibling) {\n        nextSibling.previousSibling = node;\n        parent.childNodes.splice(parent.childNodes.indexOf(nextSibling), 0, node);\n    }\n    else {\n        parent.lastChild = node;\n        parent.childNodes.push(node);\n    }\n    // ParentNode\n    if (isNodeOfType(node, 1 /* ELEMENT_NODE */)) {\n        var element = node;\n        var parentNode = asParentNode(parent);\n        // Functions calling this will ensure parent is always a ParentNode\n        /* istanbul ignore else */\n        if (parentNode) {\n            var previousElementSibling = null;\n            for (var sibling = previousSibling; sibling; sibling = sibling.previousSibling) {\n                if (isNodeOfType(sibling, 1 /* ELEMENT_NODE */)) {\n                    previousElementSibling = sibling;\n                    break;\n                }\n                var siblingNonDocumentTypeChildNode = asNonDocumentTypeChildNode(sibling);\n                if (siblingNonDocumentTypeChildNode) {\n                    previousElementSibling = siblingNonDocumentTypeChildNode.previousElementSibling;\n                    break;\n                }\n            }\n            var nextElementSibling = null;\n            for (var sibling = nextSibling; sibling; sibling = sibling.nextSibling) {\n                if (isNodeOfType(sibling, 1 /* ELEMENT_NODE */)) {\n                    nextElementSibling = sibling;\n                    break;\n                }\n                var siblingNonDocumentTypeChildNode = asNonDocumentTypeChildNode(sibling);\n                // An element can never be inserted before a doctype\n                /* istanbul ignore else */\n                if (siblingNonDocumentTypeChildNode) {\n                    nextElementSibling = siblingNonDocumentTypeChildNode.nextElementSibling;\n                    break;\n                }\n            }\n            if (!previousElementSibling) {\n                parentNode.firstElementChild = element;\n            }\n            if (!nextElementSibling) {\n                parentNode.lastElementChild = element;\n            }\n            parentNode.childElementCount += 1;\n        }\n    }\n    // Document\n    if (isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        var parentDocument = parent;\n        if (isNodeOfType(node, 1 /* ELEMENT_NODE */)) {\n            parentDocument.documentElement = node;\n        }\n        else if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            parentDocument.doctype = node;\n        }\n    }\n}\n/**\n * Remove node from parent's children.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node   Node to remove\n * @param parent Parent to remove from\n */\nexport function removeFromChildren(node, parent) {\n    var previousSibling = node.previousSibling;\n    var nextSibling = node.nextSibling;\n    var isElement = isNodeOfType(node, 1 /* ELEMENT_NODE */);\n    var previousElementSibling = isElement ? node.previousElementSibling : null;\n    var nextElementSibling = isElement ? node.nextElementSibling : null;\n    // Node\n    node.parentNode = null;\n    node.previousSibling = null;\n    node.nextSibling = null;\n    if (previousSibling) {\n        previousSibling.nextSibling = nextSibling;\n    }\n    else {\n        parent.firstChild = nextSibling;\n    }\n    if (nextSibling) {\n        nextSibling.previousSibling = previousSibling;\n    }\n    else {\n        parent.lastChild = previousSibling;\n    }\n    parent.childNodes.splice(parent.childNodes.indexOf(node), 1);\n    // ParentNode\n    if (isElement) {\n        var parentNode = asParentNode(parent);\n        // Functions calling this will ensure parent is always a ParentNode\n        /* istanbul ignore else */\n        if (parentNode) {\n            if (parentNode.firstElementChild === node) {\n                parentNode.firstElementChild = nextElementSibling;\n            }\n            if (parentNode.lastElementChild === node) {\n                parentNode.lastElementChild = previousElementSibling;\n            }\n            parentNode.childElementCount -= 1;\n        }\n    }\n    // Document\n    if (isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        var parentDocument = parent;\n        if (isNodeOfType(node, 1 /* ELEMENT_NODE */)) {\n            parentDocument.documentElement = null;\n        }\n        else if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            parentDocument.doctype = null;\n        }\n    }\n}\n//# sourceMappingURL=treeMutations.js.map","/**\n * 3.3.3. Interface MutationRecord\n *\n * A helper class which describes a specific mutation as it is observed by a MutationObserver.\n */\nvar MutationRecord = /** @class */ (function () {\n    /**\n     * (non-standard) Constructs a MutationRecord\n     *\n     * @param type   The value for the type property\n     * @param target The value for the target property\n     */\n    function MutationRecord(type, target) {\n        /**\n         * Children of target added in this mutation.\n         *\n         * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n         * array.\n         */\n        this.addedNodes = [];\n        /**\n         * Children of target removed in this mutation.\n         *\n         * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n         * array.\n         */\n        this.removedNodes = [];\n        /**\n         * The previous sibling of the added or removed nodes, or null otherwise.\n         */\n        this.previousSibling = null;\n        /**\n         * The next sibling Node of the added or removed nodes, or null otherwise.\n         */\n        this.nextSibling = null;\n        /**\n         * The local name of the changed attribute, or null otherwise.\n         */\n        this.attributeName = null;\n        /**\n         * The namespace of the changed attribute, or null otherwise.\n         */\n        this.attributeNamespace = null;\n        /**\n         * The return value depends on type. For \"attributes\", it is the value of the changed attribute\n         * before the change. For \"characterData\", it is the data of the changed node before the change.\n         * For \"childList\", it is null.\n         */\n        this.oldValue = null;\n        this.type = type;\n        this.target = target;\n    }\n    return MutationRecord;\n}());\nexport default MutationRecord;\n//# sourceMappingURL=MutationRecord.js.map","import { getContext } from '../context/Context';\nimport { default as MutationRecord } from './MutationRecord';\n/**\n * 3.3.2. Queuing a mutation record\n *\n * To queue a mutation record of type for target with name, namespace, oldValue, addedNodes,\n * removedNodes, previousSibling and nextSibling, run these steps:\n * namespace namespace, oldValue oldValue, addedNodes addedNodes, removedNodes removedNodes,\n *\n * To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and\n * nextSibling, queue a mutation record of \"childList\" for target with null, null, null, addedNodes,\n * removedNodes, previousSibling, and nextSibling.\n *\n * To queue an attribute mutation record for target with name, namespace, and oldValue, queue a\n * mutation record of \"attributes\" for target with name, namespace, oldValue, « », « », null, and\n * null.\n *\n * @param type   The type of mutation record to queue\n * @param target The target node\n * @param data   The data for the mutation record\n */\nexport default function queueMutationRecord(type, target, data) {\n    // 1. Let interested observers be an empty map\n    var interestedObservers = [];\n    var pairedStrings = [];\n    // 2. Let nodes be the inclusive ancestors of target.\n    // 3. For each node in nodes, ...:\n    for (var node = target; node; node = node.parentNode) {\n        node._registeredObservers.collectInterestedObservers(type, target, data, interestedObservers, pairedStrings);\n    }\n    var context = getContext(target);\n    // 4. For each observer → mappedOldValue of interestedObservers:\n    interestedObservers.forEach(function (observer, index) {\n        var mappedOldValue = pairedStrings[index];\n        // 4.1. Let record be a new MutationRecord object with its type set to type and target set\n        // to target,\n        var record = new MutationRecord(type, target);\n        // ...attributeName set to to name, attributeNamespace set to namespace...\n        if (data.name !== undefined && data.namespace !== undefined) {\n            record.attributeName = data.name;\n            record.attributeNamespace = data.namespace;\n        }\n        // ...oldValue set to mappedOldValue...\n        if (mappedOldValue !== undefined) {\n            record.oldValue = mappedOldValue;\n        }\n        // ...addedNodes set to addedNodes...\n        if (data.addedNodes !== undefined) {\n            record.addedNodes = data.addedNodes;\n        }\n        // ...removedNodes set to removedNodes...\n        if (data.removedNodes !== undefined) {\n            record.removedNodes = data.removedNodes;\n        }\n        // ...previousSibling set to previousSibling...\n        if (data.previousSibling !== undefined) {\n            record.previousSibling = data.previousSibling;\n        }\n        // ...and nextSibling set to nextSibling.\n        if (data.nextSibling !== undefined) {\n            record.nextSibling = data.nextSibling;\n        }\n        // 4.2. Enqueue record to observer’s record queue.\n        context._notifyList.appendRecord(observer, record);\n    });\n    // 5. Queue a mutation observer compound microtask.\n    context._notifyList.queueMutationObserverCompoundMicrotask();\n}\n//# sourceMappingURL=queueMutationRecord.js.map","import { throwHierarchyRequestError, throwNotFoundError } from './errorHelpers';\nimport { isNodeOfType } from './NodeType';\nimport { determineLengthOfNode, getNodeDocument, getNodeIndex, forEachInclusiveDescendant } from './treeHelpers';\nimport { insertIntoChildren, removeFromChildren } from './treeMutations';\nimport { getContext } from '../context/Context';\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\n// 3.2.3. Mutation algorithms\n/**\n * To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n */\nfunction ensurePreInsertionValidity(node, parent, child) {\n    // 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n    // HierarchyRequestError.\n    if (!isNodeOfType(parent, 9 /* DOCUMENT_NODE */, 11 /* DOCUMENT_FRAGMENT_NODE */, 1 /* ELEMENT_NODE */)) {\n        throwHierarchyRequestError('parent must be a Document, DocumentFragment or Element node');\n    }\n    // 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n    if (node.contains(parent)) {\n        throwHierarchyRequestError('node must not be an inclusive ancestor of parent');\n    }\n    // 3. If child is not null and its parent is not parent, then throw a NotFoundError.\n    if (child && child.parentNode !== parent) {\n        throwNotFoundError('child is not a child of parent');\n    }\n    // 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n    // Comment node, throw a HierarchyRequestError.\n    if (!isNodeOfType(node, 11 /* DOCUMENT_FRAGMENT_NODE */, 10 /* DOCUMENT_TYPE_NODE */, 1 /* ELEMENT_NODE */, 3 /* TEXT_NODE */, 4 /* CDATA_SECTION_NODE */, 7 /* PROCESSING_INSTRUCTION_NODE */, 8 /* COMMENT_NODE */)) {\n        throwHierarchyRequestError('node must be a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction ' +\n            'or Comment node');\n    }\n    // 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n    // not a document, throw a HierarchyRequestError.\n    if (isNodeOfType(node, 3 /* TEXT_NODE */) && isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        throwHierarchyRequestError('can not insert a Text node under a Document');\n    }\n    if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */) &&\n        !isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        throwHierarchyRequestError('can only insert a DocumentType node under a Document');\n    }\n    // 6. If parent is a document, and any of the statements below, switched on node, are true,\n    // throw a HierarchyRequestError.\n    if (isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        var parentDocument = parent;\n        switch (node.nodeType) {\n            // DocumentFragment node\n            case 11 /* DOCUMENT_FRAGMENT_NODE */:\n                // If node has more than one element child or has a Text node child.\n                var fragment = node;\n                if (fragment.firstElementChild !== fragment.lastElementChild) {\n                    throwHierarchyRequestError('can not insert more than one element under a Document');\n                }\n                if (Array.from(fragment.childNodes).some(function (child) {\n                    return isNodeOfType(child, 3 /* TEXT_NODE */);\n                })) {\n                    throwHierarchyRequestError('can not insert a Text node under a Document');\n                }\n                // Otherwise, if node has one element child and either parent has an element child,\n                // child is a doctype, or child is not null and a doctype is following child.\n                if (fragment.firstElementChild &&\n                    (parentDocument.documentElement ||\n                        (child && isNodeOfType(child, 10 /* DOCUMENT_TYPE_NODE */)) ||\n                        (child &&\n                            parentDocument.doctype &&\n                            getNodeIndex(child) < getNodeIndex(parentDocument.doctype)))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n            // element\n            case 1 /* ELEMENT_NODE */:\n                // parent has an element child, child is a doctype, or child is not null and a\n                // doctype is following child.\n                if (parentDocument.documentElement ||\n                    (child && isNodeOfType(child, 10 /* DOCUMENT_TYPE_NODE */)) ||\n                    (child &&\n                        parentDocument.doctype &&\n                        getNodeIndex(child) < getNodeIndex(parentDocument.doctype))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n            // doctype\n            case 10 /* DOCUMENT_TYPE_NODE */:\n                // parent has a doctype child, child is non-null and an element is preceding child,\n                // or child is null and parent has an element child.\n                if (parentDocument.doctype ||\n                    (child &&\n                        parentDocument.documentElement &&\n                        getNodeIndex(parentDocument.documentElement) < getNodeIndex(child)) ||\n                    (!child && parentDocument.documentElement)) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n        }\n    }\n}\n/**\n * To pre-insert a node into a parent before a child, run these steps:\n *\n * @param node   Node to pre-insert\n * @param parent Parent to insert under\n * @param child  Child to insert before, or null to insert at the end of parent\n *\n * @return The inserted node\n */\nexport function preInsertNode(node, parent, child) {\n    // 1. Ensure pre-insertion validity of node into parent before child.\n    ensurePreInsertionValidity(node, parent, child);\n    // 2. Let reference child be child.\n    var referenceChild = child;\n    // 3. If reference child is node, set it to node’s next sibling.\n    if (referenceChild === node) {\n        referenceChild = node.nextSibling;\n    }\n    // 4. Adopt node into parent’s node document.\n    adoptNode(node, getNodeDocument(parent));\n    // 5. Insert node into parent before reference child.\n    insertNode(node, parent, referenceChild);\n    // 6. Return node.\n    return node;\n}\n/**\n * To insert a node into a parent before a child, with an optional suppress observers flag, run\n * these steps:\n *\n * @param node              Node to insert\n * @param parent            Parent to insert under\n * @param child             Child to insert before, or null to insert at end of parent\n * @param suppressObservers Whether to skip enqueueing a mutation record for this mutation\n */\nexport function insertNode(node, parent, child, suppressObservers) {\n    if (suppressObservers === void 0) { suppressObservers = false; }\n    // 1. Let count be the number of children of node if it is a DocumentFragment node, and one\n    // otherwise.\n    var isDocumentFragment = isNodeOfType(node, 11 /* DOCUMENT_FRAGMENT_NODE */);\n    var count = isDocumentFragment ? determineLengthOfNode(node) : 1;\n    // 2. If child is non-null, then:\n    if (child !== null) {\n        var childIndex_1 = getNodeIndex(child);\n        var context = getContext(node);\n        context._ranges.forEach(function (range) {\n            // 2.1. For each live range whose start node is parent and start offset is greater than\n            // child’s index, increase its start offset by count.\n            if (range.startContainer === parent && range.startOffset > childIndex_1) {\n                range.startOffset += count;\n            }\n            // 2.2. For each live range whose end node is parent and end offset is greater than\n            // child’s index, increase its end offset by count.\n            if (range.endContainer === parent && range.endOffset > childIndex_1) {\n                range.endOffset += count;\n            }\n        });\n    }\n    // 3. Let nodes be node’s children if node is a DocumentFragment node, and a list containing\n    // solely node otherwise.\n    var nodes = isDocumentFragment ? Array.from(node.childNodes) : [node];\n    // 4. If node is a DocumentFragment node, remove its children with the suppress observers flag\n    // set.\n    if (isDocumentFragment) {\n        nodes.forEach(function (n) { return removeNode(n, node, true); });\n    }\n    // 5. If node is a DocumentFragment node, then queue a tree mutation record for node with « »,\n    // nodes, null and null. This step intentionally does not pay attention to the suppress\n    // observers flag.\n    if (isDocumentFragment) {\n        queueMutationRecord('childList', node, {\n            removedNodes: nodes\n        });\n    }\n    // 6. Let previousSibling be child’s previous sibling or parent’s last child if child is null.\n    var previousSibling = child === null ? parent.lastChild : child.previousSibling;\n    // 7. For each node in nodes, in tree order:\n    nodes.forEach(function (node) {\n        // 7.1. If child is null, then append node to parent’s children.\n        // 7.2. Otherwise, insert node into parent’s children before child’s index.\n        insertIntoChildren(node, parent, child);\n        // 7.3. If parent is a shadow host and node is a slotable, then assign a slot for node.\n        // (shadow dom not implemented)\n        // 7.4. If node is a Text node, run the child text content change steps for parent.\n        // (child text content change steps not implemented)\n        // 7.5. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the\n        // empty list, then run signal a slot change for parent.\n        // 7.6. Run assign slotables for a tree with node’s tree.\n        // (shadow dom not implemented)\n        // 7.7. For each shadow-including inclusive descendant inclusiveDescendant of node, in\n        // shadow-including tree order:\n        // 7.7.1. Run the insertion steps with inclusiveDescendant.\n        // (insertion steps not implemented)\n        // 7.7.2. If inclusiveDescendant is connected, then:\n        // 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom element callback\n        // reaction with inclusiveDescendant, callback name \"connectedCallback\", and an empty\n        // argument list.\n        // 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant. If this successfully upgrades\n        // inclusiveDescendant, its connectedCallback will be enqueued automatically during the\n        // upgrade an element algorithm.\n        // (custom elements not implemented)\n    });\n    // 8. If suppress observers flag is unset, queue a tree mutation record for parent with nodes,\n    // « », previousSibling and child.\n    if (!suppressObservers) {\n        queueMutationRecord('childList', parent, {\n            addedNodes: nodes,\n            nextSibling: child,\n            previousSibling: previousSibling\n        });\n    }\n}\n/**\n * To append a node to a parent\n *\n * @param node   Node to append\n * @param parent Parent to append to\n *\n * @return The appended node\n */\nexport function appendNode(node, parent) {\n    // pre-insert node into parent before null.\n    return preInsertNode(node, parent, null);\n}\n/**\n * To replace a child with node within a parent, run these steps:\n *\n * @param child  The child node to replace\n * @param node   The node to replace child with\n * @param parent The parent to replace under\n *\n * @return The old child node\n */\nexport function replaceChildWithNode(child, node, parent) {\n    // 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n    // HierarchyRequestError.\n    if (!isNodeOfType(parent, 9 /* DOCUMENT_NODE */, 11 /* DOCUMENT_FRAGMENT_NODE */, 1 /* ELEMENT_NODE */)) {\n        throwHierarchyRequestError('Can not replace under a non-parent node');\n    }\n    // 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n    if (node.contains(parent)) {\n        throwHierarchyRequestError('Can not insert a node under its own descendant');\n    }\n    // 3. If child’s parent is not parent, then throw a NotFoundError.\n    if (child.parentNode !== parent) {\n        throwNotFoundError('child is not a child of parent');\n    }\n    // 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n    // Comment node, throw a HierarchyRequestError.\n    if (!isNodeOfType(node, 11 /* DOCUMENT_FRAGMENT_NODE */, 10 /* DOCUMENT_TYPE_NODE */, 1 /* ELEMENT_NODE */, 3 /* TEXT_NODE */, 4 /* CDATA_SECTION_NODE */, 7 /* PROCESSING_INSTRUCTION_NODE */, 8 /* COMMENT_NODE */)) {\n        throwHierarchyRequestError(\"Can not insert a node that isn't a DocumentFragment, DocumentType, Element, Text, \" +\n            'ProcessingInstruction or Comment');\n    }\n    // 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n    // not a document, throw a HierarchyRequestError.\n    if (isNodeOfType(node, 3 /* TEXT_NODE */) && isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        throwHierarchyRequestError('can not insert a Text node under a Document');\n    }\n    if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */) &&\n        !isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        throwHierarchyRequestError('can only insert a DocumentType node under a Document');\n    }\n    // 6. If parent is a document, and any of the statements below, switched on node, are true,\n    // throw a HierarchyRequestError.\n    if (isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        var parentDocument = parent;\n        switch (node.nodeType) {\n            // DocumentFragment node\n            case 11 /* DOCUMENT_FRAGMENT_NODE */:\n                // If node has more than one element child or has a Text node child.\n                var fragment = node;\n                if (fragment.firstElementChild !== fragment.lastElementChild) {\n                    throwHierarchyRequestError('can not insert more than one element under a Document');\n                }\n                if (Array.from(fragment.childNodes).some(function (child) {\n                    return isNodeOfType(child, 3 /* TEXT_NODE */);\n                })) {\n                    throwHierarchyRequestError('can not insert a Text node under a Document');\n                }\n                // Otherwise, if node has one element child and either parent has an element child\n                // that is not child or a doctype is following child.\n                if (fragment.firstElementChild &&\n                    ((parentDocument.documentElement &&\n                        parentDocument.documentElement !== child) ||\n                        (child &&\n                            parentDocument.doctype &&\n                            getNodeIndex(child) < getNodeIndex(parentDocument.doctype)))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n            // element\n            case 1 /* ELEMENT_NODE */:\n                // parent has an element child that is not child or a doctype is following child.\n                if ((parentDocument.documentElement &&\n                    parentDocument.documentElement !== child) ||\n                    (parentDocument.doctype &&\n                        getNodeIndex(child) < getNodeIndex(parentDocument.doctype))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n            // doctype\n            case 10 /* DOCUMENT_TYPE_NODE */:\n                // parent has a doctype child that is not child, or an element is preceding child.\n                if ((parentDocument.doctype && parentDocument.doctype !== child) ||\n                    (parentDocument.documentElement &&\n                        getNodeIndex(parentDocument.documentElement) < getNodeIndex(child))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n        }\n        // The above statements differ from the pre-insert algorithm.\n    }\n    // 7. Let reference child be child’s next sibling.\n    var referenceChild = child.nextSibling;\n    // 8. If reference child is node, set it to node’s next sibling.\n    if (referenceChild === node) {\n        referenceChild = node.nextSibling;\n    }\n    // 9. Let previousSibling be child’s previous sibling.\n    var previousSibling = child.previousSibling;\n    // 10. Adopt node into parent’s node document.\n    adoptNode(node, getNodeDocument(parent));\n    // 11. Let removedNodes be the empty list.\n    var removedNodes = [];\n    // 12. If child’s parent is not null, then:\n    if (child.parentNode !== null) {\n        // 12.1. Set removedNodes to a list solely containing child.\n        removedNodes.push(child);\n        // 12.2. Remove child from its parent with the suppress observers flag set.\n        removeNode(child, child.parentNode, true);\n    }\n    // The above can only be false if child is node.\n    // 13. Let nodes be node’s children if node is a DocumentFragment node, and a list containing\n    // solely node otherwise.\n    var nodes = isNodeOfType(node, 11 /* DOCUMENT_FRAGMENT_NODE */)\n        ? Array.from(node.childNodes)\n        : [node];\n    // 14. Insert node into parent before reference child with the suppress observers flag set.\n    insertNode(node, parent, referenceChild, true);\n    // 15. Queue a tree mutation record for parent with nodes, removedNodes, previousSibling and\n    // reference child.\n    queueMutationRecord('childList', parent, {\n        addedNodes: nodes,\n        removedNodes: removedNodes,\n        nextSibling: referenceChild,\n        previousSibling: previousSibling\n    });\n    // 16. Return child.\n    return child;\n}\n/**\n * To pre-remove a child from a parent, run these steps:\n *\n * @param child  Child node to remove\n * @param parent Parent under which to remove child\n *\n * @return The removed child\n */\nexport function preRemoveChild(child, parent) {\n    // 1. If child’s parent is not parent, then throw a NotFoundError.\n    if (child.parentNode !== parent) {\n        throwNotFoundError('child is not a child of parent');\n    }\n    // 2. Remove child from parent.\n    removeNode(child, parent);\n    // 3. Return child.\n    return child;\n}\n/**\n * To remove a node from a parent, with an optional suppress observers flag, run these steps:\n *\n * @param node              Child to remove\n * @param parent            Parent to remove child from\n * @param suppressObservers Whether to skip enqueueing a mutation record for this mutation\n */\nexport function removeNode(node, parent, suppressObservers) {\n    if (suppressObservers === void 0) { suppressObservers = false; }\n    // 1. Let index be node’s index.\n    var index = getNodeIndex(node);\n    var context = getContext(node);\n    context._ranges.forEach(function (range) {\n        // 2. For each live range whose start node is an inclusive descendant of node, set its start\n        // to (parent, index).\n        if (node.contains(range.startContainer)) {\n            range.startContainer = parent;\n            range.startOffset = index;\n        }\n        // 3. For each live range whose end node is an inclusive descendant of node, set its end to\n        // (parent, index).\n        if (node.contains(range.endContainer)) {\n            range.endContainer = parent;\n            range.endOffset = index;\n        }\n        // 4. For each live range whose start node is parent and start offset is greater than index,\n        // decrease its start offset by one.\n        if (range.startContainer === parent && range.startOffset > index) {\n            range.startOffset -= 1;\n        }\n        // 5. For each live range whose end node is parent and end offset is greater than index,\n        // decrease its end offset by one.\n        if (range.endContainer === parent && range.endOffset > index) {\n            range.endOffset -= 1;\n        }\n    });\n    // 6. For each NodeIterator object iterator whose root’s node document is node’s node document,\n    // run the NodeIterator pre-removing steps given node and iterator.\n    // (NodeIterator not implemented)\n    // 7. Let oldPreviousSibling be node’s previous sibling.\n    var oldPreviousSibling = node.previousSibling;\n    // 8. Let oldNextSibling be node’s next sibling.\n    var oldNextSibling = node.nextSibling;\n    // 9. Remove node from its parent’s children.\n    removeFromChildren(node, parent);\n    // 10. If node is assigned, then run assign slotables for node’s assigned slot.\n    // (shadow dom not implemented)\n    // 11. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the empty\n    // list, then run signal a slot change for parent.\n    // (shadow dom not implemented)\n    // 12. If node has an inclusive descendant that is a slot, then:\n    // 12.1. Run assign slotables for a tree with parent’s tree.\n    // 12.2. Run assign slotables for a tree with node’s tree.\n    // (shadow dom not implemented)\n    // 13. Run the removing steps with node and parent.\n    // (removing steps not implemented)\n    // 14. If node is custom, then enqueue a custom element callback reaction with node, callback\n    // name \"disconnectedCallback\", and an empty argument list.\n    // It is intentional for now that custom elements do not get parent passed. This might change in\n    // the future if there is a need.\n    // (custom elements not implemented)\n    // 15. For each shadow-including descendant descendant of node, in shadow-including tree order,\n    // then:\n    // 15.1. Run the removing steps with descendant.\n    // (shadow dom not implemented)\n    // 15.2. If descendant is custom, then enqueue a custom element callback reaction with\n    // descendant, callback name \"disconnectedCallback\", and an empty argument list.\n    // (custom elements not implemented)\n    // 16. For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of\n    // inclusiveAncestor's registered observer list, if registered's options's subtree is true, then\n    // append a new transient registered observer whose observer is registered's observer, options\n    // is registered's options, and source is registered to node's registered observer list.\n    for (var inclusiveAncestor = parent; inclusiveAncestor; inclusiveAncestor = inclusiveAncestor.parentNode) {\n        inclusiveAncestor._registeredObservers.appendTransientRegisteredObservers(node);\n    }\n    // 17. If suppress observers flag is unset, queue a tree mutation record for parent with « »,\n    // « node », oldPreviousSibling, and oldNextSibling\n    if (!suppressObservers) {\n        queueMutationRecord('childList', parent, {\n            removedNodes: [node],\n            nextSibling: oldNextSibling,\n            previousSibling: oldPreviousSibling\n        });\n    }\n    // 18. If node is a Text node, then run the child text content change steps for parent.\n    // (child text content change steps not implemented)\n}\n/**\n * 3.5. Interface Document\n *\n * To adopt a node into a document, run these steps:\n *\n * @param node     Node to adopt\n * @param document Document to adopt node into\n */\nexport function adoptNode(node, document) {\n    // 1. Let oldDocument be node’s node document.\n    var oldDocument = getNodeDocument(node);\n    // 2. If node’s parent is not null, remove node from its parent.\n    if (node.parentNode) {\n        removeNode(node, node.parentNode);\n    }\n    // 3. If document is not oldDocument, then:\n    if (document === oldDocument) {\n        return;\n    }\n    // 3.1. For each inclusiveDescendant in node’s shadow-including inclusive descendants:\n    forEachInclusiveDescendant(node, function (node) {\n        // 3.1.1. Set inclusiveDescendant’s node document to document.\n        // (calling code ensures that node is never a Document)\n        node.ownerDocument = document;\n        // 3.1.2. If inclusiveDescendant is an element, then set the node document of each attribute\n        // in inclusiveDescendant’s attribute list to document.\n        if (isNodeOfType(node, 1 /* ELEMENT_NODE */)) {\n            for (var _i = 0, _a = node.attributes; _i < _a.length; _i++) {\n                var attr = _a[_i];\n                attr.ownerDocument = document;\n            }\n        }\n    });\n    // 3.2. For each inclusiveDescendant in node’s shadow-including inclusive descendants that is\n    // custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name\n    // \"adoptedCallback\", and an argument list containing oldDocument and document.\n    // (custom element support has not been implemented)\n    // 3.3. For each inclusiveDescendant in node’s shadow-including inclusive descendants, in\n    // shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.\n    // (adopting steps not implemented)\n}\n//# sourceMappingURL=mutationAlgorithms.js.map","import { expectObject } from './errorHelpers';\nexport function asUnsignedLong(number) {\n    return number >>> 0;\n}\nexport function treatNullAsEmptyString(value) {\n    // Treat null as empty string\n    if (value === null) {\n        return '';\n    }\n    // Coerce other values to string\n    return String(value);\n}\nexport function asObject(value, Constructor) {\n    expectObject(value, Constructor);\n    return value;\n}\nexport function asNullableObject(value, Constructor) {\n    if (value === undefined || value === null) {\n        return null;\n    }\n    return asObject(value, Constructor);\n}\nexport function asNullableString(value) {\n    // Treat undefined as null\n    if (value === undefined) {\n        return null;\n    }\n    return value;\n}\n//# sourceMappingURL=typeHelpers.js.map","import { getContext } from './context/Context';\nimport RegisteredObservers from './mutation-observer/RegisteredObservers';\nimport cloneNode from './util/cloneNode';\nimport { expectArity } from './util/errorHelpers';\nimport { preInsertNode, appendNode, replaceChildWithNode, preRemoveChild, removeNode } from './util/mutationAlgorithms';\nimport { isNodeOfType } from './util/NodeType';\nimport { getNodeDocument } from './util/treeHelpers';\nimport { asNullableObject, asNullableString, asObject } from './util/typeHelpers';\n/**\n * 3.4. Interface Node\n */\nvar Node = /** @class */ (function () {\n    function Node() {\n        /**\n         * A reference to the Document node in which the current node resides.\n         */\n        this.ownerDocument = null;\n        /**\n         * The parent node of the current node.\n         */\n        this.parentNode = null;\n        /**\n         * The node's children.\n         *\n         * Non-standard: implemented as an array rather than a NodeList.\n         */\n        this.childNodes = [];\n        /**\n         * The first child node of the current node, or null if it has no children.\n         */\n        this.firstChild = null;\n        /**\n         * The last child node of the current node, or null if it has no children.\n         */\n        this.lastChild = null;\n        /**\n         * The first preceding sibling of the current node, or null if it has none.\n         */\n        this.previousSibling = null;\n        /**\n         * The first following sibling of the current node, or null if it has none.\n         */\n        this.nextSibling = null;\n        /**\n         * (non-standard)\n         * Each node has a registered observer list of zero or more registered observers, which is\n         * initially empty.\n         */\n        this._registeredObservers = new RegisteredObservers(this);\n    }\n    Object.defineProperty(Node.prototype, \"parentElement\", {\n        /**\n         * The parent if it is an element, or null otherwise.\n         */\n        get: function () {\n            return this.parentNode && isNodeOfType(this.parentNode, 1 /* ELEMENT_NODE */)\n                ? this.parentNode\n                : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns true if the context object has children, and false otherwise.\n     */\n    Node.prototype.hasChildNodes = function () {\n        return !!this.childNodes.length;\n    };\n    /**\n     * Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized\n     * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.\n     */\n    Node.prototype.normalize = function () {\n        var _this = this;\n        // for each descendant exclusive Text node node of context object:\n        var node = this.firstChild;\n        var index = 0;\n        var document = getNodeDocument(this);\n        var _loop_1 = function () {\n            var nextNode = node.nextSibling;\n            if (!isNodeOfType(node, 3 /* TEXT_NODE */)) {\n                // Process descendants\n                node.normalize();\n                node = nextNode;\n                return \"continue\";\n            }\n            var textNode = node;\n            // 1. Let length be node’s length.\n            var length = textNode.length;\n            // 2. If length is zero, then remove node and continue with the next exclusive Text\n            // node, if any.\n            if (length === 0) {\n                removeNode(node, this_1);\n                --index;\n                node = nextNode;\n                return \"continue\";\n            }\n            // 3. Let data be the concatenation of the data of node’s contiguous exclusive Text\n            // nodes (excluding itself), in tree order.\n            var data = '';\n            var siblingsToRemove = [];\n            for (var sibling = textNode.nextSibling; sibling && isNodeOfType(sibling, 3 /* TEXT_NODE */); sibling = sibling.nextSibling) {\n                data += sibling.data;\n                siblingsToRemove.push(sibling);\n            }\n            // 4. Replace data with node node, offset length, count 0, and data data.\n            if (data) {\n                textNode.replaceData(length, 0, data);\n            }\n            // 5. Let currentNode be node’s next sibling.\n            // 6. While currentNode is an exclusive Text node:\n            var context = getContext(this_1);\n            var _loop_2 = function (i, l) {\n                var currentNode = siblingsToRemove[i];\n                var currentNodeIndex = index + i + 1;\n                context._ranges.forEach(function (range) {\n                    // 6.1. For each live range whose start node is currentNode, add length to its\n                    // start offset and set its start node to node.\n                    if (range.startContainer === currentNode) {\n                        range.startOffset += length;\n                        range.startContainer = textNode;\n                    }\n                    // 6.2. For each live range whose end node is currentNode, add length to its end\n                    // offset and set its end node to node.\n                    if (range.endContainer === currentNode) {\n                        range.endOffset += length;\n                        range.endContainer = textNode;\n                    }\n                    // 6.3. For each live range whose start node is currentNode’s parent and start\n                    // offset is currentNode’s index, set its start node to node and its start\n                    // offset to length.\n                    if (range.startContainer === _this && range.startOffset === currentNodeIndex) {\n                        range.startContainer = textNode;\n                        range.startOffset = length;\n                    }\n                    // 6.4. For each live range whose end node is currentNode’s parent and end\n                    // offset is currentNode’s index, set its end node to node and its end offset to\n                    // length.\n                    if (range.endContainer === _this && range.endOffset === currentNodeIndex) {\n                        range.endContainer = textNode;\n                        range.endOffset = length;\n                    }\n                });\n                // 6.5. Add currentNode’s length to length.\n                length += currentNode.length;\n            };\n            for (var i = 0, l = siblingsToRemove.length; i < l; ++i) {\n                _loop_2(i, l);\n            }\n            // 7. Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.\n            while (siblingsToRemove.length) {\n                removeNode(siblingsToRemove.shift(), this_1);\n            }\n            // Move to next node\n            node = node.nextSibling;\n            ++index;\n        };\n        var this_1 = this;\n        while (node) {\n            _loop_1();\n        }\n        // Note: normalize() does not need to run any child text content change steps, since\n        // although it messes with Text nodes extensively, it does so specifically in a way that\n        // preserves the child text content.\n    };\n    /**\n     * Returns a copy of the current node.\n     *\n     * @param deep Whether to also clone the node's descendants\n     *\n     * @return A copy of the current node\n     */\n    Node.prototype.cloneNode = function (deep) {\n        if (deep === void 0) { deep = false; }\n        return cloneNode(this, deep);\n    };\n    /**\n     * Returns true if other is an inclusive descendant of context object, and false otherwise\n     * (including when other is null).\n     *\n     * @param childNode Node to check\n     *\n     * @return Whether childNode is an inclusive descendant of the current node\n     */\n    Node.prototype.contains = function (other) {\n        expectArity(arguments, 1);\n        other = asNullableObject(other, Node);\n        while (other && other != this) {\n            other = other.parentNode;\n        }\n        return other === this;\n    };\n    /**\n     * Return true if defaultNamespace is the same as namespace, and false otherwise.\n     *\n     * @param namespace The namespace to check\n     *\n     * @return Whether namespace is the default namespace\n     */\n    Node.prototype.isDefaultNamespace = function (namespace) {\n        expectArity(arguments, 1);\n        namespace = asNullableString(namespace);\n        // 1. If namespace is the empty string, then set it to null.\n        if (namespace === '') {\n            namespace = null;\n        }\n        // 2. Let defaultNamespace be the result of running locate a namespace for context object\n        // using null.\n        var defaultNamespace = this.lookupNamespaceURI(null);\n        // 3. Return true if defaultNamespace is the same as namespace, and false otherwise.\n        return defaultNamespace === namespace;\n    };\n    /**\n     * Inserts the specified node before child within context object.\n     *\n     * If child is null, the new node is appended after the last child node of the current node.\n     *\n     * @param node  Node to insert\n     * @param child Childnode of the current node before which to insert, or null to append newNode\n     *              at the end\n     *\n     * @return The node that was inserted\n     */\n    Node.prototype.insertBefore = function (node, child) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        child = asNullableObject(child, Node);\n        return preInsertNode(node, this, child);\n    };\n    /**\n     * Adds node to the end of the list of children of the context object.\n     *\n     * If the node already exists it is removed from its current parent node, then added.\n     *\n     * @param node Node to append\n     *\n     * @return The node that was inserted\n     */\n    Node.prototype.appendChild = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        return appendNode(node, this);\n    };\n    /**\n     * Replaces child with node within context object and returns child.\n     *\n     * @param node  Node to insert\n     * @param child Node to remove\n     *\n     * @return The node that was removed\n     */\n    Node.prototype.replaceChild = function (node, child) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        child = asObject(child, Node);\n        return replaceChildWithNode(child, node, this);\n    };\n    /**\n     * Removes child from context object and returns the removed node.\n     *\n     * @param child Child of the current node to remove\n     *\n     * @return The node that was removed\n     */\n    Node.prototype.removeChild = function (child) {\n        expectArity(arguments, 1);\n        child = asObject(child, Node);\n        return preRemoveChild(child, this);\n    };\n    Node.ELEMENT_NODE = 1 /* ELEMENT_NODE */;\n    Node.ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;\n    Node.TEXT_NODE = 3 /* TEXT_NODE */;\n    Node.CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;\n    Node.ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */; // historical\n    Node.ENTITY_NODE = 6 /* ENTITY_NODE */; // historical\n    Node.PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;\n    Node.COMMENT_NODE = 8 /* COMMENT_NODE */;\n    Node.DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;\n    Node.DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;\n    Node.DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;\n    Node.NOTATION_NODE = 12 /* NOTATION_NODE */; // historical\n    return Node;\n}());\nexport default Node;\nNode.prototype.ELEMENT_NODE = 1 /* ELEMENT_NODE */;\nNode.prototype.ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;\nNode.prototype.TEXT_NODE = 3 /* TEXT_NODE */;\nNode.prototype.CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;\nNode.prototype.ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */; // historical\nNode.prototype.ENTITY_NODE = 6 /* ENTITY_NODE */; // historical\nNode.prototype.PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;\nNode.prototype.COMMENT_NODE = 8 /* COMMENT_NODE */;\nNode.prototype.DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;\nNode.prototype.DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;\nNode.prototype.DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;\nNode.prototype.NOTATION_NODE = 12 /* NOTATION_NODE */; // historical\n//# sourceMappingURL=Node.js.map","import queueMutationRecord from '../mutation-observer/queueMutationRecord';\n/**\n * To change an attribute attribute from an element element to value, run these steps:\n *\n * @param attribute The attribute to change\n * @param element   The element that has the attribute\n * @param value     The new value for the attribute\n */\nexport function changeAttribute(attribute, element, value) {\n    // 1. Queue an attribute mutation record for element with attribute’s local name, attribute's\n    // namespace, and attribute’s value.\n    queueMutationRecord('attributes', element, {\n        name: attribute.localName,\n        namespace: attribute.namespaceURI,\n        oldValue: attribute.value\n    });\n    // 2. If element is custom, then enqueue a custom element callback reaction with element,\n    // callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n    // name, attribute’s value, value, and attribute’s namespace.\n    // (custom elements not implemented)\n    // 3. Run the attribute change steps with element, attribute’s local name, attribute’s value,\n    // value, and attribute’s namespace.\n    // (attribute change steps not implemented)\n    // 4. Set attribute’s value to value.\n    attribute._value = value;\n}\n/**\n * To append an attribute attribute to an element element, run these steps:\n *\n * @param attribute The attribute to append\n * @param element   The element to append attribute to\n */\nexport function appendAttribute(attribute, element) {\n    // 1. Queue an attribute mutation record for element with attribute’s local name, attribute's\n    // namespace, and null.\n    queueMutationRecord('attributes', element, {\n        name: attribute.localName,\n        namespace: attribute.namespaceURI,\n        oldValue: null\n    });\n    // 2. If element is custom, then enqueue a custom element callback reaction with element,\n    // callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n    // name, null, attribute’s value, and attribute’s namespace.\n    // (custom elements not implemented)\n    // 3. Run the attribute change steps with element, attribute’s local name, null, attribute’s\n    // value, and attribute’s namespace.\n    // (attribute change steps not implemented)\n    // 4. Append attribute to element’s attribute list.\n    element.attributes.push(attribute);\n    // 5. Set attribute’s element to element.\n    attribute.ownerElement = element;\n}\n/**\n * To remove an attribute attribute from an element element, run these steps:\n *\n * @param attribute The attribute to remove\n * @param element   The element to remove attribute from\n */\nexport function removeAttribute(attribute, element) {\n    // 1. Queue an attribute mutation record for element with attribute’s local name, attribute's\n    // namespace, and attribute’s value.\n    queueMutationRecord('attributes', element, {\n        name: attribute.localName,\n        namespace: attribute.namespaceURI,\n        oldValue: attribute.value\n    });\n    // 2. If element is custom, then enqueue a custom element callback reaction with element,\n    // callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n    // name, attribute’s value, null, and attribute’s namespace.\n    // (custom elements not implemented)\n    // 3. Run the attribute change steps with element, attribute’s local name, attribute’s value,\n    // null, and attribute’s namespace.\n    // (attribute change steps not implemented)\n    // 4. Remove attribute from element’s attribute list.\n    element.attributes.splice(element.attributes.indexOf(attribute), 1);\n    // 5. Set attribute’s element to null.\n    attribute.ownerElement = null;\n}\n/**\n * To replace an attribute oldAttr by an attribute newAttr in an element element, run these steps:\n *\n * @param oldAttr The attribute to replace\n * @param newAttr The attribute to replace oldAttr with\n * @param element The element on which to replace the attribute\n */\nexport function replaceAttribute(oldAttr, newAttr, element) {\n    // 1. Queue an attribute mutation record for element with oldAttr’s local name, oldAttr’s\n    // namespace, and oldAttr’s value.\n    queueMutationRecord('attributes', element, {\n        name: oldAttr.localName,\n        namespace: oldAttr.namespaceURI,\n        oldValue: oldAttr.value\n    });\n    // 2. If element is custom, then enqueue a custom element callback reaction with element,\n    // callback name \"attributeChangedCallback\", and an argument list containing oldAttr’s local\n    // name, oldAttr’s value, newAttr’s value, and oldAttr’s namespace.\n    // (custom elements not implemented)\n    // 3. Run the attribute change steps with element, oldAttr’s local name, oldAttr’s value,\n    // newAttr’s value, and oldAttr’s namespace.\n    // (attribute change steps not implemented)\n    // 4. Replace oldAttr by newAttr in element’s attribute list.\n    element.attributes.splice(element.attributes.indexOf(oldAttr), 1, newAttr);\n    // 5. Set oldAttr’s element to null.\n    oldAttr.ownerElement = null;\n    // 6. Set newAttr’s element to element.\n    newAttr.ownerElement = element;\n}\n//# sourceMappingURL=attrMutations.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { changeAttribute } from './util/attrMutations';\nimport { expectArity } from './util/errorHelpers';\nimport { treatNullAsEmptyString } from './util/typeHelpers';\n/**\n * 3.9.2. Interface Attr\n */\nvar Attr = /** @class */ (function (_super) {\n    __extends(Attr, _super);\n    /**\n     * (non-standard) use Document#createAttribute(NS) or Element#setAttribute(NS) to create\n     * attribute nodes\n     *\n     * @param namespace The namespace URI for the attribute\n     * @param prefix    The prefix for the attribute\n     * @param localName The local name for the attribute\n     * @param value     The value for the attribute\n     * @param element   The element for the attribute, or null if the attribute is not attached to\n     *                  an element\n     */\n    function Attr(namespace, prefix, localName, value, element) {\n        var _this = _super.call(this) || this;\n        _this.namespaceURI = namespace;\n        _this.prefix = prefix;\n        _this.localName = localName;\n        _this.name = prefix === null ? localName : prefix + \":\" + localName;\n        _this._value = value;\n        _this.ownerElement = element;\n        return _this;\n    }\n    Object.defineProperty(Attr.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 2 /* ATTRIBUTE_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Attr.prototype, \"nodeName\", {\n        get: function () {\n            // Return the qualified name\n            return this.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Attr.prototype, \"nodeValue\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (newValue) {\n            newValue = treatNullAsEmptyString(newValue);\n            // Set an existing attribute value with context object and new value.\n            setExistingAttributeValue(this, newValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Attr.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to recursion)\n        // 2. Switch on the context object:\n        // Attr - Return the result of locating a namespace prefix for its element, if its element\n        // is non-null, and null otherwise.\n        if (this.ownerElement !== null) {\n            return this.ownerElement.lookupPrefix(namespace);\n        }\n        return null;\n    };\n    Attr.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to recursion)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: Attr\n        // 1. If its element is null, then return null.\n        if (this.ownerElement === null) {\n            return null;\n        }\n        // 2. Return the result of running locate a namespace on its element using prefix.\n        return this.ownerElement.lookupNamespaceURI(prefix);\n    };\n    Object.defineProperty(Attr.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (value) {\n            setExistingAttributeValue(this, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    Attr.prototype._copy = function (document) {\n        // Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n        var context = getContext(document);\n        var copy = new context.Attr(this.namespaceURI, this.prefix, this.localName, this.value, null);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return Attr;\n}(Node));\nexport default Attr;\n/**\n * To set an existing attribute value, given an attribute attribute and string value, run these\n * steps:\n *\n * @param attribute The attribute to set the value of\n * @param value     The new value for attribute\n */\nfunction setExistingAttributeValue(attribute, value) {\n    // 1. If attribute’s element is null, then set attribute’s value to value.\n    var element = attribute.ownerElement;\n    if (element === null) {\n        attribute._value = value;\n    }\n    else {\n        // 2. Otherwise, change attribute from attribute’s element to value.\n        changeAttribute(attribute, element, value);\n    }\n}\n//# sourceMappingURL=Attr.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getNextElementSibling, getPreviousElementSibling } from './mixins';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport queueMutationRecord from './mutation-observer/queueMutationRecord';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport { asUnsignedLong, treatNullAsEmptyString } from './util/typeHelpers';\n/**\n * 3.10. Interface CharacterData\n */\nvar CharacterData = /** @class */ (function (_super) {\n    __extends(CharacterData, _super);\n    /**\n     * (non-standard) CharacterData should never be instantiated directly.\n     *\n     * @param data The data to associate with the node\n     */\n    function CharacterData(data) {\n        var _this = _super.call(this) || this;\n        _this._data = String(data);\n        return _this;\n    }\n    Object.defineProperty(CharacterData.prototype, \"nodeValue\", {\n        // Node\n        get: function () {\n            return this._data;\n        },\n        set: function (newValue) {\n            newValue = treatNullAsEmptyString(newValue);\n            // Set an existing attribute value with context object and new value.\n            replaceData(this, 0, this.length, newValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CharacterData.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to recursion)\n        // 2. Switch on the context object:\n        // Any other node - Return the result of locating a namespace prefix for its parent element,\n        // if its parent element is non-null, and null otherwise.\n        var parentElement = this.parentElement;\n        if (parentElement !== null) {\n            return parentElement.lookupPrefix(namespace);\n        }\n        return null;\n    };\n    CharacterData.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to recursion)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: Any other node\n        // 1. If its parent element is null, then return null.\n        var parentElement = this.parentElement;\n        if (parentElement === null) {\n            return null;\n        }\n        // 2. Return the result of running locate a namespace on its parent element using prefix.\n        return parentElement.lookupNamespaceURI(prefix);\n    };\n    Object.defineProperty(CharacterData.prototype, \"previousElementSibling\", {\n        // NonDocumentTypeChildNode\n        get: function () {\n            return getPreviousElementSibling(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CharacterData.prototype, \"nextElementSibling\", {\n        get: function () {\n            return getNextElementSibling(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CharacterData.prototype, \"data\", {\n        get: function () {\n            return this._data;\n        },\n        set: function (newValue) {\n            // [TreatNullAs=EmptyString]\n            newValue = treatNullAsEmptyString(newValue);\n            // replace data with node context object, offset 0, count context object’s length, and data\n            // new value.\n            replaceData(this, 0, this.length, newValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CharacterData.prototype, \"length\", {\n        get: function () {\n            return this.data.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns a substring of the node's data.\n     *\n     * @param offset Offset at which to start the substring\n     * @param count  The number of code units to return\n     *\n     * @return The specified substring\n     */\n    CharacterData.prototype.substringData = function (offset, count) {\n        expectArity(arguments, 2);\n        return substringData(this, offset, count);\n    };\n    /**\n     * Appends data to the node's data.\n     *\n     * @param data Data to append\n     */\n    CharacterData.prototype.appendData = function (data) {\n        expectArity(arguments, 1);\n        replaceData(this, this.length, 0, data);\n    };\n    /**\n     * Inserts data at the specified position in the node's data.\n     *\n     * @param offset Offset at which to insert\n     * @param data   Data to insert\n     */\n    CharacterData.prototype.insertData = function (offset, data) {\n        expectArity(arguments, 1);\n        replaceData(this, offset, 0, data);\n    };\n    /**\n     * Deletes data from the specified position.\n     *\n     * @param offset Offset at which to delete\n     * @param count  Number of code units to delete\n     */\n    CharacterData.prototype.deleteData = function (offset, count) {\n        expectArity(arguments, 2);\n        replaceData(this, offset, count, '');\n    };\n    /**\n     * Replaces data at the specified position.\n     *\n     * @param offset Offset at which to replace\n     * @param count  Number of code units to remove\n     * @param data   Data to insert\n     */\n    CharacterData.prototype.replaceData = function (offset, count, data) {\n        expectArity(arguments, 3);\n        replaceData(this, offset, count, data);\n    };\n    return CharacterData;\n}(Node));\nexport default CharacterData;\n/**\n * To replace data of node node with offset offset, count count, and data data, run these steps:\n *\n * @param node   The node to replace data on\n * @param offset The offset at which to start replacing\n * @param count  The number of code units to replace\n * @param data   The data to insert in place of the removed data\n */\nexport function replaceData(node, offset, count, data) {\n    // Match spec data types\n    offset = asUnsignedLong(offset);\n    count = asUnsignedLong(count);\n    // 1. Let length be node’s length.\n    var length = node.length;\n    // 2. If offset is greater than length, then throw an IndexSizeError.\n    if (offset > length) {\n        throwIndexSizeError(\"can not replace data past the node's length\");\n    }\n    // 3. If offset plus count is greater than length, then set count to length minus offset.\n    if (offset + count > length) {\n        count = length - offset;\n    }\n    // 4. Queue a mutation record of \"characterData\" for node with null, null, node's data, « »,\n    // « », null, and null.\n    queueMutationRecord('characterData', node, {\n        oldValue: node.data\n    });\n    // 5. Insert data into node’s data after offset code units.\n    // 6. Let delete offset be offset + data's length.\n    // 7. Starting from delete offset code units, remove count code units from node’s data.\n    var nodeData = node.data;\n    var newData = nodeData.substring(0, offset) + data + nodeData.substring(offset + count);\n    node._data = newData;\n    var context = getContext(node);\n    context._ranges.forEach(function (range) {\n        // 8. For each live range whose start node is node and start offset is greater than offset\n        // but less than or equal to offset plus count, set its start offset to offset.\n        if (range.startContainer === node &&\n            range.startOffset > offset &&\n            range.startOffset <= offset + count) {\n            range.startOffset = offset;\n        }\n        // 9. For each live range whose end node is node and end offset is greater than offset but\n        // less than or equal to offset plus count, set its end offset to offset.\n        if (range.endContainer === node &&\n            range.endOffset > offset &&\n            range.endOffset <= offset + count) {\n            range.endOffset = offset;\n        }\n        // 10. For each live range whose start node is node and start offset is greater than offset\n        // plus count, increase its start offset by data's length and decrease it by count.\n        if (range.startContainer === node && range.startOffset > offset + count) {\n            range.startOffset = range.startOffset + data.length - count;\n        }\n        // 11. For each live range whose end node is node and end offset is greater than offset plus\n        // count, increase its end offset by data's length and decrease it by count.\n        if (range.endContainer === node && range.endOffset > offset + count) {\n            range.endOffset = range.endOffset + data.length - count;\n        }\n    });\n    // 12. If node is a Text node and its parent is not null, run the child text content change\n    // steps for node’s parent.\n    // (child text content change steps not implemented)\n}\n/**\n * To substring data with node node, offset offset, and count count, run these steps:\n *\n * @param node   The node to get data from\n * @param offset The offset at which to start the substring\n * @param count  The number of code units to include in the substring\n *\n * @return The requested substring\n */\nexport function substringData(node, offset, count) {\n    // Match spec data types\n    offset = asUnsignedLong(offset);\n    count = asUnsignedLong(count);\n    // 1. Let length be node’s length.\n    var length = node.length;\n    // 2. If offset is greater than length, then throw an IndexSizeError.\n    if (offset > length) {\n        throwIndexSizeError(\"can not substring data past the node's length\");\n    }\n    // 3. If offset plus count is greater than length, return a string whose value is the code units\n    // from the offsetth code unit to the end of node’s data, and then return.\n    if (offset + count > length) {\n        return node.data.substring(offset);\n    }\n    // 4. Return a string whose value is the code units from the offsetth code unit to the\n    // offset+countth code unit in node’s data.\n    return node.data.substring(offset, offset + count);\n}\n//# sourceMappingURL=CharacterData.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { replaceData, substringData, default as CharacterData } from './CharacterData';\nimport { getContext } from './context/Context';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport { insertNode } from './util/mutationAlgorithms';\nimport { getNodeIndex } from './util/treeHelpers';\nimport { asUnsignedLong } from './util/typeHelpers';\n/**\n * 3.11. Interface Text\n */\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    // Text\n    /**\n     * Returns a new Text node whose data is data and node document is current global object’s\n     * associated Document.\n     *\n     * @param data     The data for the new text node\n     */\n    function Text(data) {\n        if (data === void 0) { data = ''; }\n        var _this = _super.call(this, data) || this;\n        var context = getContext(_this);\n        _this.ownerDocument = context.document;\n        return _this;\n    }\n    Object.defineProperty(Text.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 3 /* TEXT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"nodeName\", {\n        get: function () {\n            return '#text';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Splits data at the given offset and returns the remainder as Text node.\n     *\n     * @param offset The offset at which to split\n     *\n     * @return a text node containing the second half of the split node's data\n     */\n    Text.prototype.splitText = function (offset) {\n        expectArity(arguments, 1);\n        offset = asUnsignedLong(offset);\n        return splitText(this, offset);\n    };\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    Text.prototype._copy = function (document) {\n        // Set copy’s data, to that of node.\n        var context = getContext(document);\n        var copy = new context.Text(this.data);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return Text;\n}(CharacterData));\nexport default Text;\n/**\n * To split a Text node node with offset offset, run these steps:\n *\n * @param node   The text node to split\n * @param offset The offset to split at\n *\n * @return a text node containing the second half of the split node's data\n */\nfunction splitText(node, offset) {\n    // 1. Let length be node’s length.\n    var length = node.length;\n    // 2. If offset is greater than length, then throw an IndexSizeError.\n    if (offset > length) {\n        throwIndexSizeError(\"can not split past the node's length\");\n    }\n    // 3. Let count be length minus offset.\n    var count = length - offset;\n    // 4. Let new data be the result of substringing data with node node, offset offset, and count\n    // count.\n    var newData = substringData(node, offset, count);\n    // 5. Let new node be a new Text node, with the same node document as node. Set new node’s data\n    // to new data.\n    var context = getContext(node);\n    var newNode = new context.Text(newData);\n    newNode.ownerDocument = node.ownerDocument;\n    // 6. Let parent be node’s parent.\n    var parent = node.parentNode;\n    // 7. If parent is not null, then:\n    if (parent !== null) {\n        // 7.1. Insert new node into parent before node’s next sibling.\n        insertNode(newNode, parent, node.nextSibling);\n        var indexOfNodePlusOne_1 = getNodeIndex(node) + 1;\n        var context_1 = getContext(node);\n        context_1._ranges.forEach(function (range) {\n            // 7.2. For each live range whose start node is node and start offset is greater than\n            // offset, set its start node to new node and decrease its start offset by offset.\n            if (range.startContainer === node && range.startOffset > offset) {\n                range.startContainer = newNode;\n                range.startOffset -= offset;\n            }\n            // 7.3. For each live range whose end node is node and end offset is greater than\n            // offset, set its end node to new node and decrease its end offset by offset.\n            if (range.endContainer === node && range.endOffset > offset) {\n                range.endContainer = newNode;\n                range.endOffset -= offset;\n            }\n            // 7.4. For each live range whose start node is parent and start offset is equal to the\n            // index of node + 1, increase its start offset by one.\n            if (range.startContainer === parent && range.startOffset === indexOfNodePlusOne_1) {\n                range.startOffset += 1;\n            }\n            // 7.5. For each live range whose end node is parent and end offset is equal to the\n            // index of node + 1, increase its end offset by one.\n            if (range.endContainer === parent && range.endOffset === indexOfNodePlusOne_1) {\n                range.endOffset += 1;\n            }\n        });\n    }\n    // 8. Replace data with node node, offset offset, count count, and data the empty string.\n    replaceData(node, offset, count, '');\n    // 9. Return new node.\n    return newNode;\n}\n//# sourceMappingURL=Text.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Text from './Text';\nimport { getContext } from './context/Context';\nvar CDATASection = /** @class */ (function (_super) {\n    __extends(CDATASection, _super);\n    // CDATASection\n    /**\n     * (non-standard) use Document#createCDATASection to create a CDATA section.\n     *\n     * @param data The data for the node\n     */\n    function CDATASection(data) {\n        return _super.call(this, data) || this;\n    }\n    Object.defineProperty(CDATASection.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 4 /* CDATA_SECTION_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CDATASection.prototype, \"nodeName\", {\n        get: function () {\n            return '#cdata-section';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    CDATASection.prototype._copy = function (document) {\n        // Set copy’s data, to that of node.\n        var context = getContext(document);\n        var copy = new context.CDATASection(this.data);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return CDATASection;\n}(Text));\nexport default CDATASection;\n//# sourceMappingURL=CDATASection.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport CharacterData from './CharacterData';\nimport { getContext } from './context/Context';\nvar Comment = /** @class */ (function (_super) {\n    __extends(Comment, _super);\n    // Comment\n    /**\n     * Returns a new Comment node whose data is data and node document is current global object’s\n     * associated Document.\n     *\n     * @param data The data for the new comment\n     */\n    function Comment(data) {\n        if (data === void 0) { data = ''; }\n        var _this = _super.call(this, data) || this;\n        var context = getContext(_this);\n        _this.ownerDocument = context.document;\n        return _this;\n    }\n    Object.defineProperty(Comment.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 8 /* COMMENT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Comment.prototype, \"nodeName\", {\n        get: function () {\n            return '#comment';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    Comment.prototype._copy = function (document) {\n        // Set copy’s data, to that of node.\n        var context = getContext(document);\n        var copy = new context.Comment(this.data);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return Comment;\n}(CharacterData));\nexport default Comment;\n//# sourceMappingURL=Comment.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nvar DocumentType = /** @class */ (function (_super) {\n    __extends(DocumentType, _super);\n    /**\n     * (non-standard) Use DOMImplementation#createDocumentType instead.\n     *\n     * @param name     The name of the doctype\n     * @param publicId The public ID of the doctype\n     * @param systemId The system ID of the doctype\n     */\n    function DocumentType(name, publicId, systemId) {\n        if (publicId === void 0) { publicId = ''; }\n        if (systemId === void 0) { systemId = ''; }\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this.publicId = publicId;\n        _this.systemId = systemId;\n        return _this;\n    }\n    Object.defineProperty(DocumentType.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 10 /* DOCUMENT_TYPE_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentType.prototype, \"nodeName\", {\n        get: function () {\n            return this.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentType.prototype, \"nodeValue\", {\n        get: function () {\n            return null;\n        },\n        set: function (newValue) {\n            // Do nothing.\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentType.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to return value)\n        // 2. Switch on the context object:\n        // DocumentType - Return null\n        return null;\n    };\n    DocumentType.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to return value)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: DocumentType\n        // Return null.\n        return null;\n    };\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    DocumentType.prototype._copy = function (document) {\n        // Set copy’s name, public ID, and system ID, to those of node.\n        var context = getContext(document);\n        var copy = new context.DocumentType(this.name, this.publicId, this.systemId);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return DocumentType;\n}(Node));\nexport default DocumentType;\n//# sourceMappingURL=DocumentType.js.map","import { throwInvalidCharacterError, throwNamespaceError } from './errorHelpers';\n// 1.5. Namespaces\nexport var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nexport var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n/*\n// NAME_REGEX_XML_1_0_FOURTH_EDITION generated using regenerate:\nvar regenerate = require(\"regenerate\");\n\nconst productions = {\n    NameChar: \"Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender\",\n    Letter: \"BaseChar | Ideographic\",\n    BaseChar: \"[#x0041-#x005A] | [#x0061-#x007A] | [#x00C0-#x00D6] | [#x00D8-#x00F6] |\n    [#x00F8-#x00FF] | [#x0100-#x0131] | [#x0134-#x013E] | [#x0141-#x0148] | [#x014A-#x017E] |\n    [#x0180-#x01C3] | [#x01CD-#x01F0] | [#x01F4-#x01F5] | [#x01FA-#x0217] | [#x0250-#x02A8] |\n    [#x02BB-#x02C1] | #x0386 | [#x0388-#x038A] | #x038C | [#x038E-#x03A1] | [#x03A3-#x03CE] |\n    [#x03D0-#x03D6] | #x03DA | #x03DC | #x03DE | #x03E0 | [#x03E2-#x03F3] | [#x0401-#x040C] |\n    [#x040E-#x044F] | [#x0451-#x045C] | [#x045E-#x0481] | [#x0490-#x04C4] | [#x04C7-#x04C8] |\n    [#x04CB-#x04CC] | [#x04D0-#x04EB] | [#x04EE-#x04F5] | [#x04F8-#x04F9] | [#x0531-#x0556] | #x0559\n    | [#x0561-#x0586] | [#x05D0-#x05EA] | [#x05F0-#x05F2] | [#x0621-#x063A] | [#x0641-#x064A] |\n    [#x0671-#x06B7] | [#x06BA-#x06BE] | [#x06C0-#x06CE] | [#x06D0-#x06D3] | #x06D5 | [#x06E5-#x06E6]\n    | [#x0905-#x0939] | #x093D | [#x0958-#x0961] | [#x0985-#x098C] | [#x098F-#x0990] |\n    [#x0993-#x09A8] | [#x09AA-#x09B0] | #x09B2 | [#x09B6-#x09B9] | [#x09DC-#x09DD] | [#x09DF-#x09E1]\n    | [#x09F0-#x09F1] | [#x0A05-#x0A0A] | [#x0A0F-#x0A10] | [#x0A13-#x0A28] | [#x0A2A-#x0A30] |\n    [#x0A32-#x0A33] | [#x0A35-#x0A36] | [#x0A38-#x0A39] | [#x0A59-#x0A5C] | #x0A5E | [#x0A72-#x0A74]\n    | [#x0A85-#x0A8B] | #x0A8D | [#x0A8F-#x0A91] | [#x0A93-#x0AA8] | [#x0AAA-#x0AB0] |\n    [#x0AB2-#x0AB3] | [#x0AB5-#x0AB9] | #x0ABD | #x0AE0 | [#x0B05-#x0B0C] | [#x0B0F-#x0B10] |\n    [#x0B13-#x0B28] | [#x0B2A-#x0B30] | [#x0B32-#x0B33] | [#x0B36-#x0B39] | #x0B3D | [#x0B5C-#x0B5D]\n    | [#x0B5F-#x0B61] | [#x0B85-#x0B8A] | [#x0B8E-#x0B90] | [#x0B92-#x0B95] | [#x0B99-#x0B9A] |\n    #x0B9C | [#x0B9E-#x0B9F] | [#x0BA3-#x0BA4] | [#x0BA8-#x0BAA] | [#x0BAE-#x0BB5] | [#x0BB7-#x0BB9]\n    | [#x0C05-#x0C0C] | [#x0C0E-#x0C10] | [#x0C12-#x0C28] | [#x0C2A-#x0C33] | [#x0C35-#x0C39] |\n    [#x0C60-#x0C61] | [#x0C85-#x0C8C] | [#x0C8E-#x0C90] | [#x0C92-#x0CA8] | [#x0CAA-#x0CB3] |\n    [#x0CB5-#x0CB9] | #x0CDE | [#x0CE0-#x0CE1] | [#x0D05-#x0D0C] | [#x0D0E-#x0D10] | [#x0D12-#x0D28]\n    | [#x0D2A-#x0D39] | [#x0D60-#x0D61] | [#x0E01-#x0E2E] | #x0E30 | [#x0E32-#x0E33] |\n    [#x0E40-#x0E45] | [#x0E81-#x0E82] | #x0E84 | [#x0E87-#x0E88] | #x0E8A | #x0E8D | [#x0E94-#x0E97]\n    | [#x0E99-#x0E9F] | [#x0EA1-#x0EA3] | #x0EA5 | #x0EA7 | [#x0EAA-#x0EAB] | [#x0EAD-#x0EAE] |\n    #x0EB0 | [#x0EB2-#x0EB3] | #x0EBD | [#x0EC0-#x0EC4] | [#x0F40-#x0F47] | [#x0F49-#x0F69] |\n    [#x10A0-#x10C5] | [#x10D0-#x10F6] | #x1100 | [#x1102-#x1103] | [#x1105-#x1107] | #x1109 |\n    [#x110B-#x110C] | [#x110E-#x1112] | #x113C | #x113E | #x1140 | #x114C | #x114E | #x1150 |\n    [#x1154-#x1155] | #x1159 | [#x115F-#x1161] | #x1163 | #x1165 | #x1167 | #x1169 | [#x116D-#x116E]\n    | [#x1172-#x1173] | #x1175 | #x119E | #x11A8 | #x11AB | [#x11AE-#x11AF] | [#x11B7-#x11B8] |\n    #x11BA | [#x11BC-#x11C2] | #x11EB | #x11F0 | #x11F9 | [#x1E00-#x1E9B] | [#x1EA0-#x1EF9] |\n    [#x1F00-#x1F15] | [#x1F18-#x1F1D] | [#x1F20-#x1F45] | [#x1F48-#x1F4D] | [#x1F50-#x1F57] | #x1F59\n    | #x1F5B | #x1F5D | [#x1F5F-#x1F7D] | [#x1F80-#x1FB4] | [#x1FB6-#x1FBC] | #x1FBE |\n    [#x1FC2-#x1FC4] | [#x1FC6-#x1FCC] | [#x1FD0-#x1FD3] | [#x1FD6-#x1FDB] | [#x1FE0-#x1FEC] |\n    [#x1FF2-#x1FF4] | [#x1FF6-#x1FFC] | #x2126 | [#x212A-#x212B] | #x212E | [#x2180-#x2182] |\n    [#x3041-#x3094] | [#x30A1-#x30FA] | [#x3105-#x312C] | [#xAC00-#xD7A3]\", Ideographic:\n    \"[#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]\", CombiningChar: \"[#x0300-#x0345] | [#x0360-#x0361]\n    | [#x0483-#x0486] | [#x0591-#x05A1] | [#x05A3-#x05B9] | [#x05BB-#x05BD] | #x05BF |\n    [#x05C1-#x05C2] | #x05C4 | [#x064B-#x0652] | #x0670 | [#x06D6-#x06DC] | [#x06DD-#x06DF] |\n    [#x06E0-#x06E4] | [#x06E7-#x06E8] | [#x06EA-#x06ED] | [#x0901-#x0903] | #x093C | [#x093E-#x094C]\n    | #x094D | [#x0951-#x0954] | [#x0962-#x0963] | [#x0981-#x0983] | #x09BC | #x09BE | #x09BF |\n    [#x09C0-#x09C4] | [#x09C7-#x09C8] | [#x09CB-#x09CD] | #x09D7 | [#x09E2-#x09E3] | #x0A02 | #x0A3C\n    | #x0A3E | #x0A3F | [#x0A40-#x0A42] | [#x0A47-#x0A48] | [#x0A4B-#x0A4D] | [#x0A70-#x0A71] |\n    [#x0A81-#x0A83] | #x0ABC | [#x0ABE-#x0AC5] | [#x0AC7-#x0AC9] | [#x0ACB-#x0ACD] | [#x0B01-#x0B03]\n    | #x0B3C | [#x0B3E-#x0B43] | [#x0B47-#x0B48] | [#x0B4B-#x0B4D] | [#x0B56-#x0B57] |\n    [#x0B82-#x0B83] | [#x0BBE-#x0BC2] | [#x0BC6-#x0BC8] | [#x0BCA-#x0BCD] | #x0BD7 | [#x0C01-#x0C03]\n    | [#x0C3E-#x0C44] | [#x0C46-#x0C48] | [#x0C4A-#x0C4D] | [#x0C55-#x0C56] | [#x0C82-#x0C83] |\n    [#x0CBE-#x0CC4] | [#x0CC6-#x0CC8] | [#x0CCA-#x0CCD] | [#x0CD5-#x0CD6] | [#x0D02-#x0D03] |\n    [#x0D3E-#x0D43] | [#x0D46-#x0D48] | [#x0D4A-#x0D4D] | #x0D57 | #x0E31 | [#x0E34-#x0E3A] |\n    [#x0E47-#x0E4E] | #x0EB1 | [#x0EB4-#x0EB9] | [#x0EBB-#x0EBC] | [#x0EC8-#x0ECD] | [#x0F18-#x0F19]\n    | #x0F35 | #x0F37 | #x0F39 | #x0F3E | #x0F3F | [#x0F71-#x0F84] | [#x0F86-#x0F8B] |\n    [#x0F90-#x0F95] | #x0F97 | [#x0F99-#x0FAD] | [#x0FB1-#x0FB7] | #x0FB9 | [#x20D0-#x20DC] | #x20E1\n    | [#x302A-#x302F] | #x3099 | #x309A\", Digit: \"[#x0030-#x0039] | [#x0660-#x0669] |\n    [#x06F0-#x06F9] | [#x0966-#x096F] | [#x09E6-#x09EF] | [#x0A66-#x0A6F] | [#x0AE6-#x0AEF] |\n    [#x0B66-#x0B6F] | [#x0BE7-#x0BEF] | [#x0C66-#x0C6F] | [#x0CE6-#x0CEF] | [#x0D66-#x0D6F] |\n    [#x0E50-#x0E59] | [#x0ED0-#x0ED9] | [#x0F20-#x0F29]\", Extender: \"#x00B7 | #x02D0 | #x02D1 |\n    #x0387 | #x0640 | #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] | [#x309D-#x309E] |\n    [#x30FC-#x30FE]\"\n};\n\nfunction createSetRegex (prod, set = regenerate()) {\n    return prod.split(' | ').reduce((set, part) => {\n        let m = part.match(/^\\[#x([0-9A-F]+)-#x([0-9A-F]+)\\]$/);\n        if (m) {\n            return set.addRange(parseInt(m[1], 16), parseInt(m[2], 16));\n        }\n        m = part.match(/^#x([0-9A-F]+)$/);\n        if (m) {\n            return set.add(parseInt(m[1], 16));\n        }\n        m = part.match(/^'(.)'$/);\n        if (m) {\n            return set.add(m[1]);\n        }\n        return createSetRegex(productions[part], set);\n    }, set);\n}\n\n// Name ::= (Letter | '_' | ':') (NameChar)*\n`^(?:${createRegex(\"Letter | '_' | ':'\")})(?:${createRegex('NameChar')})*$`;\n*/\nvar NAME_REGEX_XML_1_0_FOURTH_EDITION = /^(?:[:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3007\\u3021-\\u3029\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3])(?:[\\-\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u02D0\\u02D1\\u0300-\\u0345\\u0360\\u0361\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0483-\\u0486\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u0591-\\u05A1\\u05A3-\\u05B9\\u05BB-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0640-\\u0652\\u0660-\\u0669\\u0670-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5-\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0901-\\u0903\\u0905-\\u0939\\u093C-\\u094D\\u0951-\\u0954\\u0958-\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A02\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A74\\u0A81-\\u0A83\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE0\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3C-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE7-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D60\\u0D61\\u0D66-\\u0D6F\\u0E01-\\u0E2E\\u0E30-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F69\\u0F71-\\u0F84\\u0F86-\\u0F8B\\u0F90-\\u0F95\\u0F97\\u0F99-\\u0FAD\\u0FB1-\\u0FB7\\u0FB9\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u20D0-\\u20DC\\u20E1\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3005\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3041-\\u3094\\u3099\\u309A\\u309D\\u309E\\u30A1-\\u30FA\\u30FC-\\u30FE\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3])*$/;\n/*\n// NAME_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\nconst NameStartChar = regenerate()\n    .add(':')\n    .addRange('A', 'Z')\n    .add('_')\n    .addRange('a', 'z')\n    .addRange(0xC0, 0xD6)\n    .addRange(0xD8, 0xF6)\n    .addRange(0xF8, 0x2FF)\n    .addRange(0x370, 0x37D)\n    .addRange(0x37F, 0x1FFF)\n    .addRange(0x200C, 0x200D)\n    .addRange(0x2070, 0x218F)\n    .addRange(0x2C00, 0x2FEF)\n    .addRange(0x3001, 0xD7FF)\n    .addRange(0xF900, 0xFDCF)\n    .addRange(0xFDF0, 0xFFFD)\n    .addRange(0x10000, 0xEFFFF);\n\nconst NameChar = NameStartChar.clone()\n    .add('-')\n    .add('.')\n    .addRange('0', '9')\n    .add(0xB7)\n    .addRange(0x0300, 0x036F)\n    .addRange(0x203F, 0x2040);\n\nreturn `^(?:${NameStartChar.toString()})(?:${NameChar.toString()})*$`;\n*/\nvar NAME_REGEX_XML_1_0_FIFTH_EDITION = /^(?:[:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(?:[\\-\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n/**\n * Returns true if name matches the Name production.\n *\n * @param name The name to check\n *\n * @return true if name matches Name, otherwise false\n */\nexport function matchesNameProduction(name) {\n    return NAME_REGEX_XML_1_0_FOURTH_EDITION.test(name);\n}\n/**\n * As we're already testing against Name, testing QName validity can be reduced to checking if the\n * name contains at most a single colon which is not at the first or last position.\n *\n * @param name The name to check\n *\n * @return True if the name is a valid QName, provided it is also a valid Name, otherwise false\n */\nfunction isValidQName(name) {\n    var parts = name.split(':');\n    if (parts.length > 2) {\n        return false;\n    }\n    if (parts.length === 1) {\n        return true;\n    }\n    // First part should not be empty, and the second part should be a valid name\n    return parts[0].length > 0 && matchesNameProduction(parts[1]);\n}\n/**\n * To validate a qualifiedName,\n *\n * @param qualifiedName Qualified name to validate\n */\nexport function validateQualifiedName(qualifiedName) {\n    // throw an InvalidCharacterError if qualifiedName does not match the Name or QName production.\n    // (QName is basically (Name without ':') ':' (Name without ':'), so just check the position of\n    // the ':')\n    if (!isValidQName(qualifiedName) || !matchesNameProduction(qualifiedName)) {\n        throwInvalidCharacterError('The qualified name is not a valid Name or QName');\n    }\n}\n/**\n * To validate and extract a namespace and qualifiedName, run these steps:\n *\n * @param namespace     Namespace for the qualified name\n * @param qualifiedName Qualified name to validate and extract the components of\n *\n * @return Namespace, prefix and localName\n */\nexport function validateAndExtract(namespace, qualifiedName) {\n    // 1. If namespace is the empty string, set it to null.\n    if (namespace === '') {\n        namespace = null;\n    }\n    // 2. Validate qualifiedName.\n    validateQualifiedName(qualifiedName);\n    // 3. Let prefix be null.\n    var prefix = null;\n    // 4.  Let localName be qualifiedName.\n    var localName = qualifiedName;\n    // 5. If qualifiedName contains a \":\" (U+003E), then split the string on it and set prefix to\n    // the part before and localName to the part after.\n    var index = qualifiedName.indexOf(':');\n    if (index >= 0) {\n        prefix = qualifiedName.substring(0, index);\n        localName = qualifiedName.substring(index + 1);\n    }\n    // 6. If prefix is non-null and namespace is null, then throw a NamespaceError.\n    if (prefix !== null && namespace === null) {\n        throwNamespaceError('Qualified name with prefix can not have a null namespace');\n    }\n    // 7. If prefix is \"xml\" and namespace is not the XML namespace, then throw a NamespaceError.\n    if (prefix === 'xml' && namespace !== XML_NAMESPACE) {\n        throwNamespaceError('xml prefix can only be used for the XML namespace');\n    }\n    // 8. If either qualifiedName or prefix is \"xmlns\" and namespace is not the XMLNS namespace,\n    // then throw a NamespaceError.\n    if ((qualifiedName === 'xmlns' || prefix === 'xmlns') && namespace !== XMLNS_NAMESPACE) {\n        throwNamespaceError('xmlns prefix or qualifiedName must use the XMLNS namespace');\n    }\n    // 9. If namespace is the XMLNS namespace and neither qualifiedName nor prefix is \"xmlns\", then\n    // throw a NamespaceError.\n    if (namespace === XMLNS_NAMESPACE && qualifiedName !== 'xmlns' && prefix !== 'xmlns') {\n        throwNamespaceError('xmlns prefix or qualifiedName must be used for the XMLNS namespace');\n    }\n    // 10. Return namespace, prefix, and localName.\n    return { namespace: namespace, prefix: prefix, localName: localName };\n}\n/**\n * To locate a namespace prefix for an element using namespace, run these steps:\n *\n * @param element    The element at which to start the lookup\n * @param namespace  Namespace for which to look up the prefix\n *\n * @return The prefix, or null if there isn't one\n */\nexport function locateNamespacePrefix(element, namespace) {\n    // 1. If element’s namespace is namespace and its namespace prefix is not null, then return its\n    // namespace prefix.\n    if (element.namespaceURI === namespace && element.prefix !== null) {\n        return element.prefix;\n    }\n    // 2. If element has an attribute whose namespace prefix is \"xmlns\" and value is namespace, then\n    // return element’s first such attribute’s local name.\n    var attr = Array.from(element.attributes).find(function (attr) { return attr.prefix === 'xmlns' && attr.value === namespace; });\n    if (attr) {\n        return attr.localName;\n    }\n    // 3. If element’s parent element is not null, then return the result of running locate a\n    // namespace prefix on that element using namespace.\n    if (element.parentElement !== null) {\n        return locateNamespacePrefix(element.parentElement, namespace);\n    }\n    // 4. Return null.\n    return null;\n}\n//# sourceMappingURL=namespaceHelpers.js.map","import { XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\n// 3.2.1.1.2 The Namespace Prefix Map\n/**\n * A namespace prefix map is a map that associates namespaceURI and namespace prefix lists, where\n * namespaceURI values are the map's unique keys (which can include the null value representing no\n * namespace), and ordered lists of associated prefix values are the map's key values. The namespace\n * prefix map will be populated by previously seen namespaceURIs and all their previously\n * encountered prefix associations for a given node and its ancestors.\n *\n * NOTE: the last seen prefix for a given namespaceURI is at the end of its respective list. The\n * list is searched to find potentially matching prefixes, and if no matches are found for the given\n * namespaceURI, then the last prefix in the list is used. See copy a namespace prefix map and\n * retrieve a preferred prefix string for additional details.\n */\nvar NamespacePrefixMap = /** @class */ (function () {\n    function NamespacePrefixMap() {\n        this._map = new Map();\n    }\n    /**\n     * To copy a namespace prefix map map means to copy the map's keys into a new empty namespace\n     * prefix map, and to copy each of the values in the namespace prefix list associated with each\n     * keys' value into a new list which should be associated with the respective key in the new\n     * map.\n     *\n     * @return A copy of the namespace prefix map\n     */\n    NamespacePrefixMap.prototype.copy = function () {\n        var copy = new NamespacePrefixMap();\n        // Array.from needed to allow compilation to ES5 targets\n        for (var _i = 0, _a = Array.from(this._map.entries()); _i < _a.length; _i++) {\n            var _b = _a[_i], namespace = _b[0], prefixes = _b[1];\n            copy._map.set(namespace, prefixes.concat());\n        }\n        return copy;\n    };\n    /**\n     * To retrieve a preferred prefix string preferred prefix from the namespace prefix map map\n     * given a namespace ns, the user agent should:\n     *\n     * @param preferredPrefix The prefix to look up\n     * @param ns              The namespace for the prefix\n     *\n     * @return The matching candidate prefix, if found, or null otherwise\n     */\n    NamespacePrefixMap.prototype.retrievePreferredPrefixString = function (preferredPrefix, ns) {\n        // 1. Let candidates list be the result of retrieving a list from map where there exists a\n        // key in map that matches the value of ns or if there is no such key, then stop running\n        // these steps, and return the null value.\n        var candidatesList = this._map.get(ns);\n        if (candidatesList === undefined) {\n            return null;\n        }\n        // 2. Otherwise, for each prefix value prefix in candidates list, iterating from beginning\n        // to end:\n        // NOTE: There will always be at least one prefix value in the list.\n        for (var _i = 0, candidatesList_1 = candidatesList; _i < candidatesList_1.length; _i++) {\n            var prefix = candidatesList_1[_i];\n            // 2.1. If prefix matches preferred prefix, then stop running these steps and return\n            // prefix.\n            if (prefix === preferredPrefix) {\n                return prefix;\n            }\n            // 2.2. If prefix is the last item in the candidates list, then stop running these steps\n            // and return prefix.\n        }\n        return candidatesList[candidatesList.length - 1];\n    };\n    /**\n     * To check if a prefix string prefix is found in a namespace prefix map map given a namespace\n     * ns, the user agent should:\n     *\n     * @param prefix The prefix to check\n     * @param ns     The namespace to check\n     *\n     * @return Whether the combination of prefix and ns is found in the map\n     */\n    NamespacePrefixMap.prototype.checkIfFound = function (prefix, ns) {\n        // 1. Let candidates list be the result of retrieving a list from map where there exists a\n        // key in map that matches the value of ns or if there is no such key, then stop running\n        // these steps, and return false.\n        var candidatesList = this._map.get(ns);\n        if (candidatesList === undefined) {\n            return false;\n        }\n        // If the value of prefix occurs at least once in candidates list, return true, otherwise\n        // return false.\n        return candidatesList.indexOf(prefix) >= 0;\n    };\n    /**\n     * To add a prefix string prefix to the namespace prefix map map given a namespace ns, the user\n     * agent should:\n     *\n     * @param prefix The prefix to add\n     * @param ns     The namespace to add for prefix\n     */\n    NamespacePrefixMap.prototype.add = function (prefix, ns) {\n        // 1. Let candidates list be the result of retrieving a list from map where there exists a\n        // key in map that matches the value of ns or if there is no such key, then let candidates\n        // list be null.\n        // Note: undefined used instead of null for convenience\n        var candidatesList = this._map.get(ns);\n        // 2. If candidates list is null, then create a new list with prefix as the only item in the\n        // list, and associate that list with a new key ns in map.\n        if (candidatesList === undefined) {\n            this._map.set(ns, [prefix]);\n        }\n        else {\n            // 3. Otherwise, append prefix to the end of candidates list.\n            candidatesList.push(prefix);\n        }\n        // NOTE: The steps in retrieve a preferred prefix string use the list to track the most\n        // recently used (MRU) prefix associated with a given namespace, which will be the prefix at\n        // the end of the list. This list may contain duplicates of the same prefix value seen\n        // earlier (and that's OK).\n    };\n    return NamespacePrefixMap;\n}());\nexport { NamespacePrefixMap };\n// 3.2.1.1.1 Recording the namespace\n/**\n * This following algorithm will update the namespace prefix map with any found namespace prefix\n * definitions, add the found prefix definitions to the local prefixes map, and return a local\n * default namespace value defined by a default namespace attribute if one exists. Otherwise it\n * returns null.\n *\n * @param element          Element for which to record namespace information\n * @param map              The namespace prefix map to update\n * @param localPrefixesMap The local prefixes map to update\n *\n * @return The local default namespace value for element, or null if element does not define one\n */\nexport function recordNamespaceInformation(element, map, localPrefixesMap) {\n    // 1. Let default namespace attr value be null.\n    var defaultNamespaceAttrValue = null;\n    // 2. Main: For each attribute attr in element's attributes, in the order they are specified in\n    // the element's attribute list:\n    // NOTE: The following conditional steps find namespace prefixes. Only attributes in the XMLNS\n    // namespace are considered (e.g., attributes made to look like namespace declarations via\n    // setAttribute(\"xmlns:pretend-prefix\", \"pretend-namespace\") are not included).\n    for (var _i = 0, _a = element.attributes; _i < _a.length; _i++) {\n        var attr = _a[_i];\n        // 2.1. Let attribute namespace be the value of attr's namespaceURI value.\n        var attributeNamespace = attr.namespaceURI;\n        // 2.2. Let attribute prefix be the value of attr's prefix.\n        var attributePrefix = attr.prefix;\n        // 2.3. If the attribute namespace is the XMLNS namespace, then:\n        if (attributeNamespace === XMLNS_NAMESPACE) {\n            // 2.3.1. If attribute prefix is null, then attr is a default namespace declaration. Set\n            // the default namespace attr value to attr's value and stop running these steps,\n            // returning to Main to visit the next attribute.\n            if (attributePrefix === null) {\n                defaultNamespaceAttrValue = attr.value;\n                continue;\n            }\n            // 2.3.2. Otherwise, the attribute prefix is not null and attr is a namespace prefix\n            // definition. Run the following steps:\n            // 2.3.2.1. Let prefix definition be the value of attr's localName.\n            var prefixDefinition = attr.localName;\n            // 2.3.2.2. Let namespace definition be the value of attr's value.\n            var namespaceDefinition = attr.value;\n            // 2.3.2.3. If namespace definition is the XML namespace, then stop running these steps,\n            // and return to Main to visit the next attribute.\n            // NOTE: XML namespace definitions in prefixes are completely ignored (in order to avoid\n            // unnecessary work when there might be prefix conflicts). XML namespaced elements are\n            // always handled uniformly by prefixing (and overriding if necessary) the element's\n            // localname with the reserved \"xml\" prefix.\n            if (namespaceDefinition === XML_NAMESPACE) {\n                continue;\n            }\n            // 2.3.2.4. If namespace definition is the empty string (the declarative form of having\n            // no namespace), then let namespace definition be null instead.\n            if (namespaceDefinition === '') {\n                namespaceDefinition = null;\n            }\n            // 2.3.2.5. If prefix definition is found in map given the namespace namespace\n            // definition, then stop running these steps, and return to Main to visit the next\n            // attribute.\n            // NOTE: This step avoids adding duplicate prefix definitions for the same namespace in\n            // the map. This has the side-effect of avoiding later serialization of duplicate\n            // namespace prefix declarations in any descendant nodes.\n            if (map.checkIfFound(prefixDefinition, namespaceDefinition)) {\n                continue;\n            }\n            // 2.3.2.6. Add the prefix prefix definition to map given namespace namespace\n            // definition.\n            map.add(prefixDefinition, namespaceDefinition);\n            // 2.3.2.7. Add the value of prefix definition as a new key to the local prefixes map,\n            // with the namespace definition as the key's value replacing the value of null with the\n            // empty string if applicable.\n            localPrefixesMap[prefixDefinition] =\n                namespaceDefinition === null ? '' : namespaceDefinition;\n        }\n    }\n    // 3. Return the value of default namespace attr value.\n    // NOTE: The empty string is a legitimate return value and is not converted to null.\n    return defaultNamespaceAttrValue;\n}\n//# sourceMappingURL=NamespacePrefixMap.js.map","import { throwInvalidStateError } from '../util/errorHelpers';\nimport { matchesNameProduction, HTML_NAMESPACE, XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\nimport { recordNamespaceInformation, NamespacePrefixMap } from './NamespacePrefixMap';\n/*\n// CHAR_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\nconst Char = regenerate()\n    .add(0x9)\n    .add(0xA)\n    .add(0xD)\n    .addRange(0x20, 0xD7FF)\n    .addRange(0xE000, 0xFFFD)\n    .addRange(0x10000, 0xEFFFF);\n\nreturn `^(${Char.toString()})*$`;\n*/\nvar CHAR_REGEX_XML_1_0_FIFTH_EDITION = /^(?:[\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n/*\n// PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\n// #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]\nconst PubidChar = regenerate()\n    .add(0x20)\n    .add(0xD)\n    .add(0xA)\n    .addRange('a', 'z')\n    .addRange('A', 'Z')\n    .addRange('0', '9')\n    .add(...\"-'()+,./:=?;!*#@$_%\");\n\n`^(${PubidChar.toString()})*$`;\n*/\nvar PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION = /^(?:[\\n\\r !#-%'-;=\\?-Z_a-z])*$/;\nvar HTML_VOID_ELEMENTS = [\n    'area',\n    'base',\n    'basefont',\n    'bgsound',\n    'br',\n    'col',\n    'embed',\n    'frame',\n    'hr',\n    'img',\n    'input',\n    'keygen',\n    'link',\n    'menuitem',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wbr'\n];\n// 3.2. Serializing\n/**\n * The following steps form the fragment serializing algorithm:\n *\n * @param node                The node to serialize\n * @param requireWellFormed   Determines whether the result needs to be well-formed\n * @param withFictionalParent Whether to treat node as a fictional parent with node as its only\n *                            child\n *\n * @return A string representing the serialization of node\n */\nexport function serializeFragment(node, requireWellFormed, withFictionalParent) {\n    // 1. Let context document be the value of node's node document.\n    // 2. If context document is an HTML document, return an HTML serialization of node.\n    // (HTML documents not implemented)\n    if (withFictionalParent === void 0) { withFictionalParent = false; }\n    // 3. Otherwise, context document is an XML document; return an XML serialization of node\n    // passing the flag require well-formed.\n    // Note: if implemented as stated in the spec, this would make innerHTML return the outerHTML\n    // and make outerHTML trigger undefined behavior (the spec doesn't state the type of the\n    // fictional node that acts as a parent). Instead, serialize the children only\n    var childNodes = withFictionalParent ? [node] : node.childNodes;\n    var result = [];\n    for (var _i = 0, childNodes_1 = childNodes; _i < childNodes_1.length; _i++) {\n        var child = childNodes_1[_i];\n        produceXmlSerialization(child, requireWellFormed, result);\n    }\n    return result.join('');\n    // NOTE: The XML serialization defined in this document conforms to the requirements of the XML\n    // fragment serialization algorithm defined in [HTML5].\n}\n/**\n * To produce an XML serialization of a Node node given a flag require well-formed, run the\n * following steps:\n *\n * @param node                The node to serialize\n * @param requireWellFormed   Determines whether the result needs to be well-formed\n * @param result              Array of strings in which to construct the result\n */\nexport function produceXmlSerialization(node, requireWellFormed, result) {\n    // 1. Let namespace be a context namespace with value null. The context namespace tracks the XML\n    // serialization algorithm's current default namespace. The context namespace is changed when\n    // either an Element Node has a default namespace declaration, or the algorithm generates a\n    // default namespace declaration for the Element Node to match its own namespace. The algorithm\n    // assumes no namespace (null) to start.\n    var namespace = null;\n    // 2. Let prefix map be a new namespace prefix map.\n    var prefixMap = new NamespacePrefixMap();\n    // 3. Add the XML namespace with prefix value \"xml\" to prefix map.\n    prefixMap.add('xml', XML_NAMESPACE);\n    // 4. Let prefix index be a generated namespace prefix index with value 1. The generated\n    // namespace prefix index is used to generate a new unique prefix value when no suitable\n    // existing namespace prefix is available to serialize a node's namespaceURI (or the\n    // namespaceURI of one of node's attributes). See the generate a prefix algorithm.\n    var prefixIndex = { value: 1 };\n    // 5. Return the result of running the XML serialization algorithm on node passing the context\n    // namespace namespace, namespace prefix map prefix map, generated namespace prefix index\n    // reference to prefix index, and the flag require well-formed. If an exception occurs during\n    // the execution of the algorithm, then catch that exception and throw an \"InvalidStateError\"\n    // DOMException.\n    try {\n        runXmlSerializationAlgorithm(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n    }\n    catch (error) {\n        return throwInvalidStateError(error.message);\n    }\n}\n/**\n * The XML serialization algorithm produces an XML serialization of an arbitrary DOM node node based\n * on the node's interface type. Each referenced algorithm is to be passed the arguments as they\n * were recieved by the caller and return their result to the caller. Re-throw any exceptions.\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n *\n * @return The serialization of node\n */\nfunction runXmlSerializationAlgorithm(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    // If node's interface is:\n    switch (node.nodeType) {\n        // Element: Run the algorithm for XML serializing an Element node node.\n        case 1 /* ELEMENT_NODE */:\n            serializeElementNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // Document: Run the algorithm for XML serializing a Document node node.\n        case 9 /* DOCUMENT_NODE */:\n            serializeDocumentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // Comment: Run the algorithm for XML serializing a Comment node node.\n        case 8 /* COMMENT_NODE */:\n            serializeCommentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // CDATASection: Run the algorithm for XML serializing a CDATASection node node.\n        // Note: this is currently commented out in the DOM parsing spec, as it is based on the DOM4\n        // spec which removed the CDATASection interface. It seems the interface has been restored\n        // in the DOM living standard, so we'll implement its serialization as specced previously.\n        case 4 /* CDATA_SECTION_NODE */:\n            serializeCDATASectionNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // Text: Run the algorithm for XML serializing a Text node node.\n        case 3 /* TEXT_NODE */:\n            serializeTextNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // DocumentFragment: Run the algorithm for XML serializing a DocumentFragment node node.\n        case 11 /* DOCUMENT_FRAGMENT_NODE */:\n            serializeDocumentFragmentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // DocumentType: Run the algorithm for XML serializing a DocumentType node node.\n        case 10 /* DOCUMENT_TYPE_NODE */:\n            serializeDocumentTypeNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // ProcessingInstruction: Run the algorithm for XML serializing a ProcessingInstruction node\n        // node.\n        case 7 /* PROCESSING_INSTRUCTION_NODE */:\n            serializeProcessingInstructionNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // An Attr object: Return an empty string.\n        case 2 /* ATTRIBUTE_NODE */:\n            return;\n        // Anything else: Throw a TypeError. Only Nodes and Attr objects can be serialized by this\n        // algorithm.\n        // (not reachable from public API)\n        /* istanbul ignore next */\n        default:\n            throw new TypeError('Only Nodes and Attr objects can be serialized by this algorithm.');\n    }\n}\n/**\n * 3.2.1.1 XML serializing an Element node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeElementNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var element = node;\n    // If the require well-formed flag is set (its value is true), and this node's localName\n    // attribute contains the character \":\" (U+003A COLON) or does not match the XML Name\n    // production, then throw an exception; the serialization of this node would not be a\n    // well-formed element.\n    if (requireWellFormed &&\n        (element.localName.indexOf(':') >= 0 || !matchesNameProduction(element.localName))) {\n        throw new Error('The serialization of this node would not be a well-formed element');\n    }\n    // 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n    result.push('<');\n    // 3. Let qualified name be an empty string.\n    var qualifiedName = '';\n    // 4. Let skip end tag be a boolean flag with value false.\n    var skipEndTag = false;\n    // 5. Let ignore namespace definition attribute be a boolean flag with value false.\n    var ignoreNamespaceDefinitionAttribute = false;\n    // 6. Given prefix map, copy a namespace prefix map and let map be the result.\n    var map = prefixMap.copy();\n    // 7. Let local prefixes map be an empty map. The map has unique Node prefix strings as its\n    // keys, with corresponding namespaceURI Node values as the map's key values (in this map, the\n    // null namespace is represented by the empty string).\n    // NOTE: This map is local to each element. It is used to ensure there are no conflicting\n    // prefixes should a new namespace prefix attribute need to be generated. It is also used to\n    // enable skipping of duplicate prefix definitions when writing an element's attributes: the map\n    // allows the algorithm to distinguish between a prefix in the namespace prefix map that might\n    // be locally-defined (to the current Element) and one that is not.\n    var localPrefixesMap = {};\n    // 8. Let local default namespace be the result of recording the namespace information for node\n    // given map and local prefixes map.\n    // NOTE: The above step will update map with any found namespace prefix definitions, add the\n    // found prefix definitions to the local prefixes map and return a local default namespace value\n    // defined by a default namespace attribute if one exists. Otherwise it returns null.\n    var localDefaultNamespace = recordNamespaceInformation(element, map, localPrefixesMap);\n    // 9. Let inherited ns be a copy of namespace.\n    var inheritedNs = namespace;\n    // 10. Let ns be the value of node's namespaceURI attribute.\n    var ns = element.namespaceURI;\n    // 11. If inherited ns is equal to ns, then:\n    if (inheritedNs === ns) {\n        // 11.1. If local default namespace is not null, then set ignore namespace definition\n        // attribute to true.\n        if (localDefaultNamespace !== null) {\n            ignoreNamespaceDefinitionAttribute = true;\n        }\n        // 11.2. If ns is the XML namespace, then append to qualified name the concatenation of the\n        // string \"xml:\" and the value of node's localName.\n        if (ns === XML_NAMESPACE) {\n            qualifiedName += 'xml:' + element.localName;\n        }\n        else {\n            // 11.3. Otherwise, append to qualified name the value of node's localName. The node's\n            // prefix if it exists, is dropped.\n            qualifiedName += element.localName;\n        }\n        // 11.4. Append the value of qualified name to markup.\n        result.push(qualifiedName);\n    }\n    else {\n        // 12. Otherwise, inherited ns is not equal to ns (the node's own namespace is different\n        // from the context namespace of its parent). Run these sub-steps:\n        // 12.1. Let prefix be the value of node's prefix attribute.\n        var prefix = element.prefix;\n        // 12.2. Let candidate prefix be the result of retrieving a preferred prefix string prefix\n        // from map given namespace ns.\n        // NOTE: The above may return null if no namespace key ns exists in map.\n        var candidatePrefix = map.retrievePreferredPrefixString(prefix, ns);\n        // 12.3. If the value of prefix matches \"xmlns\", then run the following steps:\n        if (prefix === 'xmlns') {\n            // 12.3.1. If the require well-formed flag is set, then throw an error. An Element with\n            // prefix \"xmlns\" will not legally round-trip in a conforming XML parser.\n            if (requireWellFormed) {\n                throw new Error('An Element with prefix \"xmlns\" will not legally round-trip in a conforming ' +\n                    'XML parser');\n            }\n            // 12.3.2. Let candidate prefix be the value of prefix.\n            candidatePrefix = prefix;\n        }\n        // 12.4. Found a suitable namespace prefix: if candidate prefix is not null (a namespace\n        // prefix is defined which maps to ns), then:\n        if (candidatePrefix !== null) {\n            // NOTE: The following may serialize a different prefix than the Element's existing\n            // prefix if it already had one. However, the retrieving a preferred prefix string\n            // algorithm already tried to match the existing prefix if possible.\n            // 12.4.1. Append to qualified name the concatenation of candidate prefix, \":\" (U+003A\n            // COLON), and node's localName. There exists on this node or the node's ancestry a\n            // namespace prefix definition that defines the node's namespace.\n            qualifiedName += candidatePrefix + ':' + element.localName;\n            // 12.4.2. If the local default namespace is not null (there exists a locally-defined\n            // default namespace declaration attribute) and its value is not the XML namespace, then\n            // let inherited ns get the value of local default namespace unless the local default\n            // namespace is the empty string in which case let it get null (the context namespace is\n            // changed to the declared default, rather than this node's own namespace).\n            // NOTE: Any default namespace definitions or namespace prefixes that define the XML\n            // namespace are omitted when serializing this node's attributes.\n            if (localDefaultNamespace !== null && localDefaultNamespace !== XML_NAMESPACE) {\n                inheritedNs = localDefaultNamespace === '' ? null : localDefaultNamespace;\n            }\n            // 12.4.3. Append the value of qualified name to markup.\n            result.push(qualifiedName);\n        }\n        else if (prefix !== null) {\n            // 12.5. Otherwise, if prefix is not null, then:\n            // NOTE: By this step, there is no namespace or prefix mapping declaration in this node\n            // (or any parent node visited by this algorithm) that defines prefix otherwise the step\n            // labelled Found a suitable namespace prefix would have been followed. The sub-steps\n            // that follow will create a new namespace prefix declaration for prefix and ensure that\n            // prefix does not conflict with an existing namespace prefix declaration of the same\n            // localName in node's attribute list.\n            // 12.5.1. If the local prefixes map contains a key matching prefix, then let prefix be\n            // the result of generating a prefix providing as input map, ns, and prefix index.\n            if (prefix in localPrefixesMap) {\n                prefix = generatePrefix(map, ns, prefixIndex);\n            }\n            // 12.5.2. Add prefix to map given namespace ns.\n            map.add(prefix, ns);\n            // 12.5.3. Append to qualified name the concatenation of prefix, \":\" (U+003A COLON), and\n            // node's localName.\n            qualifiedName += prefix + ':' + element.localName;\n            // 12.5.4. Append the value of qualified name to markup.\n            result.push(qualifiedName);\n            // 12.5.5. Append the following to markup, in the order listed:\n            // NOTE: The following serializes a namespace prefix declaration for prefix which was\n            // just added to the map.\n            // 12.5.5.1. \" \" (U+0020 SPACE);\n            // 12.5.5.2. The string \"xmlns:\";\n            // 12.5.5.3. The value of prefix;\n            // 12.5.5.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n            // 12.5.5.5. The result of serializing an attribute value given ns and the require\n            // well-formed flag as input;\n            // 12.5.5.6. \"\"\" (U+0022 QUOTATION MARK).\n            result.push(' xmlns:', prefix, '=\"', serializeAttributeValue(ns, requireWellFormed), '\"');\n            // 12.5.5.7. If local default namespace is not null (there exists a locally-defined\n            // default namespace declaration attribute), then let inherited ns get the value of\n            // local default namespace unless the local default namespace is the empty string in\n            // which case let it get null.\n            if (localDefaultNamespace !== null) {\n                inheritedNs = localDefaultNamespace === '' ? null : localDefaultNamespace;\n            }\n        }\n        else if (localDefaultNamespace === null ||\n            (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {\n            // 12.6. Otherwise, if local default namespace is null, or local default namespace is\n            // not null and its value is not equal to ns, then:\n            // NOTE: At this point, the namespace for this node still needs to be serialized, but\n            // there's no prefix (or candidate prefix) availble; the following uses the default\n            // namespace declaration to define the namespace --optionally replacing an existing\n            // default declaration if present.\n            // 12.6.1. Set the ignore namespace definition attribute flag to true.\n            ignoreNamespaceDefinitionAttribute = true;\n            // 12.6.2. Append to qualified name the value of node's localName.\n            qualifiedName += element.localName;\n            // 12.6.3. Let the value of inherited ns be ns.\n            // NOTE: The new default namespace will be used in the serialization to define this\n            // node's namespace and act as the context namespace for its children.\n            inheritedNs = ns;\n            // 12.6.4. Append the value of qualified name to markup.\n            result.push(qualifiedName);\n            // 12.6.5. Append the following to markup, in the order listed:\n            // NOTE: The following serializes the new (or replacement) default namespace definition.\n            // 12.6.5.1. \" \" (U+0020 SPACE);\n            // 12.6.5.2. The string \"xmlns\";\n            // 12.6.5.3. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n            // 12.6.5.4. The result of serializing an attribute value given ns and the require\n            // well-formed flag as input;\n            // 12.6.5.5. \"\"\" (U+0022 QUOTATION MARK).\n            result.push(' xmlns=\"', serializeAttributeValue(ns, requireWellFormed), '\"');\n        }\n        else {\n            // 12.7. Otherwise, the node has a local default namespace that matches ns. Append to\n            // qualified name the value of node's localName, let the value of inherited ns be ns,\n            // and append the value of qualified name to markup.\n            qualifiedName += element.localName;\n            inheritedNs = ns;\n            result.push(qualifiedName);\n        }\n        // NOTE: All of the combinations where ns is not equal to inherited ns are handled above\n        // such that node will be serialized preserving its original namespaceURI.\n    }\n    // 13. Append to markup the result of the XML serialization of node's attributes given map,\n    // prefix index, local prefixes map, ignore namespace definition attribute flag, and require\n    // well-formed flag.\n    serializeAttributes(element, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, result);\n    // 14. If ns is the HTML namespace, and the node's list of children is empty, and the node's\n    // localName matches any one of the following void elements: \"area\", \"base\", \"basefont\",\n    // \"bgsound\", \"br\", \"col\", \"embed\", \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\",\n    // \"meta\", \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup, in the order\n    // listed:\n    if (ns === HTML_NAMESPACE &&\n        !element.hasChildNodes() &&\n        HTML_VOID_ELEMENTS.indexOf(element.localName) >= 0) {\n        // 14.1. \" \" (U+0020 SPACE);\n        // 14.2. \"/\" (U+002F SOLIDUS).\n        result.push(' /');\n        // and set the skip end tag flag to true.\n        skipEndTag = true;\n    }\n    // 15. If ns is not the HTML namespace, and the node's list of children is empty, then append\n    // \"/\" (U+002F SOLIDUS) to markup and set the skip end tag flag to true.\n    if (ns !== HTML_NAMESPACE && !element.hasChildNodes()) {\n        result.push('/');\n        skipEndTag = true;\n    }\n    // 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n    result.push('>');\n    // 17. If the value of skip end tag is true, then return the value of markup and skip the\n    // remaining steps. The node is a leaf-node.\n    if (skipEndTag) {\n        return;\n    }\n    // 18. If ns is the HTML namespace, and the node's localName matches the string \"template\", then\n    // this is a template element. Append to markup the result of XML serializing a DocumentFragment\n    // node given the template element's template contents (a DocumentFragment), providing inherited\n    // ns, map, prefix index, and the require well-formed flag.\n    // NOTE: This allows template content to round-trip , given the rules for parsing XHTML\n    // documents.\n    // (HTML documents not implemented)\n    // 19. Otherwise, append to markup the result of running the XML serialization algorithm on each\n    // of node's children, in tree order, providing inherited ns, map, prefix index, and the require\n    // well-formed flag.\n    for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {\n        var child = _a[_i];\n        runXmlSerializationAlgorithm(child, inheritedNs, map, prefixIndex, requireWellFormed, result);\n    }\n    // 20. Append the following to markup, in the order listed:\n    // 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n    // 20.2. The value of qualified name;\n    // 20.3. \">\" (U+003E GREATER-THAN SIGN).\n    result.push('</', qualifiedName, '>');\n    // 21. Return the value of markup.\n}\n// 3.2.1.1.3 Serializing an Element's attributes\n/**\n * The XML serialization of the attributes of an Element element together with a namespace prefix\n * map map, a generated namespace prefix index prefix index reference, a local prefixes map, a\n * ignore namespace definition attribute flag, and a require well-formed flag, is the result of the\n * following algorithm:\n *\n * @param element                            The element for which to serialize attributes\n * @param prefixMap                          The namespace prefix map\n * @param prefixIndex                        The generated namespace prefix index, by reference\n * @param localPrefixesMap                   The local prefixes map\n * @param ignoreNamespaceDefinitionAttribute The ignore namespace definition attribute flag\n * @param requireWellFormed                  The require well-formed flag\n * @param result                             Array of strings in which to construct the result\n */\nfunction serializeAttributes(element, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, result) {\n    // 1. Let result be the empty string.\n    // (result constructed in-place in argument)\n    // 2. Let localname set be a new empty namespace localname set. This localname set will contain\n    // tuples of unique attribute namespaceURI and localName pairs, and is populated as each attr is\n    // processed. This set is used to [optionally] enforce the well-formed constraint that an\n    // element cannot have two attributes with the same namespaceURI and localName. This can occur\n    // when two otherwise identical attributes on the same element differ only by their prefix\n    // values.\n    var localNameSet = [];\n    var _loop_1 = function (attr) {\n        // 3.1. If the require well-formed flag is set (its value is true), and the localname set\n        // contains a tuple whose values match those of a new tuple consisting of attr's\n        // namespaceURI attribute and localName attribute, then throw an exception; the\n        // serialization of this attr would fail to produce a well-formed element serialization.\n        if (requireWellFormed &&\n            localNameSet.find(function (tuple) {\n                return tuple.localName === attr.localName && tuple.namespaceURI === attr.namespaceURI;\n            })) {\n            throw new Error('The serialization of this attr would fail to produce a well-formed element ' +\n                'serialization');\n        }\n        // 3.2. Create a new tuple consisting of attr's namespaceURI attribute and localName\n        // attribute, and add it to the localname set.\n        localNameSet.push({ namespaceURI: attr.namespaceURI, localName: attr.localName });\n        // 3.3. Let attribute namespace be the value of attr's namespaceURI value.\n        var attributeNamespace = attr.namespaceURI;\n        // 3.4. Let candidate prefix be null.\n        var candidatePrefix = null;\n        // 3.5. If attribute namespace is not null, then run these sub-steps:\n        if (attributeNamespace !== null) {\n            // 3.5.1. Let candidate prefix be the result of retrieving a preferred prefix string\n            // from map given namespace attribute namespace with preferred prefix being attr's\n            // prefix value.\n            candidatePrefix = map.retrievePreferredPrefixString(attr.prefix, attributeNamespace);\n            // 3.5.2. If the value of attribute namespace is the XMLNS namespace, then run these\n            // steps:\n            if (attributeNamespace === XMLNS_NAMESPACE) {\n                // 3.5.2.1. If any of the following are true, then stop running these steps and goto\n                // Loop to visit the next attribute:\n                // - the attr's value is the XML namespace;\n                // NOTE: The XML namespace cannot be redeclared and survive round-tripping (unless\n                // it defines the prefix \"xml\"). To avoid this problem, this algorithm always\n                // prefixes elements in the XML namespace with \"xml\" and drops any related\n                // definitions as seen in the above condition.\n                if (attr.value === XML_NAMESPACE) {\n                    return \"continue\";\n                }\n                // - the attr's prefix is null and the ignore namespace definition attribute flag is\n                // true (the Element's default namespace attribute should be skipped);\n                if (attr.prefix === null && ignoreNamespaceDefinitionAttribute) {\n                    return \"continue\";\n                }\n                // - the attr's prefix is not null and either\n                //   - the attr's localName is not a key contained in the local prefixes map, or\n                //   - the attr's localName is present in the local prefixes map but the value of\n                //     the key does not match attr's value\n                if (attr.prefix !== null &&\n                    (!(attr.localName in localPrefixesMap) ||\n                        localPrefixesMap[attr.localName] !== attr.value)) {\n                    return \"continue\";\n                }\n                // 3.5.2.2. If the require well-formed flag is set (its value is true), and the\n                // value of attr's value attribute matches the XMLNS namespace, then throw an\n                // exception; the serialization of this attribute would produce invalid XML because\n                // the XMLNS namespace is reserved and cannot be applied as an element's namespace\n                // via XML parsing.\n                // NOTE: DOM APIs do allow creation of elements in the XMLNS namespace but with\n                // strict qualifications.\n                if (requireWellFormed && attr.value === XMLNS_NAMESPACE) {\n                    throw new Error('The serialization of this attribute would produce invalid XML because ' +\n                        'the XMLNS namespace is reserved and cannot be applied as an ' +\n                        \"element's namespace via XML parsing\");\n                }\n                // 3.5.2.3. If the require well-formed flag is set (its value is true), and the\n                // value of attr's value attribute is the empty string, then throw an exception;\n                // namespace prefix declarations cannot be used to undeclare a namespace (use a\n                // default namespace declaration instead).\n                if (requireWellFormed && attr.value === '') {\n                    throw new Error('Namespace prefix declarations cannot be used to undeclare a namespace ' +\n                        '(use a default namespace declaration instead)');\n                }\n                // 3.5.2.4. the attr's prefix matches the string \"xmlns\", then let candidate prefix\n                // be the string \"xmlns\".\n                if (attr.prefix === 'xmlns') {\n                    candidatePrefix = 'xmlns';\n                }\n            }\n            else {\n                // 3.5.3. Otherwise, the attribute namespace in not the XMLNS namespace. Run these\n                // steps:\n                // Note: we deviate from the spec here, as implementing as specified would generate\n                // prefixes for all namespaced attributes.\n                if (candidatePrefix === null) {\n                    if (attr.prefix === null || attr.prefix in localPrefixesMap) {\n                        // 3.5.3.1. Let candidate prefix be the result of generating a prefix\n                        // providing map, attribute namespace, and prefix index as input.\n                        candidatePrefix = generatePrefix(map, attributeNamespace, prefixIndex);\n                    }\n                    else {\n                        candidatePrefix = attr.prefix;\n                    }\n                    // Update the local and aggregate prefixes to account for the new declaration.\n                    map.add(candidatePrefix, attr.namespaceURI);\n                    localPrefixesMap[candidatePrefix] = attr.namespaceURI;\n                    // 3.5.3.2. Append the following to result, in the order listed:\n                    // 3.5.3.2.1. \" \" (U+0020 SPACE);\n                    // 3.5.3.2.2. The string \"xmlns:\";\n                    // 3.5.3.2.3. The value of candidate prefix;\n                    // 3.5.3.2.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                    // 3.5.3.2.5. The result of serializing an attribute value given attribute\n                    // namespace and the require well-formed flag as input;\n                    // 3.5.3.2.7. \"\"\" (U+0022 QUOTATION MARK).\n                    result.push(' xmlns:', candidatePrefix, '=\"', serializeAttributeValue(attributeNamespace, requireWellFormed), '\"');\n                }\n            }\n        }\n        // 3.6. Append a \" \" (U+0020 SPACE) to result.\n        result.push(' ');\n        // 3.7. If candidate prefix is not null, then append to result the concatenation of\n        // candidate prefix with \":\" (U+003A COLON).\n        if (candidatePrefix !== null) {\n            result.push(candidatePrefix, ':');\n        }\n        // 3.8. If the require well-formed flag is set (its value is true), and this attr's\n        // localName attribute contains the character \":\" (U+003A COLON) or does not match the XML\n        // Name production or equals \"xmlns\" and attribute namespace is null, then throw an\n        // exception; the serialization of this attr would not be a well-formed attribute.\n        if (requireWellFormed &&\n            (attr.localName.indexOf(':') >= 0 ||\n                !matchesNameProduction(attr.localName) ||\n                (attr.localName === 'xmlns' && attributeNamespace === null))) {\n            throw new Error('The serialization of this attr would not be a well-formed attribute');\n        }\n        // 3.9. Append the following strings to result, in the order listed:\n        // 3.9.1. The value of attr's localName;\n        // 3.9.2. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n        // 3.9.3. The result of serializing an attribute value given attr's value attribute and the\n        // require well-formed flag as input;\n        // 3.9.4. \"\"\" (U+0022 QUOTATION MARK).\n        result.push(attr.localName, '=\"', serializeAttributeValue(attr.value, requireWellFormed), '\"');\n    };\n    // 3. Loop: For each attribute attr in element's attributes, in the order they are specified in\n    // the element's attribute list:\n    for (var _i = 0, _a = element.attributes; _i < _a.length; _i++) {\n        var attr = _a[_i];\n        _loop_1(attr);\n    }\n    // 4. Return the value of result.\n}\n/**\n * When serializing an attribute value given an attribute value and require well-formed flag, the\n * user agent must run the following steps:\n *\n * @param attributeValue    The attribute value to serialize\n * @param requireWellFormed Determines whether the result needs to be well-formed\n *\n * @return The serialized attribute value\n */\nfunction serializeAttributeValue(attributeValue, requireWellFormed) {\n    // 1. If the require well-formed flag is set (its value is true), and attribute value contains\n    // characters that are not matched by the XML Char production, then throw an exception; the\n    // serialization of this attribute value would fail to produce a well-formed element\n    // serialization.\n    if (requireWellFormed &&\n        attributeValue !== null &&\n        !CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(attributeValue)) {\n        throw new Error('The serialization of this attribute value would fail to produce a well-formed ' +\n            'element serialization');\n    }\n    // 2. If attribute value is null, then return the empty string.\n    if (attributeValue === null) {\n        return '';\n    }\n    // 3. Otherwise, attribute value is a string. Return the value of attribute value, first\n    // replacing any occurrences of the following:\n    return (attributeValue\n        // 3.1. \"&\" with \"&amp;\"\n        .replace(/&/g, '&amp;')\n        // 3.2. \"\"\" with \"&quot;\"\n        .replace(/\"/g, '&quot;')\n        // 3.3. \"<\" with \"&lt;\"\n        .replace(/</g, '&lt;')\n        // 3.4. \">\" with \"&gt;\"\n        .replace(/>/g, '&gt;'));\n    // NOTE: This matches behavior present in browsers, and goes above and beyond the grammar\n    // requirement in the XML specification's AttValue production by also replacing \">\" characters.\n}\n// 3.2.1.1.4 Generating namespace prefixes\n/**\n * To generate a prefix given a namespace prefix map map, a string new namespace, and a reference to\n * a generated namespace prefix index prefix index, the user agent must run the following steps:\n *\n * @param map          The namespace prefix map\n * @param newNamespace The new namespace to generate a prefix for\n * @param prefixIndex  The reference to the generated namespace prefix index\n *\n * @return The generated prefix for the new namespace\n */\nfunction generatePrefix(map, newNamespace, prefixIndex) {\n    // 1. Let generated prefix be the concatenation of the string \"ns\" and the current numerical\n    // value of prefix index.\n    var generatedPrefix = 'ns' + prefixIndex.value;\n    // 2. Let the value of prefix index be incremented by one.\n    prefixIndex.value += 1;\n    // 3. Add to map the generated prefix given the new namespace namespace.\n    map.add(generatedPrefix, newNamespace);\n    // 4. Return the value of generated prefix.\n    return generatedPrefix;\n}\n/**\n * 3.2.1.2 XML serializing a Document node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeDocumentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var document = node;\n    // 1. If the require well-formed flag is set (its value is true), and this node has no\n    // documentElement (the documentElement attribute's value is null), then throw an exception; the\n    // serialization of this node would not be a well-formed document.\n    if (requireWellFormed && document.documentElement === null) {\n        throw new Error('The serialization of this node would not be a well-formed document');\n    }\n    // 2. Otherwise, run the following steps:\n    // 2.1. Let serialized document be an empty string.\n    // (constructed in-place in result argument)\n    // 2.2. For each child child of node, in tree order, run the XML serialization algorithm on the\n    // child passing along the provided arguments, and append the result to serialized document.\n    // NOTE: This will serialize any number of ProcessingInstruction and Comment nodes both before\n    // and after the Document's documentElement node, including at most one DocumentType node. (Text\n    // nodes are not allowed as children of the Document.)\n    for (var _i = 0, _a = document.childNodes; _i < _a.length; _i++) {\n        var child = _a[_i];\n        runXmlSerializationAlgorithm(child, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n    }\n    // 2.3. Return the value of serialized document.\n}\n/**\n * 3.2.1.3 XML serializing a Comment node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeCommentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var comment = node;\n    // 1. If the require well-formed flag is set (its value is true), and node's data contains\n    // characters that are not matched by the XML Char production or contains \"--\" (two adjacent\n    // U+002D HYPHEN-MINUS characters) or that ends with a \"-\" (U+002D HYPHEN-MINUS) character, then\n    // throw an exception; the serialization of this node's data would not be well-formed.\n    if (requireWellFormed &&\n        (!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(comment.data) ||\n            comment.data.indexOf('--') >= 0 ||\n            comment.data.endsWith('-'))) {\n        throw new Error(\"The serialization of this node's data would not be well-formed\");\n    }\n    // 2. Otherwise, return the concatenation of \"<!--\", node's data, and \"-->\".\n    result.push('<!--', comment.data, '-->');\n}\n/**\n * (not currently in spec) XML serializing a CDATASection node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeCDATASectionNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var cs = node;\n    // 1. Let markup be the concatenation of \"<![CDATA[\", node's data, and \"]]>\".\n    result.push('<![CDATA[', cs.data, ']]>');\n    // 2. Return the value of markup.\n}\n/**\n * 3.2.1.4 XML serializing a Text node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeTextNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var text = node;\n    // 1. If the require well-formed flag is set (its value is true), and node's data contains\n    // characters that are not matched by the XML Char production, then throw an exception; the\n    // serialization of this node's data would not be well-formed.\n    if (requireWellFormed && !CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(text.data)) {\n        throw new Error(\"The serialization of this node's data would not be well-formed\");\n    }\n    // 2. Let markup be the value of node's data.\n    var markup = text.data;\n    // 3. Replace any occurrences of \"&\" in markup by \"&amp;\".\n    markup = markup.replace(/&/g, '&amp;');\n    // 4. Replace any occurrences of \"<\" in markup by \"&lt;\".\n    markup = markup.replace(/</g, '&lt;');\n    // 5. Replace any occurrences of \">\" in markup by \"&gt;\".\n    markup = markup.replace(/>/g, '&gt;');\n    // 6. Return the value of markup.\n    result.push(markup);\n}\n/**\n * 3.2.1.5 XML serializing a DocumentFragment node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeDocumentFragmentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    // 1. Let markup the empty string.\n    // (constructed in-place in result argument)\n    // 2. For each child child of node, in tree order, run the XML serialization algorithm on the\n    // child given namespace, prefix map, a reference to prefix index, and flag require well-formed.\n    // Concatenate the result to markup.\n    for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {\n        var child = _a[_i];\n        runXmlSerializationAlgorithm(child, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n    }\n    // 3. Return the value of markup.\n}\n/**\n * 3.2.1.6 XML serializing a DocumentType node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeDocumentTypeNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var dt = node;\n    // 1. If the require well-formed flag is true and the node's publicId attribute contains\n    // characters that are not matched by the XML PubidChar production, then throw an exception; the\n    // serialization of this node would not be a well-formed document type declaration.\n    if (requireWellFormed && !PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION.test(dt.publicId)) {\n        throw new Error('The serialization of this node would not be a well-formed document type declaration');\n    }\n    // 2. If the require well-formed flag is true and the node's systemId attribute contains\n    // characters that are not matched by the XML Char production or that contains both a \"\"\"\n    // (U+0022 QUOTATION MARK) and a \"'\" (U+0027 APOSTROPHE), then throw an exception; the\n    // serialization of this node would not be a well-formed document type declaration.\n    if (requireWellFormed &&\n        (!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(dt.systemId) ||\n            (dt.systemId.indexOf('\"') >= 0 && dt.systemId.indexOf(\"'\") >= 0))) {\n        throw new Error('The serialization of this node would not be a well-formed document type declaration');\n    }\n    // 3. Let markup be an empty string.\n    // (constructed in-place in result argument)\n    // 4. Append the string \"<!DOCTYPE\" to markup.\n    result.push('<!DOCTYPE');\n    // 5. Append \" \" (U+0020 SPACE) to markup.\n    result.push(' ');\n    // 6. Append the value of the node's name attribute to markup. For a node belonging to an HTML\n    // document, the value will be all lowercase.\n    // (HTML documents not implemented)\n    result.push(dt.name);\n    // 7. If the node's publicId is not the empty string then append the following, in the order\n    // listed, to markup:\n    if (dt.publicId !== '') {\n        // 7.1. \" \" (U+0020 SPACE);\n        // 7.2. The string \"PUBLIC\";\n        // 7.3. \" \" (U+0020 SPACE);\n        // 7.4. \"\"\" (U+0022 QUOTATION MARK);\n        // 7.5. The value of the node's publicId attribute;\n        // 7.6. \"\"\" (U+0022 QUOTATION MARK).\n        result.push(' PUBLIC \"', dt.publicId, '\"');\n    }\n    // 8. If the node's systemId is not the empty string and the node's publicId is set to the empty\n    // string, then append the following, in the order listed, to markup:\n    if (dt.systemId !== '' && dt.publicId === '') {\n        // 8.1. \" \" (U+0020 SPACE);\n        // 8.2. The string \"SYSTEM\".\n        result.push(' SYSTEM');\n    }\n    // 9. If the node's systemId is not the empty string then append the following, in the order\n    // listed, to markup:\n    if (dt.systemId !== '') {\n        // 9.1. \" \" (U+0020 SPACE);\n        // 9.2. \"\"\" (U+0022 QUOTATION MARK);\n        // 9.3. The value of the node's systemId attribute;\n        // 9.4. \"\"\" (U+0022 QUOTATION MARK).\n        result.push(' \"', dt.systemId, '\"');\n    }\n    // 10. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n    result.push('>');\n    // 11. Return the value of markup.\n}\n/**\n * 3.2.1.7 XML serializing a ProcessingInstruction node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeProcessingInstructionNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var pi = node;\n    // 1. If the require well-formed flag is set (its value is true), and node's target contains a\n    // \":\" (U+003A COLON) character or is an ASCII case-insensitive match for the string \"xml\", then\n    // throw an exception; the serialization of this node's target would not be well-formed.\n    if (requireWellFormed && (pi.target.indexOf(':') >= 0 || pi.target.toLowerCase() === 'xml')) {\n        throw new Error(\"The serialization of this node's target would not be well-formed\");\n    }\n    // 2. If the require well-formed flag is set (its value is true), and node's data contains\n    // characters that are not matched by the XML Char production or contains the string \"?>\"\n    // (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN), then throw an exception; the serialization\n    // of this node's data would not be well-formed.\n    if (requireWellFormed &&\n        (!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(pi.data) || pi.data.indexOf('?>') >= 0)) {\n        throw new Error(\"The serialization of this node's data would not be well-formed\");\n    }\n    // 3. Let markup be the concatenation of the following, in the order listed:\n    // 3.1. \"<?\" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);\n    // 3.2. The value of node's target;\n    // 3.3. \" \" (U+0020 SPACE);\n    // 3.4. The value of node's data;\n    // 3.5. \"?>\" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).\n    result.push('<?', pi.target, ' ', pi.data, '?>');\n    // 4. Return the value of markup.\n}\n//# sourceMappingURL=serializationAlgorithms.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getChildren, getPreviousElementSibling, getNextElementSibling } from './mixins';\nimport Attr from './Attr';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { serializeFragment } from './dom-parsing/serializationAlgorithms';\nimport { appendAttribute, changeAttribute, removeAttribute, replaceAttribute } from './util/attrMutations';\nimport { expectArity, throwInUseAttributeError, throwInvalidCharacterError, throwNotFoundError } from './util/errorHelpers';\nimport { matchesNameProduction, validateAndExtract, locateNamespacePrefix, XMLNS_NAMESPACE } from './util/namespaceHelpers';\nimport { asNullableString, asObject } from './util/typeHelpers';\n/**\n * 3.9. Interface Element\n */\nvar Element = /** @class */ (function (_super) {\n    __extends(Element, _super);\n    /**\n     * (non-standard) Use Document#createElement or Document#createElementNS to create an Element.\n     *\n     * @param namespace Namespace for the element\n     * @param prefix    Prefix for the element\n     * @param localName Local name for the element\n     */\n    function Element(namespace, prefix, localName) {\n        var _this = _super.call(this) || this;\n        _this.firstElementChild = null;\n        _this.lastElementChild = null;\n        _this.childElementCount = 0;\n        /**\n         * The attributes for the element.\n         *\n         * Non-standard: the spec defines this as a NamedNodeMap, while this implementation uses an\n         * array.\n         */\n        _this.attributes = [];\n        _this.namespaceURI = namespace;\n        _this.prefix = prefix;\n        _this.localName = localName;\n        _this.tagName = prefix === null ? localName : prefix + \":\" + localName;\n        return _this;\n    }\n    Object.defineProperty(Element.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 1 /* ELEMENT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"nodeName\", {\n        get: function () {\n            return this.tagName;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"nodeValue\", {\n        get: function () {\n            return null;\n        },\n        set: function (newValue) {\n            // Do nothing.\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Element.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        namespace = asNullableString(namespace);\n        // 1. If namespace is null or the empty string, then return null.\n        if (namespace === null || namespace === '') {\n            return null;\n        }\n        // 2. Switch on the context object:\n        // Element - Return the result of locating a namespace prefix for it using namespace.\n        return locateNamespacePrefix(this, namespace);\n    };\n    Element.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        prefix = asNullableString(prefix);\n        // 1. If prefix is the empty string, then set it to null.\n        if (prefix === '') {\n            prefix = null;\n        }\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: Element\n        // 1. If its namespace is not null and its namespace prefix is prefix, then return\n        // namespace.\n        if (this.namespaceURI !== null && this.prefix === prefix) {\n            return this.namespaceURI;\n        }\n        // 2. If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is\n        // \"xmlns\", and local name is prefix, or if prefix is null and it has an attribute whose\n        // namespace is the XMLNS namespace, namespace prefix is null, and local name is \"xmlns\",\n        // then return its value if it is not the empty string, and null otherwise.\n        var ns = null;\n        if (prefix !== null) {\n            var attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, prefix);\n            if (attr && attr.prefix === 'xmlns') {\n                ns = attr.value;\n            }\n        }\n        else {\n            var attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, 'xmlns');\n            if (attr && attr.prefix === null) {\n                ns = attr.value;\n            }\n        }\n        if (ns !== null) {\n            return ns !== '' ? ns : null;\n        }\n        // 3. If its parent element is null, then return null.\n        var parentElement = this.parentElement;\n        if (parentElement === null) {\n            return null;\n        }\n        // 4. Return the result of running locate a namespace on its parent element using prefix.\n        return parentElement.lookupNamespaceURI(prefix);\n    };\n    Object.defineProperty(Element.prototype, \"children\", {\n        // ParentNode\n        get: function () {\n            return getChildren(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"previousElementSibling\", {\n        // NonDocumentTypeChildNode\n        get: function () {\n            return getPreviousElementSibling(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"nextElementSibling\", {\n        get: function () {\n            return getNextElementSibling(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns whether the element has any attributes.\n     *\n     * @return True if the element has attributes, otherwise false\n     */\n    Element.prototype.hasAttributes = function () {\n        return this.attributes.length > 0;\n    };\n    /**\n     * Get the value of the specified attribute.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     *\n     * @return The value of the attribute, or null if no such attribute exists\n     */\n    Element.prototype.getAttribute = function (qualifiedName) {\n        expectArity(arguments, 1);\n        qualifiedName = String(qualifiedName);\n        // 1. Let attr be the result of getting an attribute given qualifiedName and the context\n        // object.\n        var attr = getAttributeByName(qualifiedName, this);\n        // 2. If attr is null, return null.\n        if (attr === null) {\n            return null;\n        }\n        // 3. Return attr’s value.\n        return attr.value;\n    };\n    /**\n     * Get the value of the specified attribute.\n     *\n     * @param namespace The namespace of the attribute\n     * @param localName The local name of the attribute\n     *\n     * @return The value of the attribute, or null if no such attribute exists\n     */\n    Element.prototype.getAttributeNS = function (namespace, localName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        localName = String(localName);\n        // 1. Let attr be the result of getting an attribute given namespace, localName, and the\n        // context object.\n        var attr = getAttributeByNamespaceAndLocalName(namespace, localName, this);\n        // 2. If attr is null, return null.\n        if (attr === null) {\n            return null;\n        }\n        // 3. Return attr’s value.\n        return attr.value;\n    };\n    /**\n     * Sets the value of the specified attribute.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     * @param value         The new value for the attribute\n     */\n    Element.prototype.setAttribute = function (qualifiedName, value) {\n        expectArity(arguments, 2);\n        qualifiedName = String(qualifiedName);\n        value = String(value);\n        // 1. If qualifiedName does not match the Name production in XML, then throw an\n        // InvalidCharacterError.\n        if (!matchesNameProduction(qualifiedName)) {\n            throwInvalidCharacterError('The qualified name does not match the Name production');\n        }\n        // 2. If the context object is in the HTML namespace and its node document is an HTML\n        // document, then set qualifiedName to qualifiedName in ASCII lowercase.\n        // (html documents not implemented)\n        // 3. Let attribute be the first attribute in context object’s attribute list whose\n        // qualified name is qualifiedName, and null otherwise.\n        var attribute = getAttributeByName(qualifiedName, this);\n        // 4. If attribute is null, create an attribute whose local name is qualifiedName, value is\n        // value, and node document is context object’s node document, then append this attribute to\n        // context object, and then return.\n        if (attribute === null) {\n            var context = getContext(this);\n            var attribute_1 = new context.Attr(null, null, qualifiedName, value, this);\n            attribute_1.ownerDocument = this.ownerDocument;\n            appendAttribute(attribute_1, this);\n            return;\n        }\n        // 5. Change attribute from context object to value.\n        changeAttribute(attribute, this, value);\n    };\n    /**\n     * Sets the value of the specified attribute.\n     *\n     * @param namespace     The namespace of the attribute\n     * @param qualifiedName The qualified name of the attribute\n     * @param value         The value for the attribute\n     */\n    Element.prototype.setAttributeNS = function (namespace, qualifiedName, value) {\n        expectArity(arguments, 3);\n        namespace = asNullableString(namespace);\n        qualifiedName = String(qualifiedName);\n        value = String(value);\n        // 1. Let namespace, prefix, and localName be the result of passing namespace and\n        // qualifiedName to validate and extract.\n        var _a = validateAndExtract(namespace, qualifiedName), validatedNamespace = _a.namespace, prefix = _a.prefix, localName = _a.localName;\n        // 2. Set an attribute value for the context object using localName, value, and also prefix\n        // and namespace.\n        setAttributeValue(this, localName, value, prefix, validatedNamespace);\n    };\n    /**\n     * Removes the specified attribute.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     */\n    Element.prototype.removeAttribute = function (qualifiedName) {\n        expectArity(arguments, 1);\n        qualifiedName = String(qualifiedName);\n        removeAttributeByName(qualifiedName, this);\n    };\n    /**\n     * Removes the specified attribute.\n     *\n     * @param namespace The namespace of the attribute\n     * @param localName The local name of the attribute\n     */\n    Element.prototype.removeAttributeNS = function (namespace, localName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        localName = String(localName);\n        removeAttributeByNamespaceAndLocalName(namespace, localName, this);\n    };\n    /**\n     * If force is not given, \"toggles\" qualifiedName, removing it if it is present and adding it if\n     * it is not present. If force is true, adds qualifiedName. If force is false, removes\n     * qualifiedName.\n     *\n     * Returns true if qualifiedName is now present, and false otherwise.\n     *\n     * @param qualifiedName\n     * @param force\n     */\n    Element.prototype.toggleAttribute = function (qualifiedName, force) {\n        // 1. If qualifiedName does not match the Name production in XML, then throw an\n        // \"InvalidCharacterError\" DOMException.\n        if (!matchesNameProduction(qualifiedName)) {\n            throwInvalidCharacterError('The qualified name does not match the Name production');\n        }\n        // 2. If the context object is in the HTML namespace and its node document is an HTML\n        // document, then set qualifiedName to qualifiedName in ASCII lowercase.\n        // (html documents not implemented)\n        // 3. Let attribute be the first attribute in the context object’s attribute list whose\n        // qualified name is qualifiedName, and null otherwise.\n        var attribute = getAttributeByName(qualifiedName, this);\n        // 4. If attribute is null, then:\n        if (attribute === null) {\n            // 4.1. If force is not given or is true,\n            if (force === undefined || force === true) {\n                // ...create an attribute whose local name is qualifiedName, value is the empty\n                // string, and node document is the context object’s node document,\n                var context = getContext(this);\n                var attribute_2 = new context.Attr(null, null, qualifiedName, '', this);\n                attribute_2.ownerDocument = this.ownerDocument;\n                // ...then append this attribute to the context object,\n                appendAttribute(attribute_2, this);\n                // ...and then return true.\n                return true;\n            }\n            // 4.2. Return false.\n            return false;\n        }\n        // 5. Otherwise, if force is not given or is false,\n        if (force === undefined || force === false) {\n            // ...remove an attribute given qualifiedName and the context object,\n            removeAttributeByName(qualifiedName, this);\n            // ...and then return false.\n            return false;\n        }\n        // 6. Return true.\n        return true;\n    };\n    /**\n     * Returns true if the specified attribute exists and false otherwise.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     */\n    Element.prototype.hasAttribute = function (qualifiedName) {\n        expectArity(arguments, 1);\n        qualifiedName = String(qualifiedName);\n        // 1. If the context object is in the HTML namespace and its node document is an HTML\n        // document, then set qualifiedName to qualifiedName in ASCII lowercase.\n        // (html documents not implemented)\n        // 2. Return true if the context object has an attribute whose qualified name is\n        // qualifiedName, and false otherwise.\n        return getAttributeByName(qualifiedName, this) !== null;\n    };\n    /**\n     * Returns true if the specified attribute exists and false otherwise.\n     *\n     * @param namespace The namespace of the attribute\n     * @param localName The local name of the attribute\n     */\n    Element.prototype.hasAttributeNS = function (namespace, localName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        localName = String(localName);\n        // 1. If namespace is the empty string, set it to null.\n        // (handled by getAttributeByNamespaceAndLocalName, called below)\n        // 2. Return true if the context object has an attribute whose namespace is namespace and\n        // local name is localName, and false otherwise.\n        return getAttributeByNamespaceAndLocalName(namespace, localName, this) !== null;\n    };\n    /**\n     * Returns the specified attribute node, or null if no such attribute exists.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     *\n     * @return The attribute, or null if no such attribute exists\n     */\n    Element.prototype.getAttributeNode = function (qualifiedName) {\n        expectArity(arguments, 1);\n        qualifiedName = String(qualifiedName);\n        return getAttributeByName(qualifiedName, this);\n    };\n    /**\n     * Returns the specified attribute node, or null if no such attribute exists.\n     *\n     * @param namespace The namespace of the attribute\n     * @param localName The local name of the attribute\n     *\n     * @return The attribute, or null if no such attribute exists\n     */\n    Element.prototype.getAttributeNodeNS = function (namespace, localName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        localName = String(localName);\n        return getAttributeByNamespaceAndLocalName(namespace, localName, this);\n    };\n    /**\n     * Sets an attribute given its node\n     *\n     * @param attr The attribute node to set\n     *\n     * @return The previous attribute node for the attribute\n     */\n    Element.prototype.setAttributeNode = function (attr) {\n        expectArity(arguments, 1);\n        attr = asObject(attr, Attr);\n        return setAttribute(attr, this);\n    };\n    /**\n     * Sets an attribute given its node\n     *\n     * @param attr The attribute node to set\n     *\n     * @return The previous attribute node for the attribute\n     */\n    Element.prototype.setAttributeNodeNS = function (attr) {\n        expectArity(arguments, 1);\n        attr = asObject(attr, Attr);\n        return setAttribute(attr, this);\n    };\n    /**\n     * Removes an attribute given its node\n     *\n     * @param attr The attribute node to remove\n     *\n     * @return The removed attribute node\n     */\n    Element.prototype.removeAttributeNode = function (attr) {\n        expectArity(arguments, 1);\n        attr = asObject(attr, Attr);\n        // 1. If context object’s attribute list does not contain attr, then throw a NotFoundError.\n        if (this.attributes.indexOf(attr) < 0) {\n            throwNotFoundError('the specified attribute does not exist');\n        }\n        // 2. Remove attr from context object.\n        removeAttribute(attr, this);\n        // 3. Return attr.\n        return attr;\n    };\n    /**\n     * (non-standard) Creates a copy of the given node\n     *\n     * @param document The node document to associate with the copy\n     * @param other    The node to copy\n     *\n     * @return A shallow copy of the node\n     */\n    Element.prototype._copy = function (document) {\n        // 2.1. Let copy be the result of creating an element, given document, node’s local name,\n        // node’s namespace, node’s namespace prefix, and the value of node’s is attribute if\n        // present (or null if not). The synchronous custom elements flag should be unset.\n        var copyElement = createElement(document, this.localName, this.namespaceURI, this.prefix);\n        // 2.2. For each attribute in node’s attribute list:\n        for (var _i = 0, _a = this.attributes; _i < _a.length; _i++) {\n            var attr = _a[_i];\n            // 2.2.1. Let copyAttribute be a clone of attribute.\n            var copyAttribute = attr._copy(document);\n            // 2.2.2. Append copyAttribute to copy.\n            copyElement.setAttributeNode(copyAttribute);\n        }\n        return copyElement;\n    };\n    Object.defineProperty(Element.prototype, \"innerHTML\", {\n        // From the DOM Parsing and Serialization spec\n        /**\n         * Returns a fragment of HTML or XML that represents the element's contents.\n         */\n        get: function () {\n            // Return the result of invoking the fragment serializing algorithm on the context object\n            // providing true for the require well-formed flag (this might throw an exception instead of\n            // returning a string).\n            return serializeFragment(this, true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"outerHTML\", {\n        /**\n         * Returns a fragment of HTML or XML that represents the element and its contents.\n         */\n        get: function () {\n            // Return the result of invoking the fragment serializing algorithm on a fictional node\n            // whose only child is the context object providing true for the require well-formed flag\n            // (this might throw an exception instead of returning a string).\n            return serializeFragment(this, true, true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Element;\n}(Node));\nexport default Element;\n/**\n * To create an element, given a document, localName, namespace, and optional prefix, is, and\n * synchronous custom elements flag, run these steps:\n *\n * @param document  The node document for the new element\n * @param localName The local name for the new element\n * @param namespace The namespace URI for the new element, or null for the null namespace\n * @param prefix    The prefix for the new element, or null for no prefix\n *\n * @return The new element\n */\nexport function createElement(document, localName, namespace, prefix) {\n    // 1. If prefix was not given, let prefix be null.\n    // (handled by default)\n    if (prefix === void 0) { prefix = null; }\n    // 2. If is was not given, let is be null.\n    // (custom elements not implemented)\n    // 3. Let result be null.\n    var result = null;\n    // 4. Let definition be the result of looking up a custom element definition given document,\n    // namespace, localName, and is.\n    // (custom elements not implemented)\n    // 5. If definition is non-null, and definition’s name is not equal to its local name (i.e.,\n    // definition represents a customized built-in element), then:\n    // 5.1. Let interface be the element interface for localName and the HTML namespace.\n    // 5.2. Set result to a new element that implements interface, with no attributes, namespace set\n    // to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom\n    // element state set to \"undefined\", custom element definition set to null, is value set to is,\n    // and node document set to document.\n    // 5.3. If the synchronous custom elements flag is set, upgrade element using definition.\n    // 5.4. Otherwise, enqueue a custom element upgrade reaction given result and definition.\n    // (custom elements not implemented)\n    // 6. Otherwise, if definition is non-null, then:\n    // 6.1. If the synchronous custom elements flag is set, then run these steps while catching any\n    // exceptions:\n    // 6.1.1. Let C be definition’s constructor.\n    // 6.1.2. Set result to the result of constructing C, with no arguments.\n    // 6.1.3. If result does not implement the HTMLElement interface, then throw a TypeError.\n    // This is meant to be a brand check to ensure that the object was allocated by the HTML element\n    // constructor. See webidl #97 about making this more precise.\n    // If this check passes, then result will already have its custom element state and custom\n    // element definition initialized.\n    // 6.1.4. If result’s attribute list is not empty, then throw a NotSupportedError.\n    // 6.1.5. If result has children, then throw a NotSupportedError.\n    // 6.1.6. If result’s parent is not null, then throw a NotSupportedError.\n    // 6.1.7. If result’s node document is not document, then throw a NotSupportedError.\n    // 6.1.8. If result’s namespace is not the HTML namespace, then throw a NotSupportedError.\n    // As of the time of this writing, every element that implements the HTMLElement interface is\n    // also in the HTML namespace, so this check is currently redundant with the above brand check.\n    // However, this is not guaranteed to be true forever in the face of potential specification\n    // changes, such as converging certain SVG and HTML interfaces.\n    // 6.1.9. If result’s local name is not equal to localName, then throw a NotSupportedError.\n    // 6.1.10. Set result’s namespace prefix to prefix.\n    // 6.1.11. Set result’s is value to null.\n    // If any of these steps threw an exception, then:\n    // 6.1.catch.1. Report the exception.\n    // 6.1.catch.2. Set result to a new element that implements the HTMLUnknownElement interface,\n    // with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix,\n    // local name set to localName, custom element state set to \"failed\", custom element definition\n    // set to null, is value set to null, and node document set to document.\n    // 6.2. Otherwise:\n    // 6.2.1. Set result to a new element that implements the HTMLElement interface, with no\n    // attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name\n    // set to localName, custom element state set to \"undefined\", custom element definition set to\n    // null, is value set to null, and node document set to document.\n    // 6.2.2. Enqueue a custom element upgrade reaction given result and definition.\n    // (custom elements not implemented)\n    // 7. Otherwise:\n    // 7.1. Let interface be the element interface for localName and namespace.\n    // (interfaces other than Element not implemented)\n    // 7.2. Set result to a new element that implements interface, with no attributes, namespace set\n    // to namespace, namespace prefix set to prefix, local name set to localName, custom element\n    // state set to \"uncustomized\", custom element definition set to null, is value set to is, and\n    // node document set to document.\n    var context = getContext(document);\n    result = new context.Element(namespace, prefix, localName);\n    result.ownerDocument = document;\n    // If namespace is the HTML namespace, and either localName is a valid custom element name or is\n    // is non-null, then set result’s custom element state to \"undefined\".\n    // (custom elements not implemented)\n    // Return result.\n    return result;\n}\n/**\n * To get an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName The qualified name of the attribute to get\n * @param element       The element to get the attribute on\n *\n * @return The first matching attribute, or null otherwise\n */\nfunction getAttributeByName(qualifiedName, element) {\n    // 1. If element is in the HTML namespace and its node document is an HTML document, then set\n    // qualifiedName to qualifiedName in ASCII lowercase.\n    // (html documents not implemented)\n    // 2. Return the first attribute in element’s attribute list whose qualified name is\n    // qualifiedName, and null otherwise.\n    return element.attributes.find(function (attr) { return attr.name === qualifiedName; }) || null;\n}\n/**\n * To get an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace Namespace for the attribute\n * @param localName Local name for the attribute\n * @param element   The element to get the attribute on\n *\n * @return The first matching attribute, or null otherwise\n */\nfunction getAttributeByNamespaceAndLocalName(namespace, localName, element) {\n    // 1. If namespace is the empty string, set it to null.\n    if (namespace === '') {\n        namespace = null;\n    }\n    // 2. Return the attribute in element’s attribute list whose namespace is namespace and local\n    // name is localName, if any, and null otherwise.\n    return (element.attributes.find(function (attr) { return attr.namespaceURI === namespace && attr.localName === localName; }) || null);\n}\n/**\n * To set an attribute given an attr and element, run these steps:\n *\n * @param attr    The new attribute to set\n * @param element The element to set attr on\n *\n * @return The previous attribute with attr's namespace and local name, or null if there was no such\n *         attribute\n */\nfunction setAttribute(attr, element) {\n    // 1. If attr’s element is neither null nor element, throw an InUseAttributeError.\n    if (attr.ownerElement !== null && attr.ownerElement !== element) {\n        throwInUseAttributeError('attribute is in use by another element');\n    }\n    // 2. Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local\n    // name, and element.\n    var oldAttr = getAttributeByNamespaceAndLocalName(attr.namespaceURI, attr.localName, element);\n    // 3. If oldAttr is attr, return attr.\n    if (oldAttr === attr) {\n        return attr;\n    }\n    // 4. If oldAttr is non-null, replace it by attr in element.\n    if (oldAttr !== null) {\n        replaceAttribute(oldAttr, attr, element);\n    }\n    else {\n        // 5. Otherwise, append attr to element.\n        appendAttribute(attr, element);\n    }\n    // 6. Return oldAttr.\n    return oldAttr;\n}\n/**\n * To set an attribute value for an element element using a localName and value, and an optional\n * prefix, and namespace, run these steps:\n *\n * @param element   Element to set the attribute value on\n * @param localName Local name of the attribute\n * @param value     New value of the attribute\n * @param prefix    Prefix of the attribute\n * @param namespace Namespace of the attribute\n */\nfunction setAttributeValue(element, localName, value, prefix, namespace) {\n    // 1. If prefix is not given, set it to null.\n    // 2. If namespace is not given, set it to null.\n    // (handled by default values)\n    // 3. Let attribute be the result of getting an attribute given namespace, localName, and\n    // element.\n    var attribute = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n    // 4. If attribute is null, create an attribute whose namespace is namespace, namespace prefix\n    // is prefix, local name is localName, value is value, and node document is element’s node\n    // document, then append this attribute to element, and then return.\n    if (attribute === null) {\n        var context = getContext(element);\n        var attribute_3 = new context.Attr(namespace, prefix, localName, value, element);\n        attribute_3.ownerDocument = element.ownerDocument;\n        appendAttribute(attribute_3, element);\n        return;\n    }\n    // 5. Change attribute from element to value.\n    changeAttribute(attribute, element, value);\n}\n/**\n * To remove an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName Qualified name of the attribute\n * @param element       The element to remove the attribute from\n *\n * @return The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByName(qualifiedName, element) {\n    // 1. Let attr be the result of getting an attribute given qualifiedName and element.\n    var attr = getAttributeByName(qualifiedName, element);\n    // 2. If attr is non-null, remove it from element.\n    if (attr !== null) {\n        removeAttribute(attr, element);\n    }\n    // 3. Return attr.\n    return attr;\n}\n/**\n * To remove an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace The namespace of the attribute\n * @param localName The local name of the attribute\n * @param element   The element to remove the attribute from\n *\n * @return The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByNamespaceAndLocalName(namespace, localName, element) {\n    // 1. Let attr be the result of getting an attribute given namespace, localName, and element.\n    var attr = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n    // 2. If attr is non-null, remove it from element.\n    if (attr !== null) {\n        removeAttribute(attr, element);\n    }\n    // 3. Return attr.\n    return attr;\n}\n//# sourceMappingURL=Element.js.map","import { createElement } from '../Element';\nimport { validateAndExtract } from './namespaceHelpers';\n// 3.5. Interface Document\n/**\n * The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as\n * follows:\n *\n * @param document      The node document for the new element\n * @param namespace     The namespace for the new element\n * @param qualifiedName The qualified name for the new element\n *\n * @return The new element\n */\nexport default function createElementNS(document, namespace, qualifiedName) {\n    // 1. Let namespace, prefix, and localName be the result of passing namespace and qualifiedName\n    // to validate and extract.\n    var _a = validateAndExtract(namespace, qualifiedName), validatedNamespace = _a.namespace, prefix = _a.prefix, localName = _a.localName;\n    // 2. Let is be the value of is member of options, or null if no such member exists.\n    // (custom elements not implemented)\n    // 3. Let element be the result of creating an element given document, localName, namespace,\n    // prefix, is, and with the synchronous custom elements flag set.\n    var element = createElement(document, localName, validatedNamespace, prefix);\n    // 4. If is is non-null, then set an attribute value for element using \"is\" and is.\n    // (custom elements not implemented)\n    // 5. Return element.\n    return element;\n}\n//# sourceMappingURL=createElementNS.js.map","import DocumentType from './DocumentType';\nimport { createElement } from './Element';\nimport { getContext } from './context/Context';\nimport createElementNS from './util/createElementNS';\nimport { expectArity } from './util/errorHelpers';\nimport { HTML_NAMESPACE, validateQualifiedName } from './util/namespaceHelpers';\nimport { asNullableObject, asNullableString, treatNullAsEmptyString } from './util/typeHelpers';\nvar DOMImplementation = /** @class */ (function () {\n    /**\n     * (non-standard) Use Document#implementation to access instances of this class\n     *\n     * @param document The document to associate with this instance\n     */\n    function DOMImplementation(document) {\n        this._document = document;\n    }\n    /**\n     * Returns a doctype, with the given qualifiedName, publicId, and systemId.\n     *\n     * @param qualifiedName Qualified name for the doctype\n     * @param publicId      Public ID for the doctype\n     * @param systemId      System ID for the doctype\n     *\n     * @return The new doctype node\n     */\n    DOMImplementation.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {\n        expectArity(arguments, 3);\n        qualifiedName = String(qualifiedName);\n        publicId = String(publicId);\n        systemId = String(systemId);\n        // 1. Validate qualifiedName.\n        validateQualifiedName(qualifiedName);\n        // 2. Return a new doctype, with qualifiedName as its name, publicId as its public ID, and\n        // systemId as its system ID, and with its node document set to the associated document of\n        // the context object.\n        var context = getContext(this._document);\n        var doctype = new context.DocumentType(qualifiedName, publicId, systemId);\n        doctype.ownerDocument = this._document;\n        return doctype;\n    };\n    /**\n     * Returns an XMLDocument, with a document element whose local name is qualifiedName and whose\n     * namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is\n     * given, as its doctype.\n     *\n     * @param namespace     The namespace for the root element\n     * @param qualifiedName The qualified name for the root element, or empty string to not create a\n     *                      root element\n     * @param doctype       The doctype for the new document, or null to not add a doctype\n     *\n     * @return The new XMLDocument\n     */\n    DOMImplementation.prototype.createDocument = function (namespace, qualifiedName, doctype) {\n        if (doctype === void 0) { doctype = null; }\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        // [TreatNullAs=EmptyString] for qualifiedName\n        qualifiedName = treatNullAsEmptyString(qualifiedName);\n        doctype = asNullableObject(doctype, DocumentType);\n        // 1. Let document be a new XMLDocument.\n        var context = getContext(this._document);\n        var document = new context.XMLDocument();\n        // 2. Let element be null.\n        var element = null;\n        // 3. If qualifiedName is not the empty string, then set element to the result of running\n        // the internal createElementNS steps, given document, namespace, qualifiedName, and an\n        // empty dictionary.\n        if (qualifiedName !== '') {\n            element = createElementNS(document, namespace, qualifiedName);\n        }\n        // 4. If doctype is non-null, append doctype to document.\n        if (doctype) {\n            document.appendChild(doctype);\n        }\n        // 5. If element is non-null, append element to document.\n        if (element) {\n            document.appendChild(element);\n        }\n        // 6. document’s origin is context object’s associated document’s origin.\n        // (origin not implemented)\n        // 7. document’s content type is determined by namespace:\n        // HTML namespace: application/xhtml+xml\n        // SVG namespace: image/svg+xml\n        // Any other namespace: application/xml\n        // (content type not implemented)\n        // 8. Return document.\n        return document;\n    };\n    /**\n     * Returns a HTML document with a basic tree already constructed.\n     *\n     * @param title Optional title for the new HTML document\n     *\n     * @return The new document\n     */\n    DOMImplementation.prototype.createHTMLDocument = function (title) {\n        title = asNullableString(title);\n        // 1. Let doc be a new document that is an HTML document.\n        var context = getContext(this._document);\n        var doc = new context.Document();\n        // 2. Set doc’s content type to \"text/html\".\n        // (content type not implemented)\n        // 3. Append a new doctype, with \"html\" as its name and with its node document set to doc,\n        // to doc.\n        var doctype = new context.DocumentType('html');\n        doctype.ownerDocument = doc;\n        doc.appendChild(doctype);\n        // 4. Append the result of creating an element given doc, html, and the HTML namespace, to\n        // doc.\n        var htmlElement = createElement(doc, 'html', HTML_NAMESPACE);\n        doc.appendChild(htmlElement);\n        // 5. Append the result of creating an element given doc, head, and the HTML namespace, to\n        // the html element created earlier.\n        var headElement = createElement(doc, 'head', HTML_NAMESPACE);\n        htmlElement.appendChild(headElement);\n        // 6. If title is given:\n        if (title !== null) {\n            // 6.1. Append the result of creating an element given doc, title, and the HTML\n            // namespace, to the head element created earlier.\n            var titleElement = createElement(doc, 'title', HTML_NAMESPACE);\n            headElement.appendChild(titleElement);\n            // 6.2. Append a new Text node, with its data set to title (which could be the empty\n            // string) and its node document set to doc, to the title element created earlier.\n            titleElement.appendChild(doc.createTextNode(title));\n        }\n        // 7. Append the result of creating an element given doc, body, and the HTML namespace, to\n        // the html element created earlier.\n        htmlElement.appendChild(createElement(doc, 'body', HTML_NAMESPACE));\n        // 8. doc’s origin is context object’s associated document’s origin.\n        // (origin not implemented)\n        // 9. Return doc.\n        return doc;\n    };\n    return DOMImplementation;\n}());\nexport default DOMImplementation;\n//# sourceMappingURL=DOMImplementation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getChildren } from './mixins';\nimport DOMImplementation from './DOMImplementation';\nimport { createElement } from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport cloneNode from './util/cloneNode';\nimport createElementNS from './util/createElementNS';\nimport { expectArity, throwInvalidCharacterError, throwNotSupportedError } from './util/errorHelpers';\nimport { adoptNode } from './util/mutationAlgorithms';\nimport { isNodeOfType } from './util/NodeType';\nimport { matchesNameProduction, validateAndExtract } from './util/namespaceHelpers';\nimport { asNullableString, asObject } from './util/typeHelpers';\n/**\n * 3.5. Interface Document\n */\nvar Document = /** @class */ (function (_super) {\n    __extends(Document, _super);\n    /**\n     * Creates a new Document.\n     *\n     * Note: Unlike DOMImplementation#createDocument(), this constructor does not return an\n     * XMLDocument object, but a document (Document object).\n     */\n    function Document() {\n        var _this = _super.call(this) || this;\n        _this.firstElementChild = null;\n        _this.lastElementChild = null;\n        _this.childElementCount = 0;\n        // Document\n        /**\n         * Returns a reference to the DOMImplementation object associated with the document.\n         */\n        _this.implementation = new DOMImplementation(_this);\n        /**\n         * The doctype, or null if there is none.\n         */\n        _this.doctype = null;\n        /**\n         * The document element, or null if there is none.\n         */\n        _this.documentElement = null;\n        return _this;\n    }\n    Object.defineProperty(Document.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 9 /* DOCUMENT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Document.prototype, \"nodeName\", {\n        get: function () {\n            return '#document';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Document.prototype, \"nodeValue\", {\n        get: function () {\n            return null;\n        },\n        set: function (newValue) {\n            // Do nothing.\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Document.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to recursion)\n        // 2. Switch on the context object:\n        // Document - Return the result of locating a namespace prefix for its document element, if\n        // its document element is non-null, and null otherwise.\n        if (this.documentElement !== null) {\n            return this.documentElement.lookupPrefix(namespace);\n        }\n        return null;\n    };\n    Document.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to recursion)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: Document\n        // 1. If its document element is null, then return null.\n        if (this.documentElement === null) {\n            return null;\n        }\n        // 2. Return the result of running locate a namespace on its document element using prefix.\n        return this.documentElement.lookupNamespaceURI(prefix);\n    };\n    Object.defineProperty(Document.prototype, \"children\", {\n        // ParentNode\n        get: function () {\n            return getChildren(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a new element in the null namespace.\n     *\n     * @param localName Local name of the element\n     *\n     * @return The new element\n     */\n    Document.prototype.createElement = function (localName) {\n        expectArity(arguments, 1);\n        localName = String(localName);\n        // 1. If localName does not match the Name production, then throw an InvalidCharacterError.\n        if (!matchesNameProduction(localName)) {\n            throwInvalidCharacterError('The local name is not a valid Name');\n        }\n        // 2. If the context object is an HTML document, then set localName to localName in ASCII\n        // lowercase.\n        // (html documents not implemented)\n        // 3. Let is be the value of is member of options, or null if no such member exists.\n        // (custom elements not implemented)\n        // 4. Let namespace be the HTML namespace, if the context object is an HTML document or\n        // context object’s content type is \"application/xhtml+xml\", and null otherwise.\n        // (html documents not implemented)\n        var namespace = null;\n        // 5. Let element be the result of creating an element given the context object, localName,\n        // namespace, null, is, and with the synchronous custom elements flag set.\n        var element = createElement(this, localName, namespace, null);\n        // 6. If is is non-null, then set an attribute value for element using \"is\" and is.\n        // (custom elements not implemented)\n        // 7. Return element.\n        return element;\n    };\n    /**\n     * Creates a new element in the given namespace.\n     *\n     * @param namespace     Namespace URI for the new element\n     * @param qualifiedName Qualified name for the new element\n     *\n     * @return The new element\n     */\n    Document.prototype.createElementNS = function (namespace, qualifiedName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        qualifiedName = String(qualifiedName);\n        // return the result of running the internal createElementNS steps, given context object,\n        // namespace, qualifiedName, and options.\n        return createElementNS(this, namespace, qualifiedName);\n    };\n    /**\n     * Returns a new DocumentFragment node with its node document set to the context object.\n     *\n     * @return The new document fragment\n     */\n    Document.prototype.createDocumentFragment = function () {\n        var context = getContext(this);\n        var documentFragment = new context.DocumentFragment();\n        documentFragment.ownerDocument = this;\n        return documentFragment;\n    };\n    /**\n     * Returns a new Text node with its data set to data and node document set to the context\n     * object.\n     *\n     * @param data Data for the new text node\n     *\n     * @return The new text node\n     */\n    Document.prototype.createTextNode = function (data) {\n        expectArity(arguments, 1);\n        data = String(data);\n        var context = getContext(this);\n        var text = new context.Text(data);\n        text.ownerDocument = this;\n        return text;\n    };\n    /**\n     * Returns a new CDATA section with the given data and node document set to the context object.\n     *\n     * @param data Data for the new CDATA section\n     *\n     * @return The new CDATA section\n     */\n    Document.prototype.createCDATASection = function (data) {\n        expectArity(arguments, 1);\n        data = String(data);\n        // 1. If context object is an HTML document, then throw a NotSupportedError.\n        // (html documents not implemented)\n        // 2. If data contains the string \"]]>\", then throw an InvalidCharacterError.\n        if (data.indexOf(']]>') >= 0) {\n            throwInvalidCharacterError('Data must not contain the string \"]]>\"');\n        }\n        // 3. Return a new CDATASection node with its data set to data and node document set to the\n        // context object.\n        var context = getContext(this);\n        var cdataSection = new context.CDATASection(data);\n        cdataSection.ownerDocument = this;\n        return cdataSection;\n    };\n    /**\n     * Returns a new Comment node with its data set to data and node document set to the context\n     * object.\n     *\n     * @param data Data for the new comment\n     *\n     * @return The new comment node\n     */\n    Document.prototype.createComment = function (data) {\n        expectArity(arguments, 1);\n        data = String(data);\n        var context = getContext(this);\n        var comment = new context.Comment(data);\n        comment.ownerDocument = this;\n        return comment;\n    };\n    /**\n     * Creates a new processing instruction node, with target set to target, data set to data, and\n     * node document set to the context object.\n     *\n     * @param target Target for the new processing instruction\n     * @param data   Data for the new processing instruction\n     *\n     * @return The new processing instruction\n     */\n    Document.prototype.createProcessingInstruction = function (target, data) {\n        expectArity(arguments, 2);\n        target = String(target);\n        data = String(data);\n        // 1. If target does not match the Name production, then throw an InvalidCharacterError.\n        if (!matchesNameProduction(target)) {\n            throwInvalidCharacterError('The target is not a valid Name');\n        }\n        // 2. If data contains the string \"?>\", then throw an InvalidCharacterError.\n        if (data.indexOf('?>') >= 0) {\n            throwInvalidCharacterError('Data must not contain the string \"?>\"');\n        }\n        // 3. Return a new ProcessingInstruction node, with target set to target, data set to data,\n        // and node document set to the context object.\n        var context = getContext(this);\n        var pi = new context.ProcessingInstruction(target, data);\n        pi.ownerDocument = this;\n        return pi;\n        // Note: No check is performed that target contains \"xml\" or \":\", or that data contains\n        // characters that match the Char production.\n    };\n    /**\n     * Creates a copy of a node from an external document that can be inserted into the current\n     * document.\n     *\n     * @param node The node to import\n     * @param deep Whether to also import node's children\n     */\n    Document.prototype.importNode = function (node, deep) {\n        if (deep === void 0) { deep = false; }\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. If node is a document or shadow root, then throw a NotSupportedError.\n        if (isNodeOfType(node, 9 /* DOCUMENT_NODE */)) {\n            throwNotSupportedError('importing a Document node is not supported');\n        }\n        // 2. Return a clone of node, with context object and the clone children flag set if deep is\n        // true.\n        return cloneNode(node, deep, this);\n    };\n    /**\n     * Adopts a node. The node and its subtree is removed from the document it's in (if any), and\n     * its ownerDocument is changed to the current document. The node can then be inserted into the\n     * current document.\n     *\n     * @param node The node to adopt\n     */\n    Document.prototype.adoptNode = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. If node is a document, then throw a NotSupportedError.\n        if (isNodeOfType(node, 9 /* DOCUMENT_NODE */)) {\n            throwNotSupportedError('adopting a Document node is not supported');\n        }\n        // 2. If node is a shadow root, then throw a HierarchyRequestError.\n        // (shadow dom not implemented)\n        // 3. Adopt node into the context object.\n        adoptNode(node, this);\n        // 4. Return node.\n        return node;\n    };\n    /**\n     * Creates a new attribute node with the null namespace and given local name.\n     *\n     * @param localName The local name of the attribute\n     *\n     * @return The new attribute node\n     */\n    Document.prototype.createAttribute = function (localName) {\n        expectArity(arguments, 1);\n        localName = String(localName);\n        // 1. If localName does not match the Name production in XML, then throw an\n        // InvalidCharacterError.\n        if (!matchesNameProduction(localName)) {\n            throwInvalidCharacterError('The local name is not a valid Name');\n        }\n        // 2. If the context object is an HTML document, then set localName to localName in ASCII\n        // lowercase.\n        // (html documents not implemented)\n        // 3. Return a new attribute whose local name is localName and node document is context\n        // object.\n        var context = getContext(this);\n        var attr = new context.Attr(null, null, localName, '', null);\n        attr.ownerDocument = this;\n        return attr;\n    };\n    /**\n     * Creates a new attribute node with the given namespace and qualified name.\n     *\n     * @param namespace     Namespace URI for the new attribute, or null for the null namespace\n     * @param qualifiedName Qualified name for the new attribute\n     *\n     * @return The new attribute node\n     */\n    Document.prototype.createAttributeNS = function (namespace, qualifiedName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        qualifiedName = String(qualifiedName);\n        // 1. Let namespace, prefix, and localName be the result of passing namespace and\n        // qualifiedName to validate and extract.\n        var _a = validateAndExtract(namespace, qualifiedName), validatedNamespace = _a.namespace, prefix = _a.prefix, localName = _a.localName;\n        // 2. Return a new attribute whose namespace is namespace, namespace prefix is prefix, local\n        // name is localName, and node document is context object.\n        var context = getContext(this);\n        var attr = new context.Attr(validatedNamespace, prefix, localName, '', null);\n        attr.ownerDocument = this;\n        return attr;\n    };\n    /**\n     * Creates a new live Range, initially positioned at the root of this document.\n     *\n     * @return The new Range\n     */\n    Document.prototype.createRange = function () {\n        var context = getContext(this);\n        var range = new context.Range();\n        range.startContainer = this;\n        range.startOffset = 0;\n        range.endContainer = this;\n        range.endOffset = 0;\n        return range;\n    };\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    Document.prototype._copy = function (document) {\n        // Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n        // (properties not implemented)\n        var context = getContext(document);\n        return new context.Document();\n    };\n    return Document;\n}(Node));\nexport default Document;\n//# sourceMappingURL=Document.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getChildren } from './mixins';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nvar DocumentFragment = /** @class */ (function (_super) {\n    __extends(DocumentFragment, _super);\n    /**\n     * Return a new DocumentFragment node whose node document is current global object’s associated\n     * Document.\n     */\n    function DocumentFragment() {\n        var _this = _super.call(this) || this;\n        _this.firstElementChild = null;\n        _this.lastElementChild = null;\n        _this.childElementCount = 0;\n        var context = getContext(_this);\n        _this.ownerDocument = context.document;\n        return _this;\n    }\n    Object.defineProperty(DocumentFragment.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 11 /* DOCUMENT_FRAGMENT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentFragment.prototype, \"nodeName\", {\n        get: function () {\n            return '#document-fragment';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentFragment.prototype, \"nodeValue\", {\n        get: function () {\n            return null;\n        },\n        set: function (newValue) {\n            // Do nothing.\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentFragment.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to return value)\n        // 2. Switch on the context object:\n        // DocumentFragment - Return null\n        return null;\n    };\n    DocumentFragment.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to return value)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: DocumentFragment\n        // Return null.\n        return null;\n    };\n    Object.defineProperty(DocumentFragment.prototype, \"children\", {\n        // ParentNode\n        get: function () {\n            return getChildren(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    DocumentFragment.prototype._copy = function (document) {\n        var context = getContext(document);\n        var copy = new context.DocumentFragment();\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return DocumentFragment;\n}(Node));\nexport default DocumentFragment;\n//# sourceMappingURL=DocumentFragment.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport CharacterData from './CharacterData';\nimport { getContext } from './context/Context';\n/**\n * 3.13. Interface ProcessingInstruction\n */\nvar ProcessingInstruction = /** @class */ (function (_super) {\n    __extends(ProcessingInstruction, _super);\n    /**\n     * (non-standard) Use Document#createProcessingInstruction to create a processing instruction.\n     *\n     * @param target The target of the processing instruction\n     * @param data   The data of the processing instruction\n     */\n    function ProcessingInstruction(target, data) {\n        var _this = _super.call(this, data) || this;\n        _this.target = target;\n        return _this;\n    }\n    Object.defineProperty(ProcessingInstruction.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 7 /* PROCESSING_INSTRUCTION_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProcessingInstruction.prototype, \"nodeName\", {\n        get: function () {\n            return this.target;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    ProcessingInstruction.prototype._copy = function (document) {\n        // Set copy’s target and data to those of node.\n        var context = getContext(document);\n        var copy = new context.ProcessingInstruction(this.target, this.data);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return ProcessingInstruction;\n}(CharacterData));\nexport default ProcessingInstruction;\n//# sourceMappingURL=ProcessingInstruction.js.map","import Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity, throwIndexSizeError, throwInvalidNodeTypeError, throwNotSupportedError, throwWrongDocumentError } from './util/errorHelpers';\nimport { isNodeOfType } from './util/NodeType';\nimport { determineLengthOfNode, getInclusiveAncestors, getNodeIndex, getRootOfNode } from './util/treeHelpers';\nimport { asObject, asUnsignedLong } from './util/typeHelpers';\n/**\n * A range is collapsed if its start node is its end node and its start offset is its end offset.\n *\n * @param range\n */\nfunction isCollapsed(range) {\n    return range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n}\n/**\n * Interface Range\n *\n * Objects implementing the Range interface are known as live ranges.\n */\nvar Range = /** @class */ (function () {\n    /**\n     * The Range() constructor, when invoked, must return a new live range with (current global\n     * object’s associated Document, 0) as its start and end.\n     */\n    function Range() {\n        var context = getContext(this);\n        this.startContainer = context.document;\n        this.startOffset = 0;\n        this.endContainer = context.document;\n        this.endOffset = 0;\n        context._ranges.push(this);\n    }\n    Object.defineProperty(Range.prototype, \"collapsed\", {\n        get: function () {\n            return isCollapsed(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Range.prototype, \"commonAncestorContainer\", {\n        /**\n         * Get the common ancestor of the range's boundary position nodes.\n         *\n         * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n         */\n        get: function () {\n            var ancestors1 = getInclusiveAncestors(this.startContainer);\n            var ancestors2 = getInclusiveAncestors(this.endContainer);\n            var commonAncestorContainer = ancestors1[0];\n            var i = 0;\n            while (i < ancestors1.length && i < ancestors2.length) {\n                if (ancestors1[i] !== ancestors2[i]) {\n                    break;\n                }\n                commonAncestorContainer = ancestors1[i];\n                ++i;\n            }\n            return commonAncestorContainer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the start boundary point of the range.\n     *\n     * @param node   The new start container\n     * @param offset The new start offset\n     */\n    Range.prototype.setStart = function (node, offset) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        offset = asUnsignedLong(offset);\n        // 1. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Can not set a range under a doctype node');\n        }\n        // 2. If offset is greater than node’s length, then throw an IndexSizeError.\n        if (offset > determineLengthOfNode(node)) {\n            throwIndexSizeError('Can not set a range past the end of the node');\n        }\n        // 3. Let bp be the boundary point (node, offset).\n        // 4.a. If these steps were invoked as \"set the start\"\n        // 4.a.1. If bp is after the range’s end, or if range’s root is not equal to node’s root,\n        // set range’s end to bp.\n        var rootOfNode = getRootOfNode(node);\n        var rootOfRange = getRootOfRange(this);\n        if (rootOfNode !== rootOfRange ||\n            compareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n                POSITION_AFTER) {\n            this.endContainer = node;\n            this.endOffset = offset;\n        }\n        // 4.a.2. Set range’s start to bp.\n        this.startContainer = node;\n        this.startOffset = offset;\n        // 4.b. If these steps were invoked as \"set the end\"\n        // 4.b.1. If bp is before the range’s start, or if range’s root is not equal to node’s root,\n        // set range’s start to bp.\n        // 4.b.2. Set range’s end to bp.\n        // (see Range#setEnd for this branch)\n    };\n    /**\n     * Sets the end boundary point of the range.\n     *\n     * @param node   The new end container\n     * @param offset The new end offset\n     */\n    Range.prototype.setEnd = function (node, offset) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        offset = asUnsignedLong(offset);\n        // 1. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Can not set a range under a doctype node');\n        }\n        // 2. If offset is greater than node’s length, then throw an IndexSizeError.\n        if (offset > determineLengthOfNode(node)) {\n            throwIndexSizeError('Can not set a range past the end of the node');\n        }\n        // 3. Let bp be the boundary point (node, offset).\n        // 4.a. If these steps were invoked as \"set the start\"\n        // 4.a.1. If bp is after the range’s end, or if range’s root is not equal to node’s root,\n        // set range’s end to bp.\n        // 4.a.2. Set range’s start to bp.\n        // (see Range#setStart for this branch)\n        // 4.b. If these steps were invoked as \"set the end\"\n        // 4.b.1. If bp is before the range’s start, or if range’s root is not equal to node’s root,\n        // set range’s start to bp.\n        var rootOfNode = getRootOfNode(node);\n        var rootOfRange = getRootOfRange(this);\n        if (rootOfNode !== rootOfRange ||\n            compareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n                POSITION_BEFORE) {\n            this.startContainer = node;\n            this.startOffset = offset;\n        }\n        // 4.b.2. Set range’s end to bp.\n        this.endContainer = node;\n        this.endOffset = offset;\n    };\n    /**\n     * Sets the start boundary point of the range to the position just before the given node.\n     *\n     * @param node The node to set the range's start before\n     */\n    Range.prototype.setStartBefore = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not set range before node without a parent');\n        }\n        // 3. Set the start of the context object to boundary point (parent, node’s index).\n        this.setStart(parent, getNodeIndex(node));\n    };\n    /**\n     * Sets the start boundary point of the range to the position just after the given node.\n     *\n     * @param node The node to set the range's start before\n     */\n    Range.prototype.setStartAfter = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not set range before node without a parent');\n        }\n        // 3. Set the start of the context object to boundary point (parent, node’s index plus one).\n        this.setStart(parent, getNodeIndex(node) + 1);\n    };\n    /**\n     * Sets the end boundary point of the range to the position just before the given node.\n     *\n     * @param node The node to set the range's end before\n     */\n    Range.prototype.setEndBefore = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not set range before node without a parent');\n        }\n        // 3. Set the end of the context object to boundary point (parent, node’s index).\n        this.setEnd(parent, getNodeIndex(node));\n    };\n    /**\n     * Sets the end boundary point of the range to the position just after the given node.\n     *\n     * @param node The node to set the range's end before\n     */\n    Range.prototype.setEndAfter = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not set range before node without a parent');\n        }\n        // 3. Set the end of the context object to boundary point (parent, node’s index plus one).\n        this.setEnd(parent, getNodeIndex(node) + 1);\n    };\n    /**\n     * Sets the range's boundary points to the same position.\n     *\n     * @param toStart If true, set both points to the start of the range, otherwise set them to the\n     *                end\n     */\n    Range.prototype.collapse = function (toStart) {\n        if (toStart === void 0) { toStart = false; }\n        if (toStart) {\n            this.endContainer = this.startContainer;\n            this.endOffset = this.startOffset;\n        }\n        else {\n            this.startContainer = this.endContainer;\n            this.startOffset = this.endOffset;\n        }\n    };\n    Range.prototype.selectNode = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not select node with null parent');\n        }\n        // 3. Let index be node’s index.\n        var index = getNodeIndex(node);\n        // 4. Set range’s start to boundary point (parent, index).\n        this.startContainer = parent;\n        this.startOffset = index;\n        // 5. Set range’s end to boundary point (parent, index plus one).\n        this.endContainer = parent;\n        this.endOffset = index + 1;\n    };\n    Range.prototype.selectNodeContents = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Can not place range inside a doctype node');\n        }\n        // 2. Let length be the length of node.\n        var length = determineLengthOfNode(node);\n        // 3. Set start to the boundary point (node, 0).\n        this.startContainer = node;\n        this.startOffset = 0;\n        // 4. Set end to the boundary point (node, length).\n        this.endContainer = node;\n        this.endOffset = length;\n    };\n    Range.prototype.compareBoundaryPoints = function (how, sourceRange) {\n        expectArity(arguments, 2);\n        sourceRange = asObject(sourceRange, Range);\n        // 1. If how is not one of START_TO_START, START_TO_END, END_TO_END, and END_TO_START, then\n        // throw a NotSupportedError.\n        if (how !== Range.START_TO_START &&\n            how !== Range.START_TO_END &&\n            how !== Range.END_TO_END &&\n            how !== Range.END_TO_START) {\n            throwNotSupportedError('Unsupported comparison type');\n        }\n        // 2. If context object’s root is not the same as sourceRange’s root, then throw a\n        // WrongDocumentError.\n        if (getRootOfRange(this) !== getRootOfRange(sourceRange)) {\n            throwWrongDocumentError('Can not compare positions of ranges in different trees');\n        }\n        // 3. If how is:\n        switch (how) {\n            // START_TO_START:\n            case Range.START_TO_START:\n                // Let this point be the context object’s start. Let other point be sourceRange’s\n                // start.\n                return compareBoundaryPointPositions(\n                // this point\n                this.startContainer, this.startOffset, \n                // other point\n                sourceRange.startContainer, sourceRange.startOffset);\n            // START_TO_END:\n            case Range.START_TO_END:\n                // Let this point be the context object’s end. Let other point be sourceRange’s\n                // start.\n                return compareBoundaryPointPositions(\n                // this point\n                this.endContainer, this.endOffset, \n                // other point\n                sourceRange.startContainer, sourceRange.startOffset);\n            // END_TO_END:\n            case Range.END_TO_END:\n                // Let this point be the context object’s end. Let other point be sourceRange’s end.\n                return compareBoundaryPointPositions(\n                // this point\n                this.endContainer, this.endOffset, \n                // other point\n                sourceRange.endContainer, sourceRange.endOffset);\n            // END_TO_START:\n            default:\n                // Let this point be the context object’s start. Let other point be sourceRange’s\n                // end.\n                return compareBoundaryPointPositions(\n                // this point\n                this.startContainer, this.startOffset, \n                // other point,\n                sourceRange.endContainer, sourceRange.endOffset);\n        }\n        // 4. If the position of this point relative to other point is\n        // before: Return −1.\n        // equal: Return 0.\n        // after: Return 1.\n        // (handled in switch above)\n    };\n    /**\n     * Returns a range with the same start and end as the context object.\n     *\n     * @return A copy of the context object\n     */\n    Range.prototype.cloneRange = function () {\n        var context = getContext(this);\n        var range = new context.Range();\n        range.startContainer = this.startContainer;\n        range.startOffset = this.startOffset;\n        range.endContainer = this.endContainer;\n        range.endOffset = this.endOffset;\n        return range;\n    };\n    /**\n     * Stops tracking the range.\n     *\n     * (non-standard) According to the spec, this method must do nothing. However, as it is not\n     * possible to rely on garbage collection to determine when to stop updating a range for node\n     * mutations, this implementation requires calling detach to stop such updates from affecting\n     * the range.\n     */\n    Range.prototype.detach = function () {\n        var context = getContext(this);\n        var index = context._ranges.indexOf(this);\n        if (index >= 0) {\n            context._ranges.splice(index, 1);\n        }\n    };\n    /**\n     * Returns true if the given point is after or equal to the start point and before or equal to\n     * the end point of the context object.\n     *\n     * @param node   Node of point to check\n     * @param offset Offset of point to check\n     *\n     * @return Whether the point is in the range\n     */\n    Range.prototype.isPointInRange = function (node, offset) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        offset = asUnsignedLong(offset);\n        // 1. If node’s root is different from the context object’s root, return false.\n        if (getRootOfNode(node) !== getRootOfRange(this)) {\n            return false;\n        }\n        // 2. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Point can not be under a doctype');\n        }\n        // 3. If offset is greater than node’s length, then throw an IndexSizeError.\n        if (offset > determineLengthOfNode(node)) {\n            throwIndexSizeError('Offset should not be past the end of node');\n        }\n        // 4. If (node, offset) is before start or after end, return false.\n        if (compareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n            POSITION_BEFORE ||\n            compareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n                POSITION_AFTER) {\n            return false;\n        }\n        // 5. Return true.\n        return true;\n    };\n    /**\n     * Compares the given point to the range's boundary points.\n     *\n     * @param node   Node of point to check\n     * @param offset Offset of point to check\n     *\n     * @return -1, 0 or 1 depending on whether the point is before, inside or after the range,\n     *         respectively\n     */\n    Range.prototype.comparePoint = function (node, offset) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        offset = asUnsignedLong(offset);\n        // 1. If node’s root is different from the context object’s root, then throw a\n        // WrongDocumentError.\n        if (getRootOfNode(node) !== getRootOfRange(this)) {\n            throwWrongDocumentError('Can not compare point to range in different trees');\n        }\n        // 2. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Point can not be under a doctype');\n        }\n        // 3. If offset is greater than node’s length, then throw an IndexSizeError.\n        if (offset > determineLengthOfNode(node)) {\n            throwIndexSizeError('Offset should not be past the end of node');\n        }\n        // 4. If (node, offset) is before start, return −1.\n        if (compareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n            POSITION_BEFORE) {\n            return -1;\n        }\n        // 5. If (node, offset) is after end, return 1.\n        if (compareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n            POSITION_AFTER) {\n            return 1;\n        }\n        // 6. Return 0.\n        return 0;\n    };\n    /**\n     * Returns true if range overlaps the range from before node to after node.\n     *\n     * @param node The node to check\n     *\n     * @return Whether the range intersects node\n     */\n    Range.prototype.intersectsNode = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. If node’s root is different from the context object’s root, return false.\n        if (getRootOfNode(node) !== getRootOfRange(this)) {\n            return false;\n        }\n        // 2. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 3. If parent is null, return true.\n        if (parent === null) {\n            return true;\n        }\n        // 4. Let offset be node’s index.\n        var offset = getNodeIndex(node);\n        // 5. If (parent, offset) is before end and (parent, offset + 1) is after start, return\n        // true.\n        // 6. Return false.\n        return (compareBoundaryPointPositions(parent, offset, this.endContainer, this.endOffset) ===\n            POSITION_BEFORE &&\n            compareBoundaryPointPositions(parent, offset + 1, this.startContainer, this.startOffset) === POSITION_AFTER);\n    };\n    Range.START_TO_START = 0;\n    Range.START_TO_END = 1;\n    Range.END_TO_END = 2;\n    Range.END_TO_START = 3;\n    return Range;\n}());\nexport default Range;\nvar POSITION_BEFORE = -1;\nvar POSITION_EQUAL = 0;\nvar POSITION_AFTER = 1;\n/**\n * If the two nodes of boundary points (node A, offset A) and (node B, offset B) have the same root,\n * the position of the first relative to the second is either before, equal, or after.\n *\n * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n *\n * This implementation assumes it is called on nodes under the same root.\n *\n * @param nodeA   First boundary point's node\n * @param offsetA First boundary point's offset\n * @param nodeB   Second boundary point's node\n * @param offsetB Second boundary point's offset\n *\n * @return -1, 0 or 1, depending on the boundary points' relative positions\n */\nfunction compareBoundaryPointPositions(nodeA, offsetA, nodeB, offsetB) {\n    if (nodeA !== nodeB) {\n        var ancestors1 = getInclusiveAncestors(nodeA);\n        var ancestors2 = getInclusiveAncestors(nodeB);\n        // Skip common parents\n        while (ancestors1[0] && ancestors2[0] && ancestors1[0] === ancestors2[0]) {\n            ancestors1.shift();\n            ancestors2.shift();\n        }\n        // Compute offsets at the level under the last common parent. Add 0.5 to bias positions\n        // inside the parent vs. those before or after.\n        if (ancestors1.length) {\n            offsetA = getNodeIndex(ancestors1[0]) + 0.5;\n        }\n        if (ancestors2.length) {\n            offsetB = getNodeIndex(ancestors2[0]) + 0.5;\n        }\n    }\n    // Compare positions at this level\n    if (offsetA === offsetB) {\n        return POSITION_EQUAL;\n    }\n    return offsetA < offsetB ? POSITION_BEFORE : POSITION_AFTER;\n}\n/**\n * The root of a range is the root of its start node.\n *\n * @param range The range to get the root of\n *\n * @return The root of range\n */\nfunction getRootOfRange(range) {\n    return getRootOfNode(range.startContainer);\n}\n//# sourceMappingURL=Range.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Document from './Document';\nimport { getContext } from './context/Context';\nvar XMLDocument = /** @class */ (function (_super) {\n    __extends(XMLDocument, _super);\n    function XMLDocument() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    XMLDocument.prototype._copy = function (document) {\n        // Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n        // (properties not implemented)\n        var context = getContext(document);\n        return new context.XMLDocument();\n    };\n    return XMLDocument;\n}(Document));\nexport default XMLDocument;\n//# sourceMappingURL=XMLDocument.js.map","import Node from '../Node';\nimport { asObject } from '../util/typeHelpers';\nimport { produceXmlSerialization } from './serializationAlgorithms';\nvar XMLSerializer = /** @class */ (function () {\n    /**\n     * Constructs a new XMLSerializer object.\n     */\n    function XMLSerializer() {\n    }\n    /**\n     * Serializes root into a string using an XML serialization. Throws a TypeError exception if\n     * root is not a Node.\n     *\n     * @param root The node to serialize\n     *\n     * @return The XML resulting from serialization\n     */\n    XMLSerializer.prototype.serializeToString = function (root) {\n        root = asObject(root, Node);\n        // Produce an XML serialization of root passing a value of false for the require well-formed\n        // parameter, and return the result.\n        var result = [];\n        produceXmlSerialization(root, false, result);\n        return result.join('');\n    };\n    return XMLSerializer;\n}());\nexport default XMLSerializer;\n/**\n * Serializes root into a string using an XML serialization. Throws if the result would not be\n * well-formed XML.\n *\n * Non-standard: the dom-parsing spec does not provide a way to serialize arbitrary nodes while\n * enforcing well-formedness.\n *\n * @param root The node to serialize\n *\n * @return The XML resulting from serialization\n */\nexport function serializeToWellFormedString(root) {\n    root = asObject(root, Node);\n    // Produce an XML serialization of root passing a value of false for the require well-formed\n    // parameter, and return the result.\n    var result = [];\n    produceXmlSerialization(root, true, result);\n    return result.join('');\n}\n//# sourceMappingURL=XMLSerializer.js.map","import Node from '../Node';\nimport { expectArity } from '../util/errorHelpers';\nimport { asObject } from '../util/typeHelpers';\n/**\n * 3.3.1. Interface MutationObserver\n *\n * A MutationObserver object can be used to observe mutations to the tree of nodes.\n */\nvar MutationObserver = /** @class */ (function () {\n    /**\n     * Constructs a MutationObserver object and sets its callback to callback. The callback is\n     * invoked with a list of MutationRecord objects as first argument and the constructed\n     * MutationObserver object as second argument. It is invoked after nodes registered with the\n     * observe() method, are mutated.\n     *\n     * @param callback Function called after mutations have been observed.\n     */\n    function MutationObserver(callback) {\n        /**\n         * The list of nodes on which this observer is a RegisteredObserver's observer.\n         */\n        this._nodes = [];\n        /**\n         * The list of MutationRecord objects collected so far.\n         */\n        this._recordQueue = [];\n        /**\n         * Tracks transient registered observers created for this observer, to simplify their removal.\n         */\n        this._transients = [];\n        expectArity(arguments, 1);\n        callback = asObject(callback, Function);\n        // create a new MutationObserver object with callback set to callback\n        this._callback = callback;\n        // append it to the unit of related similar-origin browsing contexts' list of\n        // MutationObserver objects (for efficiency, this implementation only tracks\n        // MutationObserver objects that have records queued)\n    }\n    /**\n     * Instructs the user agent to observe a given target (a node) and report any mutations based on\n     * the criteria given by options (an object).\n     *\n     * NOTE: Adding an observer to an element is just like addEventListener, if you observe the\n     * element multiple times it does not make a difference. Meaning if you observe element twice,\n     * the observe callback does not fire twice, nor will you have to run disconnect() twice. In\n     * other words, once an element is observed, observing it again with the same will do nothing.\n     * However if the callback object is different it will of course add another observer to it.\n     *\n     * @param target  Node (or root of subtree) to observe\n     * @param options Determines which types of mutations to observe\n     */\n    MutationObserver.prototype.observe = function (target, options) {\n        expectArity(arguments, 2);\n        target = asObject(target, Node);\n        // Defaults from IDL\n        options.childList = !!options.childList;\n        options.subtree = !!options.subtree;\n        // 1. If either options’ attributeOldValue or attributeFilter is present and options’\n        // attributes is omitted, set options’ attributes to true.\n        if (options.attributeOldValue !== undefined && options.attributes === undefined) {\n            options.attributes = true;\n        }\n        // 2. If options’ characterDataOldValue is present and options’ characterData is omitted,\n        // set options’ characterData to true.\n        if (options.characterDataOldValue !== undefined && options.characterData === undefined) {\n            options.characterData = true;\n        }\n        // 3. If none of options’ childList, attributes, and characterData is true, throw a\n        // TypeError.\n        if (!(options.childList || options.attributes || options.characterData)) {\n            throw new TypeError('The options object must set at least one of \"attributes\", \"characterData\", or ' +\n                '\"childList\" to true.');\n        }\n        // 4. If options’ attributeOldValue is true and options’ attributes is false, throw a\n        // TypeError.\n        if (options.attributeOldValue && !options.attributes) {\n            throw new TypeError('The options object may only set \"attributeOldValue\" to true when \"attributes\" ' +\n                'is true or not present.');\n        }\n        // 5. If options’ attributeFilter is present and options’ attributes is false, throw a\n        // TypeError. (attributeFilter not yet implemented)\n        // 6. If options’ characterDataOldValue is true and options’ characterData is false, throw a\n        // TypeError.\n        if (options.characterDataOldValue && !options.characterData) {\n            throw new TypeError('The options object may only set \"characterDataOldValue\" to true when ' +\n                '\"characterData\" is true or not present.');\n        }\n        // 7. For each registered registered of target’s registered observer list, if registered's\n        // observer is the context object:\n        // 7.1. For each node of the context object's node list, remove all transient registered\n        // observers whose source is registered from node's registered observer list.\n        // 7.2. Set registered’s options to options.\n        // 8. Otherwise:\n        // 8.1. Append a new registered observer whose observer is the context object and options is\n        // options to target's registered observer list.\n        // 8.2. Append target to the context object's node list.\n        target._registeredObservers.register(this, options);\n    };\n    /**\n     * Stops the MutationObserver instance from receiving notifications of DOM mutations. Until the\n     * observe() method is used again, observer's callback will not be invoked.\n     */\n    MutationObserver.prototype.disconnect = function () {\n        var _this = this;\n        // 1. For each node of the context object’s node list, remove any registered observer from\n        // node's registered observer list for which the context object is the observer.\n        this._nodes.forEach(function (node) { return node._registeredObservers.removeForObserver(_this); });\n        this._nodes.length = 0;\n        // 2. Empty the context object’s record queue.\n        this._recordQueue.length = 0;\n    };\n    /**\n     * Empties the MutationObserver instance's record queue and returns what was in there.\n     *\n     * @return An Array of MutationRecord objects that were recorded.\n     */\n    MutationObserver.prototype.takeRecords = function () {\n        // 1. Let records be a clone of the context object's record queue.\n        var records = this._recordQueue.concat();\n        // 2. Empty the context object's record queue\n        this._recordQueue.length = 0;\n        // 3. Return records\n        return records;\n    };\n    return MutationObserver;\n}());\nexport default MutationObserver;\n//# sourceMappingURL=MutationObserver.js.map","import Attr from './Attr';\n/**\n * Create an Attr node without the usual validation of the given names.\n *\n * @param namespace\n * @param prefix\n * @param localName\n * @param value\n * @param element\n */\nexport function unsafeCreateAttribute(namespace, prefix, localName, value, ownerElement) {\n    return new Attr(namespace, prefix, localName, value, ownerElement);\n}\nexport { createElement as unsafeCreateElement } from './Element';\nexport { appendAttribute as unsafeAppendAttribute } from './util/attrMutations';\n//# sourceMappingURL=unsafe.js.map","export { default as Attr } from './Attr';\nexport { default as CDATASection } from './CDATASection';\nexport { default as CharacterData } from './CharacterData';\nexport { default as Comment } from './Comment';\nexport { default as Document } from './Document';\nexport { default as DocumentFragment } from './DocumentFragment';\nexport { default as DocumentType } from './DocumentType';\nexport { default as DOMImplementation } from './DOMImplementation';\nexport { default as Element } from './Element';\nexport { default as Node } from './Node';\nexport { default as ProcessingInstruction } from './ProcessingInstruction';\nexport { default as Range } from './Range';\nexport { default as Text } from './Text';\nexport { default as XMLDocument } from './XMLDocument';\nexport { default as XMLSerializer } from './dom-parsing/XMLSerializer';\nexport { default as MutationObserver } from './mutation-observer/MutationObserver';\nexport { default as MutationRecord } from './mutation-observer/MutationRecord';\n// Standard DOM does not expose a way to serialize arbitrary nodes as well-formed XML\nexport { serializeToWellFormedString } from './dom-parsing/XMLSerializer';\n// Unsafe exports, required for connecting a HTML parser\nexport { unsafeCreateAttribute, unsafeCreateElement, unsafeAppendAttribute } from './unsafe';\n// To avoid cyclic dependencies and enable multiple contexts with their own constructors later,\n// inject all constructors as well as the global document into the default context (i.e., global\n// object) here.\nimport { defaultContext } from './context/Context';\nimport Attr from './Attr';\nimport CDATASection from './CDATASection';\nimport Comment from './Comment';\nimport Document from './Document';\nimport DocumentFragment from './DocumentFragment';\nimport DocumentType from './DocumentType';\nimport DOMImplementation from './DOMImplementation';\nimport Element from './Element';\nimport ProcessingInstruction from './ProcessingInstruction';\nimport Range from './Range';\nimport Text from './Text';\nimport XMLDocument from './XMLDocument';\n// Document to associate with the global object\nexport var document = new Document();\ndefaultContext.document = document;\ndefaultContext.Attr = Attr;\ndefaultContext.CDATASection = CDATASection;\ndefaultContext.Comment = Comment;\ndefaultContext.Document = Document;\ndefaultContext.DocumentFragment = DocumentFragment;\ndefaultContext.DocumentType = DocumentType;\ndefaultContext.DOMImplementation = DOMImplementation;\ndefaultContext.Element = Element;\ndefaultContext.ProcessingInstruction = ProcessingInstruction;\ndefaultContext.Range = Range;\ndefaultContext.Text = Text;\ndefaultContext.XMLDocument = XMLDocument;\n//# sourceMappingURL=index.js.map"],"names":["RegisteredObserver","observer","node","options","source","_transients","push","prototype","collectInterestedObservers","type","target","data","interestedObservers","pairedStrings","subtree","attributes","characterData","childList","index","indexOf","length","attributeOldValue","characterDataOldValue","oldValue","RegisteredObservers","_registeredObservers","_node","register","registeredObservers","hasRegisteredObserverForObserver","forEach","registered","removeTransientRegisteredObserversForSource","_nodes","removeTransientRegisteredObserver","transientRegisteredObserver","splice","removeForObserver","write","read","l","registeredObserver","appendTransientRegisteredObservers","registerTransient","removeTransientRegisteredObserversForObserver","i","queueCompoundMicrotask","callback","thisArg","args","_i","arguments","Promise","resolve","then","apply","NotifyList","_notifyList","_compoundMicrotaskQueued","appendRecord","record","_recordQueue","queueMutationObserverCompoundMicrotask","_this","_notifyMutationObservers","notifyList","concat","mo","queue","takeRecords","_callback","DefaultContext","_ranges","defaultContext","getContext","isNodeOfType","types","some","t","nodeType","determineLengthOfNode","childNodes","getInclusiveAncestors","ancestor","ancestors","unshift","parentNode","getNodeDocument","ownerDocument","getNodeIndex","getRootOfNode","forEachInclusiveDescendant","child","firstChild","nextSibling","cloneNode","cloneChildren","document","copy","_copy","appendChild","expectArity","minArity","TypeError","expectObject","value","Constructor","name","createDOMException","code","message","err","Error","throwHierarchyRequestError","throwIndexSizeError","throwInUseAttributeError","throwInvalidCharacterError","throwInvalidNodeTypeError","throwInvalidStateError","throwNamespaceError","throwNotFoundError","throwNotSupportedError","throwWrongDocumentError","asParentNode","getChildren","elements","firstElementChild","nextElementSibling","asNonDocumentTypeChildNode","getPreviousElementSibling","sibling","previousSibling","getNextElementSibling","insertIntoChildren","parent","referenceChild","lastChild","element","previousElementSibling","siblingNonDocumentTypeChildNode","lastElementChild","childElementCount","parentDocument","documentElement","doctype","removeFromChildren","isElement","MutationRecord","addedNodes","removedNodes","attributeName","attributeNamespace","queueMutationRecord","context","mappedOldValue","namespace","ensurePreInsertionValidity","contains","fragment","Array","from","preInsertNode","adoptNode","insertNode","suppressObservers","isDocumentFragment","count","childIndex_1","range","startContainer","startOffset","endContainer","endOffset","nodes","n","removeNode","appendNode","replaceChildWithNode","preRemoveChild","oldPreviousSibling","oldNextSibling","inclusiveAncestor","oldDocument","attr","_a","asUnsignedLong","number","treatNullAsEmptyString","asObject","asNullableObject","asNullableString","Node","Object","defineProperty","get","enumerable","configurable","hasChildNodes","normalize","_loop_1","nextNode","textNode","this_1","siblingsToRemove","replaceData","_loop_2","currentNode","currentNodeIndex","shift","deep","other","isDefaultNamespace","defaultNamespace","lookupNamespaceURI","insertBefore","replaceChild","removeChild","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","changeAttribute","attribute","localName","namespaceURI","_value","appendAttribute","ownerElement","removeAttribute","replaceAttribute","oldAttr","newAttr","__extends","extendStatics","d","b","setPrototypeOf","__proto__","p","hasOwnProperty","__","constructor","create","Attr","_super","prefix","call","set","newValue","setExistingAttributeValue","lookupPrefix","CharacterData","_data","parentElement","substringData","offset","appendData","insertData","deleteData","nodeData","newData","substring","Text","splitText","newNode","indexOfNodePlusOne_1","context_1","CDATASection","Comment","DocumentType","publicId","systemId","HTML_NAMESPACE","XML_NAMESPACE","XMLNS_NAMESPACE","NAME_REGEX_XML_1_0_FOURTH_EDITION","matchesNameProduction","test","isValidQName","parts","split","validateQualifiedName","qualifiedName","validateAndExtract","locateNamespacePrefix","find","NamespacePrefixMap","_map","Map","entries","_b","prefixes","retrievePreferredPrefixString","preferredPrefix","ns","candidatesList","candidatesList_1","checkIfFound","add","recordNamespaceInformation","map","localPrefixesMap","defaultNamespaceAttrValue","attributePrefix","prefixDefinition","namespaceDefinition","CHAR_REGEX_XML_1_0_FIFTH_EDITION","PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION","HTML_VOID_ELEMENTS","serializeFragment","requireWellFormed","withFictionalParent","result","childNodes_1","produceXmlSerialization","join","prefixMap","runXmlSerializationAlgorithm","error","prefixIndex","serializeElementNode","serializeDocumentNode","serializeCommentNode","serializeCDATASectionNode","serializeTextNode","serializeDocumentFragmentNode","serializeDocumentTypeNode","serializeProcessingInstructionNode","skipEndTag","ignoreNamespaceDefinitionAttribute","localDefaultNamespace","inheritedNs","candidatePrefix","serializeAttributeValue","generatePrefix","serializeAttributes","localNameSet","tuple","attributeValue","replace","newNamespace","generatedPrefix","comment","endsWith","text","markup","dt","pi","toLowerCase","Element","tagName","getAttributeNodeNS","hasAttributes","getAttribute","getAttributeByName","getAttributeNS","getAttributeByNamespaceAndLocalName","setAttribute","attribute_1","setAttributeNS","validatedNamespace","setAttributeValue","removeAttributeByName","removeAttributeNS","removeAttributeByNamespaceAndLocalName","toggleAttribute","force","attribute_2","hasAttribute","hasAttributeNS","getAttributeNode","setAttributeNode","setAttributeNodeNS","removeAttributeNode","copyElement","createElement","copyAttribute","attribute_3","createElementNS","DOMImplementation","_document","createDocumentType","createDocument","XMLDocument","createHTMLDocument","title","doc","Document","htmlElement","headElement","titleElement","createTextNode","implementation","createDocumentFragment","documentFragment","DocumentFragment","createCDATASection","cdataSection","createComment","createProcessingInstruction","ProcessingInstruction","importNode","createAttribute","createAttributeNS","createRange","Range","isCollapsed","ancestors1","ancestors2","commonAncestorContainer","setStart","rootOfNode","rootOfRange","getRootOfRange","compareBoundaryPointPositions","POSITION_AFTER","setEnd","POSITION_BEFORE","setStartBefore","setStartAfter","setEndBefore","setEndAfter","collapse","toStart","selectNode","selectNodeContents","compareBoundaryPoints","how","sourceRange","START_TO_START","START_TO_END","END_TO_END","END_TO_START","cloneRange","detach","isPointInRange","comparePoint","intersectsNode","POSITION_EQUAL","nodeA","offsetA","nodeB","offsetB","XMLSerializer","serializeToString","root","serializeToWellFormedString","MutationObserver","Function","observe","disconnect","records","unsafeCreateAttribute"],"mappings":"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"}