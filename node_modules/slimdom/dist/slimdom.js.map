{"version":3,"file":"slimdom.js","sources":["../lib/mutation-observer/RegisteredObservers.js","../lib/mutation-observer/NotifyList.js","../lib/context/Context.js","../lib/util/NodeType.js","../lib/util/treeHelpers.js","../lib/util/cloneNode.js","../lib/util/errorHelpers.js","../lib/mixins.js","../lib/util/treeMutations.js","../lib/mutation-observer/queueMutationRecord.js","../lib/util/mutationAlgorithms.js","../lib/util/typeHelpers.js","../lib/util/attrMutations.js","../lib/Attr.js","../lib/CharacterData.js","../lib/Text.js","../lib/util/namespaceHelpers.js","../lib/dom-parsing/NamespacePrefixMap.js","../lib/dom-parsing/serializationAlgorithms.js","../lib/Element.js","../lib/util/createElementNS.js","../lib/Range.js","../lib/mutation-observer/RegisteredObserver.js","../lib/mutation-observer/MutationRecord.js","../lib/Node.js","../lib/CDATASection.js","../lib/Comment.js","../lib/DocumentType.js","../lib/DOMImplementation.js","../lib/Document.js","../lib/DocumentFragment.js","../lib/ProcessingInstruction.js","../lib/XMLDocument.js","../lib/dom-parsing/XMLSerializer.js","../lib/mutation-observer/MutationObserver.js","../lib/index.js","../lib/unsafe.js"],"sourcesContent":["import RegisteredObserver from './RegisteredObserver';\n/**\n * Each node has an associated list of registered observers.\n */\nvar RegisteredObservers = /** @class */ (function () {\n    /**\n     * @param node Node for which this instance holds RegisteredObserver instances.\n     */\n    function RegisteredObservers(node) {\n        this._registeredObservers = [];\n        this._node = node;\n    }\n    /**\n     * Registers a given MutationObserver with the given options.\n     *\n     * @param observer Observer to create a registration for\n     * @param options  Options for the registration\n     */\n    RegisteredObservers.prototype.register = function (observer, options) {\n        // (continuing from MutationObserver#observe)\n        // 7. For each registered registered of target’s registered observer list, if registered's\n        // observer is the context object:\n        var registeredObservers = this._registeredObservers;\n        var hasRegisteredObserverForObserver = false;\n        registeredObservers.forEach(function (registered) {\n            if (registered.observer !== observer) {\n                return;\n            }\n            hasRegisteredObserverForObserver = true;\n            // 7.1. For each node of the context object's node list, remove all transient registered\n            // observers whose source is registered from node's registered observer list.\n            removeTransientRegisteredObserversForSource(registered);\n            // 7.2. Set registered’s options to options.\n            registered.options = options;\n        });\n        // 8. Otherwise:\n        if (!hasRegisteredObserverForObserver) {\n            // 8.1. Append a new registered observer whose observer is the context object and\n            // options is options to target's registered observer list.\n            this._registeredObservers.push(new RegisteredObserver(observer, this._node, options));\n            // 8.2. Append target to the context object's node list.\n            observer._nodes.push(this._node);\n        }\n    };\n    /**\n     * Removes the given transient registered observer.\n     *\n     * Transient registered observers never have a corresponding entry in the observer's list of\n     * nodes. They are guaranteed to be present in the array, as MutationObserver#_transients and\n     * RegisteredObservers#_registeredObservers are kept in sync.\n     *\n     * @param transientRegisteredObserver The registered observer to remove\n     */\n    RegisteredObservers.prototype.removeTransientRegisteredObserver = function (transientRegisteredObserver) {\n        this._registeredObservers.splice(this._registeredObservers.indexOf(transientRegisteredObserver), 1);\n    };\n    /**\n     * Remove any registered observer on the associated node for which observer is the observer.\n     *\n     * As this only occurs for all nodes at once, it is the caller's responsibility to remove the\n     * associated node from the observer's list of nodes.\n     *\n     * @param observer Observer for which to remove the registration\n     */\n    RegisteredObservers.prototype.removeForObserver = function (observer) {\n        // Filter the array in-place\n        var write = 0;\n        for (var read = 0, l = this._registeredObservers.length; read < l; ++read) {\n            var registered = this._registeredObservers[read];\n            if (registered.observer === observer) {\n                continue;\n            }\n            if (read !== write) {\n                this._registeredObservers[write] = registered;\n            }\n            ++write;\n        }\n        this._registeredObservers.length = write;\n    };\n    /**\n     * Determines interested observers for the given record.\n     *\n     * @param type                The type of mutation record to queue\n     * @param target              The target node\n     * @param data                The data for the mutation record\n     * @param interestedObservers Array of mutation observer objects to append to\n     * @param pairedStrings       Paired strings for the mutation observer objects\n     */\n    RegisteredObservers.prototype.collectInterestedObservers = function (type, target, data, interestedObservers, pairedStrings) {\n        // (continuing from queueMutationRecord)\n        // 3. ...and then for each registered of node's registered observer list:\n        this._registeredObservers.forEach(function (registeredObserver) {\n            registeredObserver.collectInterestedObservers(type, target, data, interestedObservers, pairedStrings);\n        });\n    };\n    /**\n     * Append transient registered observers for any registered observers whose options' subtree is\n     * true.\n     *\n     * @param node Node to append the transient registered observers to\n     */\n    RegisteredObservers.prototype.appendTransientRegisteredObservers = function (node) {\n        this._registeredObservers.forEach(function (registeredObserver) {\n            if (registeredObserver.options.subtree) {\n                node._registeredObservers.registerTransient(registeredObserver);\n            }\n        });\n    };\n    /**\n     * Appends a transient registered observer for the given registered observer.\n     *\n     * @param source The source registered observer\n     */\n    RegisteredObservers.prototype.registerTransient = function (source) {\n        this._registeredObservers.push(new RegisteredObserver(source.observer, this._node, source.options, source));\n        // Note that node is not added to the transient observer's observer's list of nodes.\n    };\n    return RegisteredObservers;\n}());\nexport default RegisteredObservers;\n/**\n * Removes all transient registered observers whose observer is observer.\n *\n * @param observer The mutation observer object to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForObserver(observer) {\n    observer._transients.forEach(function (transientRegisteredObserver) {\n        transientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(transientRegisteredObserver);\n    });\n    observer._transients.length = 0;\n}\n/**\n * Removes all transient registered observer whose source is source.\n *\n * @param source The registered observer to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForSource(source) {\n    for (var i = source.observer._transients.length - 1; i >= 0; --i) {\n        var transientRegisteredObserver = source.observer._transients[i];\n        if (transientRegisteredObserver.source !== source) {\n            return;\n        }\n        transientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(transientRegisteredObserver);\n        source.observer._transients.splice(i, 1);\n    }\n}\n//# sourceMappingURL=RegisteredObservers.js.map","import { removeTransientRegisteredObserversForObserver } from './RegisteredObservers';\nfunction queueCompoundMicrotask(callback, thisArg) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    Promise.resolve().then(function () { return callback.apply(thisArg, args); });\n}\n/**\n * Tracks MutationObserver instances which have a non-empty record queue and schedules their\n * callbacks to be called.\n */\nvar NotifyList = /** @class */ (function () {\n    function NotifyList() {\n        this._notifyList = [];\n        this._compoundMicrotaskQueued = false;\n    }\n    /**\n     * Appends a given MutationRecord to the recordQueue of the given MutationObserver and schedules\n     * it for reporting.\n     *\n     * @param observer The observer for which to enqueue the record\n     * @param record   The record to enqueue\n     */\n    NotifyList.prototype.appendRecord = function (observer, record) {\n        observer._recordQueue.push(record);\n        this._notifyList.push(observer);\n    };\n    /**\n     * To queue a mutation observer compound microtask, run these steps:\n     */\n    NotifyList.prototype.queueMutationObserverCompoundMicrotask = function () {\n        var _this = this;\n        // 1. If mutation observer compound microtask queued flag is set, then return.\n        if (this._compoundMicrotaskQueued) {\n            return;\n        }\n        // 2. Set mutation observer compound microtask queued flag.\n        // 3. Queue a compound microtask to notify mutation observers.\n        this._compoundMicrotaskQueued = true;\n        queueCompoundMicrotask(function () {\n            _this._notifyMutationObservers();\n        }, this);\n    };\n    /**\n     * To notify mutation observers, run these steps:\n     */\n    NotifyList.prototype._notifyMutationObservers = function () {\n        var _this = this;\n        // 1. Unset mutation observer compound microtask queued flag.\n        this._compoundMicrotaskQueued = false;\n        // 2. Let notify list be a clone of unit of related similar-origin browsing contexts' list\n        // of MutationObserver objects.\n        var notifyList = this._notifyList.concat();\n        // Clear the notify list - for efficiency this list only tracks observers that have a\n        // non-empty queue\n        this._notifyList.length = 0;\n        // 3. Let signalList be a copy of unit of related similar-origin browsing contexts' signal\n        // slot list.\n        // 4. Empty unit of related similar-origin browsing contexts' signal slot list.\n        // (shadow dom not implemented)\n        // 5. For each MutationObserver object mo in notify list, execute a compound microtask\n        // subtask to run these steps: [HTML]\n        notifyList.forEach(function (mo) {\n            queueCompoundMicrotask(function (mo) {\n                // 5.1. Let queue be a copy of mo’s record queue.\n                // 5.2. Empty mo’s record queue.\n                var queue = mo.takeRecords();\n                // 5.3. For each node of mo's node list, remove all transient registered\n                // observers whose observer is mo from node's registered observer list.\n                removeTransientRegisteredObserversForObserver(mo);\n                // 5.4. If records is not empty, then invoke mo’s callback with « records, mo »,\n                // and mo. If this throws an exception, then report the exception.\n                if (queue.length) {\n                    mo._callback(queue, mo);\n                }\n            }, _this, mo);\n        });\n        // 6. For each slot slot in signalList, in order, fire an event named slotchange, with its\n        // bubbles attribute set to true, at slot.\n        // (shadow dom not implemented)\n    };\n    return NotifyList;\n}());\nexport default NotifyList;\n//# sourceMappingURL=NotifyList.js.map","import NotifyList from '../mutation-observer/NotifyList';\n/**\n * The DefaultContext is comparable to the global object in that it tracks its associated document.\n * It also serves as a way to inject the constructors for the constructable types, avoiding cyclic\n * dependencies.\n */\nvar DefaultContext = /** @class */ (function () {\n    function DefaultContext() {\n        /**\n         * The NotifyList instance is shared between all MutationObserver objects. It holds references\n         * to all MutationObserver instances that have collected records, and is responsible for\n         * invoking their callbacks when control returns to the event loop.\n         */\n        this._notifyList = new NotifyList();\n        this._ranges = [];\n    }\n    return DefaultContext;\n}());\nexport { DefaultContext };\n// TODO: make it possible to create multiple contexts by binding constructors to each instance\nexport var defaultContext = new DefaultContext();\nexport function getContext(instance) {\n    return defaultContext;\n}\n//# sourceMappingURL=Context.js.map","/**\n * Checks whether the given node's nodeType is one of the specified values\n *\n * @param node  The node to test\n * @param types Possible nodeTypes for node\n *\n * @return Whether node.nodeType is one of the specified values\n */\nexport function isNodeOfType(node) {\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        types[_i - 1] = arguments[_i];\n    }\n    return types.some(function (t) { return node.nodeType === t; });\n}\n//# sourceMappingURL=NodeType.js.map","import { isNodeOfType } from './NodeType';\n/**\n * 3.2. Node Tree: to determine the length of a node, switch on node:\n *\n * @param node The node to determine the length of\n *\n * @return The length of the node\n */\nexport function determineLengthOfNode(node) {\n    switch (node.nodeType) {\n        // DocumentType: Zero.\n        // (not necessary, as doctypes never have children)\n        // Text, ProcessingInstruction, Comment: The number of code units in its data.\n        case 3 /* TEXT_NODE */:\n        case 7 /* PROCESSING_INSTRUCTION_NODE */:\n        case 8 /* COMMENT_NODE */:\n            return node.data.length;\n        // Any other node: Its number of children.\n        default:\n            return node.childNodes.length;\n    }\n}\n/**\n * Get inclusive ancestors of the given node.\n *\n * @param node Node to get inclusive ancestors of\n *\n * @return Node's inclusive ancestors, in tree order\n */\nexport function getInclusiveAncestors(node) {\n    var ancestor = node;\n    var ancestors = [];\n    while (ancestor) {\n        ancestors.unshift(ancestor);\n        ancestor = ancestor.parentNode;\n    }\n    return ancestors;\n}\n/**\n * Get the node document associated with the given node.\n *\n * @param node The node to get the node document for\n *\n * @return The node document for node\n */\nexport function getNodeDocument(node) {\n    if (isNodeOfType(node, 9 /* DOCUMENT_NODE */)) {\n        return node;\n    }\n    return node.ownerDocument;\n}\n/**\n * Determine the index of the given node among its siblings.\n *\n * @param node Node to determine the index of\n *\n * @return The index of node in its parent's children\n */\nexport function getNodeIndex(node) {\n    return node.parentNode.childNodes.indexOf(node);\n}\n/**\n * The root of an object is itself, if its parent is null, or else it is the root of its parent.\n *\n * @param node Node to get the root of\n *\n * @return The root of node\n */\nexport function getRootOfNode(node) {\n    while (node.parentNode) {\n        node = node.parentNode;\n    }\n    return node;\n}\n/**\n * Invokes callback on each inclusive descendant of node, in tree order\n *\n * @param node     Root of the subtree to process\n * @param callback Callback to invoke for each descendant, should not modify node's position in the\n *                 tree\n */\nexport function forEachInclusiveDescendant(node, callback) {\n    callback(node);\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n        forEachInclusiveDescendant(child, callback);\n    }\n}\n//# sourceMappingURL=treeHelpers.js.map","import { getNodeDocument } from './treeHelpers';\n// 3.4. Interface Node\n/**\n * To clone a node, with an optional document and clone children flag, run these steps:\n *\n * @param node          The node to clone\n * @param cloneChildren Whether to also clone node's descendants\n * @param document      The document used to create the copy\n */\nexport default function cloneNode(node, cloneChildren, document) {\n    // 1. If document is not given, let document be node’s node document.\n    if (!document) {\n        document = getNodeDocument(node);\n    }\n    // 2. If node is an element, then:\n    // 2.1. Let copy be the result of creating an element, given document, node’s local name, node’s\n    // namespace, node’s namespace prefix, and node’s is value, with the synchronous custom elements\n    // flag unset.\n    // 2.2. For each attribute in node’s attribute list:\n    // 2.2.1. Let copyAttribute be a clone of attribute.\n    // 2.2.2. Append copyAttribute to copy.\n    // 3. Otherwise, let copy be a node that implements the same interfaces as node, and fulfills\n    // these additional requirements, switching on node:\n    // Document: Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n    // DocumentType: Set copy’s name, public ID, and system ID, to those of node.\n    // Attr: Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n    // Text, Comment: Set copy’s data, to that of node.\n    // ProcessingInstruction: Set copy’s target and data to those of node.\n    // Any other node: —\n    // 4. Set copy’s node document and document to copy, if copy is a document, and set copy’s node\n    // document to document otherwise.\n    // (all handled by _copy method)\n    var copy = node._copy(document);\n    // 5. Run any cloning steps defined for node in other applicable specifications and pass copy,\n    // node, document and the clone children flag if set, as parameters.\n    // (cloning steps not implemented)\n    // 6. If the clone children flag is set, clone all the children of node and append them to copy,\n    // with document as specified and the clone children flag being set.\n    if (cloneChildren) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n            copy.appendChild(cloneNode(child, true, document));\n        }\n    }\n    // 7. Return copy.\n    return copy;\n}\n//# sourceMappingURL=cloneNode.js.map","export function expectArity(args, minArity) {\n    // According to WebIDL overload resolution semantics, only a lower bound applies to the number\n    // of arguments provided\n    if (args.length < minArity) {\n        throw new TypeError(\"Function should be called with at least \" + minArity + \" arguments\");\n    }\n}\nexport function expectObject(value, Constructor) {\n    if (!(value instanceof Constructor)) {\n        throw new TypeError(\"Value should be an instance of \" + Constructor.name);\n    }\n}\nfunction createDOMException(name, code, message) {\n    var err = new Error(name + \": \" + message);\n    err.name = name;\n    err.code = code;\n    return err;\n}\nexport function throwHierarchyRequestError(message) {\n    throw createDOMException('HierarchyRequestError', 3, message);\n}\nexport function throwIndexSizeError(message) {\n    throw createDOMException('IndexSizeError', 1, message);\n}\nexport function throwInUseAttributeError(message) {\n    throw createDOMException('InUseAttributeError', 10, message);\n}\nexport function throwInvalidCharacterError(message) {\n    throw createDOMException('InvalidCharacterError', 5, message);\n}\nexport function throwInvalidNodeTypeError(message) {\n    throw createDOMException('InvalidNodeTypeError', 24, message);\n}\nexport function throwInvalidStateError(message) {\n    throw createDOMException('InvalidStateError', 11, message);\n}\nexport function throwNamespaceError(message) {\n    throw createDOMException('NamespaceError', 14, message);\n}\nexport function throwNotFoundError(message) {\n    throw createDOMException('NotFoundError', 8, message);\n}\nexport function throwNotSupportedError(message) {\n    throw createDOMException('NotSupportedError', 9, message);\n}\nexport function throwWrongDocumentError(message) {\n    throw createDOMException('WrongDocumentError', 4, message);\n}\n//# sourceMappingURL=errorHelpers.js.map","import { isNodeOfType } from './util/NodeType';\n// Document implements ParentNode;\n// DocumentFragment implements ParentNode;\n// Element implements ParentNode;\nexport function asParentNode(node) {\n    // This is only called from treeMutations.js, where node can never be anything other than these\n    /* istanbul ignore else */\n    if (isNodeOfType(node, 1 /* ELEMENT_NODE */, 9 /* DOCUMENT_NODE */, 11 /* DOCUMENT_FRAGMENT_NODE */)) {\n        return node;\n    }\n    /* istanbul ignore next */\n    return null;\n}\n/**\n * Returns the element children of node.\n *\n * (Non-standard) According to the spec, the children getter should return a live HTMLCollection.\n * This implementation returns a static array instead.\n *\n * @param node The node to get element children of\n *\n * @return The\n */\nexport function getChildren(node) {\n    var elements = [];\n    for (var child = node.firstElementChild; child; child = child.nextElementSibling) {\n        elements.push(child);\n    }\n    return elements;\n}\n// Element implements NonDocumentTypeChildNode;\n// CharacterData implements NonDocumentTypeChildNode;\nexport function asNonDocumentTypeChildNode(node) {\n    if (isNodeOfType(node, 1 /* ELEMENT_NODE */, 8 /* COMMENT_NODE */, 7 /* PROCESSING_INSTRUCTION_NODE */, 3 /* TEXT_NODE */, 4 /* CDATA_SECTION_NODE */)) {\n        return node;\n    }\n    return null;\n}\nexport function getPreviousElementSibling(node) {\n    for (var sibling = node.previousSibling; sibling; sibling = sibling.previousSibling) {\n        if (isNodeOfType(sibling, 1 /* ELEMENT_NODE */)) {\n            return sibling;\n        }\n    }\n    return null;\n}\nexport function getNextElementSibling(node) {\n    for (var sibling = node.nextSibling; sibling; sibling = sibling.nextSibling) {\n        if (isNodeOfType(sibling, 1 /* ELEMENT_NODE */)) {\n            return sibling;\n        }\n    }\n    return null;\n}\n// DocumentType implements ChildNode;\n// Element implements ChildNode;\n// CharacterData implements ChildNode;\n//# sourceMappingURL=mixins.js.map","import { asParentNode, asNonDocumentTypeChildNode } from '../mixins';\nimport { isNodeOfType } from './NodeType';\n/**\n * Insert node into parent's children before referenceNode.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node           Node to insert\n * @param parent         Parent to insert under\n * @param referenceChild Child to insert before\n */\nexport function insertIntoChildren(node, parent, referenceChild) {\n    // Node\n    node.parentNode = parent;\n    var previousSibling = referenceChild === null ? parent.lastChild : referenceChild.previousSibling;\n    var nextSibling = referenceChild === null ? null : referenceChild;\n    node.previousSibling = previousSibling;\n    node.nextSibling = nextSibling;\n    if (previousSibling) {\n        previousSibling.nextSibling = node;\n    }\n    else {\n        parent.firstChild = node;\n    }\n    if (nextSibling) {\n        nextSibling.previousSibling = node;\n        parent.childNodes.splice(parent.childNodes.indexOf(nextSibling), 0, node);\n    }\n    else {\n        parent.lastChild = node;\n        parent.childNodes.push(node);\n    }\n    // ParentNode\n    if (isNodeOfType(node, 1 /* ELEMENT_NODE */)) {\n        var element = node;\n        var parentNode = asParentNode(parent);\n        // Functions calling this will ensure parent is always a ParentNode\n        /* istanbul ignore else */\n        if (parentNode) {\n            var previousElementSibling = null;\n            for (var sibling = previousSibling; sibling; sibling = sibling.previousSibling) {\n                if (isNodeOfType(sibling, 1 /* ELEMENT_NODE */)) {\n                    previousElementSibling = sibling;\n                    break;\n                }\n                var siblingNonDocumentTypeChildNode = asNonDocumentTypeChildNode(sibling);\n                if (siblingNonDocumentTypeChildNode) {\n                    previousElementSibling = siblingNonDocumentTypeChildNode.previousElementSibling;\n                    break;\n                }\n            }\n            var nextElementSibling = null;\n            for (var sibling = nextSibling; sibling; sibling = sibling.nextSibling) {\n                if (isNodeOfType(sibling, 1 /* ELEMENT_NODE */)) {\n                    nextElementSibling = sibling;\n                    break;\n                }\n                var siblingNonDocumentTypeChildNode = asNonDocumentTypeChildNode(sibling);\n                // An element can never be inserted before a doctype\n                /* istanbul ignore else */\n                if (siblingNonDocumentTypeChildNode) {\n                    nextElementSibling = siblingNonDocumentTypeChildNode.nextElementSibling;\n                    break;\n                }\n            }\n            if (!previousElementSibling) {\n                parentNode.firstElementChild = element;\n            }\n            if (!nextElementSibling) {\n                parentNode.lastElementChild = element;\n            }\n            parentNode.childElementCount += 1;\n        }\n    }\n    // Document\n    if (isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        var parentDocument = parent;\n        if (isNodeOfType(node, 1 /* ELEMENT_NODE */)) {\n            parentDocument.documentElement = node;\n        }\n        else if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            parentDocument.doctype = node;\n        }\n    }\n}\n/**\n * Remove node from parent's children.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node   Node to remove\n * @param parent Parent to remove from\n */\nexport function removeFromChildren(node, parent) {\n    var previousSibling = node.previousSibling;\n    var nextSibling = node.nextSibling;\n    var isElement = isNodeOfType(node, 1 /* ELEMENT_NODE */);\n    var previousElementSibling = isElement ? node.previousElementSibling : null;\n    var nextElementSibling = isElement ? node.nextElementSibling : null;\n    // Node\n    node.parentNode = null;\n    node.previousSibling = null;\n    node.nextSibling = null;\n    if (previousSibling) {\n        previousSibling.nextSibling = nextSibling;\n    }\n    else {\n        parent.firstChild = nextSibling;\n    }\n    if (nextSibling) {\n        nextSibling.previousSibling = previousSibling;\n    }\n    else {\n        parent.lastChild = previousSibling;\n    }\n    parent.childNodes.splice(parent.childNodes.indexOf(node), 1);\n    // ParentNode\n    if (isElement) {\n        var parentNode = asParentNode(parent);\n        // Functions calling this will ensure parent is always a ParentNode\n        /* istanbul ignore else */\n        if (parentNode) {\n            if (parentNode.firstElementChild === node) {\n                parentNode.firstElementChild = nextElementSibling;\n            }\n            if (parentNode.lastElementChild === node) {\n                parentNode.lastElementChild = previousElementSibling;\n            }\n            parentNode.childElementCount -= 1;\n        }\n    }\n    // Document\n    if (isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        var parentDocument = parent;\n        if (isNodeOfType(node, 1 /* ELEMENT_NODE */)) {\n            parentDocument.documentElement = null;\n        }\n        else if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            parentDocument.doctype = null;\n        }\n    }\n}\n//# sourceMappingURL=treeMutations.js.map","import { getContext } from '../context/Context';\nimport { default as MutationRecord } from './MutationRecord';\n/**\n * 3.3.2. Queuing a mutation record\n *\n * To queue a mutation record of type for target with name, namespace, oldValue, addedNodes,\n * removedNodes, previousSibling and nextSibling, run these steps:\n * namespace namespace, oldValue oldValue, addedNodes addedNodes, removedNodes removedNodes,\n *\n * To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and\n * nextSibling, queue a mutation record of \"childList\" for target with null, null, null, addedNodes,\n * removedNodes, previousSibling, and nextSibling.\n *\n * To queue an attribute mutation record for target with name, namespace, and oldValue, queue a\n * mutation record of \"attributes\" for target with name, namespace, oldValue, « », « », null, and\n * null.\n *\n * @param type   The type of mutation record to queue\n * @param target The target node\n * @param data   The data for the mutation record\n */\nexport default function queueMutationRecord(type, target, data) {\n    // 1. Let interested observers be an empty map\n    var interestedObservers = [];\n    var pairedStrings = [];\n    // 2. Let nodes be the inclusive ancestors of target.\n    // 3. For each node in nodes, ...:\n    for (var node = target; node; node = node.parentNode) {\n        node._registeredObservers.collectInterestedObservers(type, target, data, interestedObservers, pairedStrings);\n    }\n    var context = getContext(target);\n    // 4. For each observer → mappedOldValue of interestedObservers:\n    interestedObservers.forEach(function (observer, index) {\n        var mappedOldValue = pairedStrings[index];\n        // 4.1. Let record be a new MutationRecord object with its type set to type and target set\n        // to target,\n        var record = new MutationRecord(type, target);\n        // ...attributeName set to to name, attributeNamespace set to namespace...\n        if (data.name !== undefined && data.namespace !== undefined) {\n            record.attributeName = data.name;\n            record.attributeNamespace = data.namespace;\n        }\n        // ...oldValue set to mappedOldValue...\n        if (mappedOldValue !== undefined) {\n            record.oldValue = mappedOldValue;\n        }\n        // ...addedNodes set to addedNodes...\n        if (data.addedNodes !== undefined) {\n            record.addedNodes = data.addedNodes;\n        }\n        // ...removedNodes set to removedNodes...\n        if (data.removedNodes !== undefined) {\n            record.removedNodes = data.removedNodes;\n        }\n        // ...previousSibling set to previousSibling...\n        if (data.previousSibling !== undefined) {\n            record.previousSibling = data.previousSibling;\n        }\n        // ...and nextSibling set to nextSibling.\n        if (data.nextSibling !== undefined) {\n            record.nextSibling = data.nextSibling;\n        }\n        // 4.2. Enqueue record to observer’s record queue.\n        context._notifyList.appendRecord(observer, record);\n    });\n    // 5. Queue a mutation observer compound microtask.\n    context._notifyList.queueMutationObserverCompoundMicrotask();\n}\n//# sourceMappingURL=queueMutationRecord.js.map","import { throwHierarchyRequestError, throwNotFoundError } from './errorHelpers';\nimport { isNodeOfType } from './NodeType';\nimport { determineLengthOfNode, getNodeDocument, getNodeIndex, forEachInclusiveDescendant } from './treeHelpers';\nimport { insertIntoChildren, removeFromChildren } from './treeMutations';\nimport { getContext } from '../context/Context';\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\n// 3.2.3. Mutation algorithms\n/**\n * To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n */\nfunction ensurePreInsertionValidity(node, parent, child) {\n    // 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n    // HierarchyRequestError.\n    if (!isNodeOfType(parent, 9 /* DOCUMENT_NODE */, 11 /* DOCUMENT_FRAGMENT_NODE */, 1 /* ELEMENT_NODE */)) {\n        throwHierarchyRequestError('parent must be a Document, DocumentFragment or Element node');\n    }\n    // 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n    if (node.contains(parent)) {\n        throwHierarchyRequestError('node must not be an inclusive ancestor of parent');\n    }\n    // 3. If child is not null and its parent is not parent, then throw a NotFoundError.\n    if (child && child.parentNode !== parent) {\n        throwNotFoundError('child is not a child of parent');\n    }\n    // 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n    // Comment node, throw a HierarchyRequestError.\n    if (!isNodeOfType(node, 11 /* DOCUMENT_FRAGMENT_NODE */, 10 /* DOCUMENT_TYPE_NODE */, 1 /* ELEMENT_NODE */, 3 /* TEXT_NODE */, 4 /* CDATA_SECTION_NODE */, 7 /* PROCESSING_INSTRUCTION_NODE */, 8 /* COMMENT_NODE */)) {\n        throwHierarchyRequestError('node must be a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction ' +\n            'or Comment node');\n    }\n    // 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n    // not a document, throw a HierarchyRequestError.\n    if (isNodeOfType(node, 3 /* TEXT_NODE */) && isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        throwHierarchyRequestError('can not insert a Text node under a Document');\n    }\n    if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */) &&\n        !isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        throwHierarchyRequestError('can only insert a DocumentType node under a Document');\n    }\n    // 6. If parent is a document, and any of the statements below, switched on node, are true,\n    // throw a HierarchyRequestError.\n    if (isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        var parentDocument = parent;\n        switch (node.nodeType) {\n            // DocumentFragment node\n            case 11 /* DOCUMENT_FRAGMENT_NODE */:\n                // If node has more than one element child or has a Text node child.\n                var fragment = node;\n                if (fragment.firstElementChild !== fragment.lastElementChild) {\n                    throwHierarchyRequestError('can not insert more than one element under a Document');\n                }\n                if (Array.from(fragment.childNodes).some(function (child) {\n                    return isNodeOfType(child, 3 /* TEXT_NODE */);\n                })) {\n                    throwHierarchyRequestError('can not insert a Text node under a Document');\n                }\n                // Otherwise, if node has one element child and either parent has an element child,\n                // child is a doctype, or child is not null and a doctype is following child.\n                if (fragment.firstElementChild &&\n                    (parentDocument.documentElement ||\n                        (child && isNodeOfType(child, 10 /* DOCUMENT_TYPE_NODE */)) ||\n                        (child &&\n                            parentDocument.doctype &&\n                            getNodeIndex(child) < getNodeIndex(parentDocument.doctype)))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n            // element\n            case 1 /* ELEMENT_NODE */:\n                // parent has an element child, child is a doctype, or child is not null and a\n                // doctype is following child.\n                if (parentDocument.documentElement ||\n                    (child && isNodeOfType(child, 10 /* DOCUMENT_TYPE_NODE */)) ||\n                    (child &&\n                        parentDocument.doctype &&\n                        getNodeIndex(child) < getNodeIndex(parentDocument.doctype))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n            // doctype\n            case 10 /* DOCUMENT_TYPE_NODE */:\n                // parent has a doctype child, child is non-null and an element is preceding child,\n                // or child is null and parent has an element child.\n                if (parentDocument.doctype ||\n                    (child &&\n                        parentDocument.documentElement &&\n                        getNodeIndex(parentDocument.documentElement) < getNodeIndex(child)) ||\n                    (!child && parentDocument.documentElement)) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n        }\n    }\n}\n/**\n * To pre-insert a node into a parent before a child, run these steps:\n *\n * @param node   Node to pre-insert\n * @param parent Parent to insert under\n * @param child  Child to insert before, or null to insert at the end of parent\n *\n * @return The inserted node\n */\nexport function preInsertNode(node, parent, child) {\n    // 1. Ensure pre-insertion validity of node into parent before child.\n    ensurePreInsertionValidity(node, parent, child);\n    // 2. Let reference child be child.\n    var referenceChild = child;\n    // 3. If reference child is node, set it to node’s next sibling.\n    if (referenceChild === node) {\n        referenceChild = node.nextSibling;\n    }\n    // 4. Adopt node into parent’s node document.\n    adoptNode(node, getNodeDocument(parent));\n    // 5. Insert node into parent before reference child.\n    insertNode(node, parent, referenceChild);\n    // 6. Return node.\n    return node;\n}\n/**\n * To insert a node into a parent before a child, with an optional suppress observers flag, run\n * these steps:\n *\n * @param node              Node to insert\n * @param parent            Parent to insert under\n * @param child             Child to insert before, or null to insert at end of parent\n * @param suppressObservers Whether to skip enqueueing a mutation record for this mutation\n */\nexport function insertNode(node, parent, child, suppressObservers) {\n    if (suppressObservers === void 0) { suppressObservers = false; }\n    // 1. Let count be the number of children of node if it is a DocumentFragment node, and one\n    // otherwise.\n    var isDocumentFragment = isNodeOfType(node, 11 /* DOCUMENT_FRAGMENT_NODE */);\n    var count = isDocumentFragment ? determineLengthOfNode(node) : 1;\n    // 2. If child is non-null, then:\n    if (child !== null) {\n        var childIndex_1 = getNodeIndex(child);\n        var context = getContext(node);\n        context._ranges.forEach(function (range) {\n            // 2.1. For each live range whose start node is parent and start offset is greater than\n            // child’s index, increase its start offset by count.\n            if (range.startContainer === parent && range.startOffset > childIndex_1) {\n                range.startOffset += count;\n            }\n            // 2.2. For each live range whose end node is parent and end offset is greater than\n            // child’s index, increase its end offset by count.\n            if (range.endContainer === parent && range.endOffset > childIndex_1) {\n                range.endOffset += count;\n            }\n        });\n    }\n    // 3. Let nodes be node’s children if node is a DocumentFragment node, and a list containing\n    // solely node otherwise.\n    var nodes = isDocumentFragment ? Array.from(node.childNodes) : [node];\n    // 4. If node is a DocumentFragment node, remove its children with the suppress observers flag\n    // set.\n    if (isDocumentFragment) {\n        nodes.forEach(function (n) { return removeNode(n, node, true); });\n    }\n    // 5. If node is a DocumentFragment node, then queue a tree mutation record for node with « »,\n    // nodes, null and null. This step intentionally does not pay attention to the suppress\n    // observers flag.\n    if (isDocumentFragment) {\n        queueMutationRecord('childList', node, {\n            removedNodes: nodes\n        });\n    }\n    // 6. Let previousSibling be child’s previous sibling or parent’s last child if child is null.\n    var previousSibling = child === null ? parent.lastChild : child.previousSibling;\n    // 7. For each node in nodes, in tree order:\n    nodes.forEach(function (node) {\n        // 7.1. If child is null, then append node to parent’s children.\n        // 7.2. Otherwise, insert node into parent’s children before child’s index.\n        insertIntoChildren(node, parent, child);\n        // 7.3. If parent is a shadow host and node is a slotable, then assign a slot for node.\n        // (shadow dom not implemented)\n        // 7.4. If node is a Text node, run the child text content change steps for parent.\n        // (child text content change steps not implemented)\n        // 7.5. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the\n        // empty list, then run signal a slot change for parent.\n        // 7.6. Run assign slotables for a tree with node’s tree.\n        // (shadow dom not implemented)\n        // 7.7. For each shadow-including inclusive descendant inclusiveDescendant of node, in\n        // shadow-including tree order:\n        // 7.7.1. Run the insertion steps with inclusiveDescendant.\n        // (insertion steps not implemented)\n        // 7.7.2. If inclusiveDescendant is connected, then:\n        // 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom element callback\n        // reaction with inclusiveDescendant, callback name \"connectedCallback\", and an empty\n        // argument list.\n        // 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant. If this successfully upgrades\n        // inclusiveDescendant, its connectedCallback will be enqueued automatically during the\n        // upgrade an element algorithm.\n        // (custom elements not implemented)\n    });\n    // 8. If suppress observers flag is unset, queue a tree mutation record for parent with nodes,\n    // « », previousSibling and child.\n    if (!suppressObservers) {\n        queueMutationRecord('childList', parent, {\n            addedNodes: nodes,\n            nextSibling: child,\n            previousSibling: previousSibling\n        });\n    }\n}\n/**\n * To append a node to a parent\n *\n * @param node   Node to append\n * @param parent Parent to append to\n *\n * @return The appended node\n */\nexport function appendNode(node, parent) {\n    // pre-insert node into parent before null.\n    return preInsertNode(node, parent, null);\n}\n/**\n * To replace a child with node within a parent, run these steps:\n *\n * @param child  The child node to replace\n * @param node   The node to replace child with\n * @param parent The parent to replace under\n *\n * @return The old child node\n */\nexport function replaceChildWithNode(child, node, parent) {\n    // 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n    // HierarchyRequestError.\n    if (!isNodeOfType(parent, 9 /* DOCUMENT_NODE */, 11 /* DOCUMENT_FRAGMENT_NODE */, 1 /* ELEMENT_NODE */)) {\n        throwHierarchyRequestError('Can not replace under a non-parent node');\n    }\n    // 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n    if (node.contains(parent)) {\n        throwHierarchyRequestError('Can not insert a node under its own descendant');\n    }\n    // 3. If child’s parent is not parent, then throw a NotFoundError.\n    if (child.parentNode !== parent) {\n        throwNotFoundError('child is not a child of parent');\n    }\n    // 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n    // Comment node, throw a HierarchyRequestError.\n    if (!isNodeOfType(node, 11 /* DOCUMENT_FRAGMENT_NODE */, 10 /* DOCUMENT_TYPE_NODE */, 1 /* ELEMENT_NODE */, 3 /* TEXT_NODE */, 4 /* CDATA_SECTION_NODE */, 7 /* PROCESSING_INSTRUCTION_NODE */, 8 /* COMMENT_NODE */)) {\n        throwHierarchyRequestError(\"Can not insert a node that isn't a DocumentFragment, DocumentType, Element, Text, \" +\n            'ProcessingInstruction or Comment');\n    }\n    // 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n    // not a document, throw a HierarchyRequestError.\n    if (isNodeOfType(node, 3 /* TEXT_NODE */) && isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        throwHierarchyRequestError('can not insert a Text node under a Document');\n    }\n    if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */) &&\n        !isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        throwHierarchyRequestError('can only insert a DocumentType node under a Document');\n    }\n    // 6. If parent is a document, and any of the statements below, switched on node, are true,\n    // throw a HierarchyRequestError.\n    if (isNodeOfType(parent, 9 /* DOCUMENT_NODE */)) {\n        var parentDocument = parent;\n        switch (node.nodeType) {\n            // DocumentFragment node\n            case 11 /* DOCUMENT_FRAGMENT_NODE */:\n                // If node has more than one element child or has a Text node child.\n                var fragment = node;\n                if (fragment.firstElementChild !== fragment.lastElementChild) {\n                    throwHierarchyRequestError('can not insert more than one element under a Document');\n                }\n                if (Array.from(fragment.childNodes).some(function (child) {\n                    return isNodeOfType(child, 3 /* TEXT_NODE */);\n                })) {\n                    throwHierarchyRequestError('can not insert a Text node under a Document');\n                }\n                // Otherwise, if node has one element child and either parent has an element child\n                // that is not child or a doctype is following child.\n                if (fragment.firstElementChild &&\n                    ((parentDocument.documentElement &&\n                        parentDocument.documentElement !== child) ||\n                        (child &&\n                            parentDocument.doctype &&\n                            getNodeIndex(child) < getNodeIndex(parentDocument.doctype)))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n            // element\n            case 1 /* ELEMENT_NODE */:\n                // parent has an element child that is not child or a doctype is following child.\n                if ((parentDocument.documentElement &&\n                    parentDocument.documentElement !== child) ||\n                    (parentDocument.doctype &&\n                        getNodeIndex(child) < getNodeIndex(parentDocument.doctype))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n            // doctype\n            case 10 /* DOCUMENT_TYPE_NODE */:\n                // parent has a doctype child that is not child, or an element is preceding child.\n                if ((parentDocument.doctype && parentDocument.doctype !== child) ||\n                    (parentDocument.documentElement &&\n                        getNodeIndex(parentDocument.documentElement) < getNodeIndex(child))) {\n                    throwHierarchyRequestError('Document should contain at most one doctype, followed by at most one ' +\n                        'element');\n                }\n                break;\n        }\n        // The above statements differ from the pre-insert algorithm.\n    }\n    // 7. Let reference child be child’s next sibling.\n    var referenceChild = child.nextSibling;\n    // 8. If reference child is node, set it to node’s next sibling.\n    if (referenceChild === node) {\n        referenceChild = node.nextSibling;\n    }\n    // 9. Let previousSibling be child’s previous sibling.\n    var previousSibling = child.previousSibling;\n    // 10. Adopt node into parent’s node document.\n    adoptNode(node, getNodeDocument(parent));\n    // 11. Let removedNodes be the empty list.\n    var removedNodes = [];\n    // 12. If child’s parent is not null, then:\n    if (child.parentNode !== null) {\n        // 12.1. Set removedNodes to a list solely containing child.\n        removedNodes.push(child);\n        // 12.2. Remove child from its parent with the suppress observers flag set.\n        removeNode(child, child.parentNode, true);\n    }\n    // The above can only be false if child is node.\n    // 13. Let nodes be node’s children if node is a DocumentFragment node, and a list containing\n    // solely node otherwise.\n    var nodes = isNodeOfType(node, 11 /* DOCUMENT_FRAGMENT_NODE */)\n        ? Array.from(node.childNodes)\n        : [node];\n    // 14. Insert node into parent before reference child with the suppress observers flag set.\n    insertNode(node, parent, referenceChild, true);\n    // 15. Queue a tree mutation record for parent with nodes, removedNodes, previousSibling and\n    // reference child.\n    queueMutationRecord('childList', parent, {\n        addedNodes: nodes,\n        removedNodes: removedNodes,\n        nextSibling: referenceChild,\n        previousSibling: previousSibling\n    });\n    // 16. Return child.\n    return child;\n}\n/**\n * To pre-remove a child from a parent, run these steps:\n *\n * @param child  Child node to remove\n * @param parent Parent under which to remove child\n *\n * @return The removed child\n */\nexport function preRemoveChild(child, parent) {\n    // 1. If child’s parent is not parent, then throw a NotFoundError.\n    if (child.parentNode !== parent) {\n        throwNotFoundError('child is not a child of parent');\n    }\n    // 2. Remove child from parent.\n    removeNode(child, parent);\n    // 3. Return child.\n    return child;\n}\n/**\n * To remove a node from a parent, with an optional suppress observers flag, run these steps:\n *\n * @param node              Child to remove\n * @param parent            Parent to remove child from\n * @param suppressObservers Whether to skip enqueueing a mutation record for this mutation\n */\nexport function removeNode(node, parent, suppressObservers) {\n    if (suppressObservers === void 0) { suppressObservers = false; }\n    // 1. Let index be node’s index.\n    var index = getNodeIndex(node);\n    var context = getContext(node);\n    context._ranges.forEach(function (range) {\n        // 2. For each live range whose start node is an inclusive descendant of node, set its start\n        // to (parent, index).\n        if (node.contains(range.startContainer)) {\n            range.startContainer = parent;\n            range.startOffset = index;\n        }\n        // 3. For each live range whose end node is an inclusive descendant of node, set its end to\n        // (parent, index).\n        if (node.contains(range.endContainer)) {\n            range.endContainer = parent;\n            range.endOffset = index;\n        }\n        // 4. For each live range whose start node is parent and start offset is greater than index,\n        // decrease its start offset by one.\n        if (range.startContainer === parent && range.startOffset > index) {\n            range.startOffset -= 1;\n        }\n        // 5. For each live range whose end node is parent and end offset is greater than index,\n        // decrease its end offset by one.\n        if (range.endContainer === parent && range.endOffset > index) {\n            range.endOffset -= 1;\n        }\n    });\n    // 6. For each NodeIterator object iterator whose root’s node document is node’s node document,\n    // run the NodeIterator pre-removing steps given node and iterator.\n    // (NodeIterator not implemented)\n    // 7. Let oldPreviousSibling be node’s previous sibling.\n    var oldPreviousSibling = node.previousSibling;\n    // 8. Let oldNextSibling be node’s next sibling.\n    var oldNextSibling = node.nextSibling;\n    // 9. Remove node from its parent’s children.\n    removeFromChildren(node, parent);\n    // 10. If node is assigned, then run assign slotables for node’s assigned slot.\n    // (shadow dom not implemented)\n    // 11. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the empty\n    // list, then run signal a slot change for parent.\n    // (shadow dom not implemented)\n    // 12. If node has an inclusive descendant that is a slot, then:\n    // 12.1. Run assign slotables for a tree with parent’s tree.\n    // 12.2. Run assign slotables for a tree with node’s tree.\n    // (shadow dom not implemented)\n    // 13. Run the removing steps with node and parent.\n    // (removing steps not implemented)\n    // 14. If node is custom, then enqueue a custom element callback reaction with node, callback\n    // name \"disconnectedCallback\", and an empty argument list.\n    // It is intentional for now that custom elements do not get parent passed. This might change in\n    // the future if there is a need.\n    // (custom elements not implemented)\n    // 15. For each shadow-including descendant descendant of node, in shadow-including tree order,\n    // then:\n    // 15.1. Run the removing steps with descendant.\n    // (shadow dom not implemented)\n    // 15.2. If descendant is custom, then enqueue a custom element callback reaction with\n    // descendant, callback name \"disconnectedCallback\", and an empty argument list.\n    // (custom elements not implemented)\n    // 16. For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of\n    // inclusiveAncestor's registered observer list, if registered's options's subtree is true, then\n    // append a new transient registered observer whose observer is registered's observer, options\n    // is registered's options, and source is registered to node's registered observer list.\n    for (var inclusiveAncestor = parent; inclusiveAncestor; inclusiveAncestor = inclusiveAncestor.parentNode) {\n        inclusiveAncestor._registeredObservers.appendTransientRegisteredObservers(node);\n    }\n    // 17. If suppress observers flag is unset, queue a tree mutation record for parent with « »,\n    // « node », oldPreviousSibling, and oldNextSibling\n    if (!suppressObservers) {\n        queueMutationRecord('childList', parent, {\n            removedNodes: [node],\n            nextSibling: oldNextSibling,\n            previousSibling: oldPreviousSibling\n        });\n    }\n    // 18. If node is a Text node, then run the child text content change steps for parent.\n    // (child text content change steps not implemented)\n}\n/**\n * 3.5. Interface Document\n *\n * To adopt a node into a document, run these steps:\n *\n * @param node     Node to adopt\n * @param document Document to adopt node into\n */\nexport function adoptNode(node, document) {\n    // 1. Let oldDocument be node’s node document.\n    var oldDocument = getNodeDocument(node);\n    // 2. If node’s parent is not null, remove node from its parent.\n    if (node.parentNode) {\n        removeNode(node, node.parentNode);\n    }\n    // 3. If document is not oldDocument, then:\n    if (document === oldDocument) {\n        return;\n    }\n    // 3.1. For each inclusiveDescendant in node’s shadow-including inclusive descendants:\n    forEachInclusiveDescendant(node, function (node) {\n        // 3.1.1. Set inclusiveDescendant’s node document to document.\n        // (calling code ensures that node is never a Document)\n        node.ownerDocument = document;\n        // 3.1.2. If inclusiveDescendant is an element, then set the node document of each attribute\n        // in inclusiveDescendant’s attribute list to document.\n        if (isNodeOfType(node, 1 /* ELEMENT_NODE */)) {\n            for (var _i = 0, _a = node.attributes; _i < _a.length; _i++) {\n                var attr = _a[_i];\n                attr.ownerDocument = document;\n            }\n        }\n    });\n    // 3.2. For each inclusiveDescendant in node’s shadow-including inclusive descendants that is\n    // custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name\n    // \"adoptedCallback\", and an argument list containing oldDocument and document.\n    // (custom element support has not been implemented)\n    // 3.3. For each inclusiveDescendant in node’s shadow-including inclusive descendants, in\n    // shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.\n    // (adopting steps not implemented)\n}\n//# sourceMappingURL=mutationAlgorithms.js.map","import { expectObject } from './errorHelpers';\nexport function asUnsignedLong(number) {\n    return number >>> 0;\n}\nexport function treatNullAsEmptyString(value) {\n    // Treat null as empty string\n    if (value === null) {\n        return '';\n    }\n    // Coerce other values to string\n    return String(value);\n}\nexport function asObject(value, Constructor) {\n    expectObject(value, Constructor);\n    return value;\n}\nexport function asNullableObject(value, Constructor) {\n    if (value === undefined || value === null) {\n        return null;\n    }\n    return asObject(value, Constructor);\n}\nexport function asNullableString(value) {\n    // Treat undefined as null\n    if (value === undefined) {\n        return null;\n    }\n    return value;\n}\n//# sourceMappingURL=typeHelpers.js.map","import queueMutationRecord from '../mutation-observer/queueMutationRecord';\n/**\n * To change an attribute attribute from an element element to value, run these steps:\n *\n * @param attribute The attribute to change\n * @param element   The element that has the attribute\n * @param value     The new value for the attribute\n */\nexport function changeAttribute(attribute, element, value) {\n    // 1. Queue an attribute mutation record for element with attribute’s local name, attribute's\n    // namespace, and attribute’s value.\n    queueMutationRecord('attributes', element, {\n        name: attribute.localName,\n        namespace: attribute.namespaceURI,\n        oldValue: attribute.value\n    });\n    // 2. If element is custom, then enqueue a custom element callback reaction with element,\n    // callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n    // name, attribute’s value, value, and attribute’s namespace.\n    // (custom elements not implemented)\n    // 3. Run the attribute change steps with element, attribute’s local name, attribute’s value,\n    // value, and attribute’s namespace.\n    // (attribute change steps not implemented)\n    // 4. Set attribute’s value to value.\n    attribute._value = value;\n}\n/**\n * To append an attribute attribute to an element element, run these steps:\n *\n * @param attribute The attribute to append\n * @param element   The element to append attribute to\n */\nexport function appendAttribute(attribute, element) {\n    // 1. Queue an attribute mutation record for element with attribute’s local name, attribute's\n    // namespace, and null.\n    queueMutationRecord('attributes', element, {\n        name: attribute.localName,\n        namespace: attribute.namespaceURI,\n        oldValue: null\n    });\n    // 2. If element is custom, then enqueue a custom element callback reaction with element,\n    // callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n    // name, null, attribute’s value, and attribute’s namespace.\n    // (custom elements not implemented)\n    // 3. Run the attribute change steps with element, attribute’s local name, null, attribute’s\n    // value, and attribute’s namespace.\n    // (attribute change steps not implemented)\n    // 4. Append attribute to element’s attribute list.\n    element.attributes.push(attribute);\n    // 5. Set attribute’s element to element.\n    attribute.ownerElement = element;\n}\n/**\n * To remove an attribute attribute from an element element, run these steps:\n *\n * @param attribute The attribute to remove\n * @param element   The element to remove attribute from\n */\nexport function removeAttribute(attribute, element) {\n    // 1. Queue an attribute mutation record for element with attribute’s local name, attribute's\n    // namespace, and attribute’s value.\n    queueMutationRecord('attributes', element, {\n        name: attribute.localName,\n        namespace: attribute.namespaceURI,\n        oldValue: attribute.value\n    });\n    // 2. If element is custom, then enqueue a custom element callback reaction with element,\n    // callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n    // name, attribute’s value, null, and attribute’s namespace.\n    // (custom elements not implemented)\n    // 3. Run the attribute change steps with element, attribute’s local name, attribute’s value,\n    // null, and attribute’s namespace.\n    // (attribute change steps not implemented)\n    // 4. Remove attribute from element’s attribute list.\n    element.attributes.splice(element.attributes.indexOf(attribute), 1);\n    // 5. Set attribute’s element to null.\n    attribute.ownerElement = null;\n}\n/**\n * To replace an attribute oldAttr by an attribute newAttr in an element element, run these steps:\n *\n * @param oldAttr The attribute to replace\n * @param newAttr The attribute to replace oldAttr with\n * @param element The element on which to replace the attribute\n */\nexport function replaceAttribute(oldAttr, newAttr, element) {\n    // 1. Queue an attribute mutation record for element with oldAttr’s local name, oldAttr’s\n    // namespace, and oldAttr’s value.\n    queueMutationRecord('attributes', element, {\n        name: oldAttr.localName,\n        namespace: oldAttr.namespaceURI,\n        oldValue: oldAttr.value\n    });\n    // 2. If element is custom, then enqueue a custom element callback reaction with element,\n    // callback name \"attributeChangedCallback\", and an argument list containing oldAttr’s local\n    // name, oldAttr’s value, newAttr’s value, and oldAttr’s namespace.\n    // (custom elements not implemented)\n    // 3. Run the attribute change steps with element, oldAttr’s local name, oldAttr’s value,\n    // newAttr’s value, and oldAttr’s namespace.\n    // (attribute change steps not implemented)\n    // 4. Replace oldAttr by newAttr in element’s attribute list.\n    element.attributes.splice(element.attributes.indexOf(oldAttr), 1, newAttr);\n    // 5. Set oldAttr’s element to null.\n    oldAttr.ownerElement = null;\n    // 6. Set newAttr’s element to element.\n    newAttr.ownerElement = element;\n}\n//# sourceMappingURL=attrMutations.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { changeAttribute } from './util/attrMutations';\nimport { expectArity } from './util/errorHelpers';\nimport { treatNullAsEmptyString } from './util/typeHelpers';\n/**\n * 3.9.2. Interface Attr\n */\nvar Attr = /** @class */ (function (_super) {\n    __extends(Attr, _super);\n    /**\n     * (non-standard) use Document#createAttribute(NS) or Element#setAttribute(NS) to create\n     * attribute nodes\n     *\n     * @param namespace The namespace URI for the attribute\n     * @param prefix    The prefix for the attribute\n     * @param localName The local name for the attribute\n     * @param value     The value for the attribute\n     * @param element   The element for the attribute, or null if the attribute is not attached to\n     *                  an element\n     */\n    function Attr(namespace, prefix, localName, value, element) {\n        var _this = _super.call(this) || this;\n        _this.namespaceURI = namespace;\n        _this.prefix = prefix;\n        _this.localName = localName;\n        _this.name = prefix === null ? localName : prefix + \":\" + localName;\n        _this._value = value;\n        _this.ownerElement = element;\n        return _this;\n    }\n    Object.defineProperty(Attr.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 2 /* ATTRIBUTE_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Attr.prototype, \"nodeName\", {\n        get: function () {\n            // Return the qualified name\n            return this.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Attr.prototype, \"nodeValue\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (newValue) {\n            newValue = treatNullAsEmptyString(newValue);\n            // Set an existing attribute value with context object and new value.\n            setExistingAttributeValue(this, newValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Attr.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to recursion)\n        // 2. Switch on the context object:\n        // Attr - Return the result of locating a namespace prefix for its element, if its element\n        // is non-null, and null otherwise.\n        if (this.ownerElement !== null) {\n            return this.ownerElement.lookupPrefix(namespace);\n        }\n        return null;\n    };\n    Attr.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to recursion)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: Attr\n        // 1. If its element is null, then return null.\n        if (this.ownerElement === null) {\n            return null;\n        }\n        // 2. Return the result of running locate a namespace on its element using prefix.\n        return this.ownerElement.lookupNamespaceURI(prefix);\n    };\n    Object.defineProperty(Attr.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (value) {\n            setExistingAttributeValue(this, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    Attr.prototype._copy = function (document) {\n        // Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n        var context = getContext(document);\n        var copy = new context.Attr(this.namespaceURI, this.prefix, this.localName, this.value, null);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return Attr;\n}(Node));\nexport default Attr;\n/**\n * To set an existing attribute value, given an attribute attribute and string value, run these\n * steps:\n *\n * @param attribute The attribute to set the value of\n * @param value     The new value for attribute\n */\nfunction setExistingAttributeValue(attribute, value) {\n    // 1. If attribute’s element is null, then set attribute’s value to value.\n    var element = attribute.ownerElement;\n    if (element === null) {\n        attribute._value = value;\n    }\n    else {\n        // 2. Otherwise, change attribute from attribute’s element to value.\n        changeAttribute(attribute, element, value);\n    }\n}\n//# sourceMappingURL=Attr.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getNextElementSibling, getPreviousElementSibling } from './mixins';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport queueMutationRecord from './mutation-observer/queueMutationRecord';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport { asUnsignedLong, treatNullAsEmptyString } from './util/typeHelpers';\n/**\n * 3.10. Interface CharacterData\n */\nvar CharacterData = /** @class */ (function (_super) {\n    __extends(CharacterData, _super);\n    /**\n     * (non-standard) CharacterData should never be instantiated directly.\n     *\n     * @param data The data to associate with the node\n     */\n    function CharacterData(data) {\n        var _this = _super.call(this) || this;\n        _this._data = String(data);\n        return _this;\n    }\n    Object.defineProperty(CharacterData.prototype, \"nodeValue\", {\n        // Node\n        get: function () {\n            return this._data;\n        },\n        set: function (newValue) {\n            newValue = treatNullAsEmptyString(newValue);\n            // Set an existing attribute value with context object and new value.\n            replaceData(this, 0, this.length, newValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CharacterData.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to recursion)\n        // 2. Switch on the context object:\n        // Any other node - Return the result of locating a namespace prefix for its parent element,\n        // if its parent element is non-null, and null otherwise.\n        var parentElement = this.parentElement;\n        if (parentElement !== null) {\n            return parentElement.lookupPrefix(namespace);\n        }\n        return null;\n    };\n    CharacterData.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to recursion)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: Any other node\n        // 1. If its parent element is null, then return null.\n        var parentElement = this.parentElement;\n        if (parentElement === null) {\n            return null;\n        }\n        // 2. Return the result of running locate a namespace on its parent element using prefix.\n        return parentElement.lookupNamespaceURI(prefix);\n    };\n    Object.defineProperty(CharacterData.prototype, \"previousElementSibling\", {\n        // NonDocumentTypeChildNode\n        get: function () {\n            return getPreviousElementSibling(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CharacterData.prototype, \"nextElementSibling\", {\n        get: function () {\n            return getNextElementSibling(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CharacterData.prototype, \"data\", {\n        get: function () {\n            return this._data;\n        },\n        set: function (newValue) {\n            // [TreatNullAs=EmptyString]\n            newValue = treatNullAsEmptyString(newValue);\n            // replace data with node context object, offset 0, count context object’s length, and data\n            // new value.\n            replaceData(this, 0, this.length, newValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CharacterData.prototype, \"length\", {\n        get: function () {\n            return this.data.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns a substring of the node's data.\n     *\n     * @param offset Offset at which to start the substring\n     * @param count  The number of code units to return\n     *\n     * @return The specified substring\n     */\n    CharacterData.prototype.substringData = function (offset, count) {\n        expectArity(arguments, 2);\n        return substringData(this, offset, count);\n    };\n    /**\n     * Appends data to the node's data.\n     *\n     * @param data Data to append\n     */\n    CharacterData.prototype.appendData = function (data) {\n        expectArity(arguments, 1);\n        replaceData(this, this.length, 0, data);\n    };\n    /**\n     * Inserts data at the specified position in the node's data.\n     *\n     * @param offset Offset at which to insert\n     * @param data   Data to insert\n     */\n    CharacterData.prototype.insertData = function (offset, data) {\n        expectArity(arguments, 1);\n        replaceData(this, offset, 0, data);\n    };\n    /**\n     * Deletes data from the specified position.\n     *\n     * @param offset Offset at which to delete\n     * @param count  Number of code units to delete\n     */\n    CharacterData.prototype.deleteData = function (offset, count) {\n        expectArity(arguments, 2);\n        replaceData(this, offset, count, '');\n    };\n    /**\n     * Replaces data at the specified position.\n     *\n     * @param offset Offset at which to replace\n     * @param count  Number of code units to remove\n     * @param data   Data to insert\n     */\n    CharacterData.prototype.replaceData = function (offset, count, data) {\n        expectArity(arguments, 3);\n        replaceData(this, offset, count, data);\n    };\n    return CharacterData;\n}(Node));\nexport default CharacterData;\n/**\n * To replace data of node node with offset offset, count count, and data data, run these steps:\n *\n * @param node   The node to replace data on\n * @param offset The offset at which to start replacing\n * @param count  The number of code units to replace\n * @param data   The data to insert in place of the removed data\n */\nexport function replaceData(node, offset, count, data) {\n    // Match spec data types\n    offset = asUnsignedLong(offset);\n    count = asUnsignedLong(count);\n    // 1. Let length be node’s length.\n    var length = node.length;\n    // 2. If offset is greater than length, then throw an IndexSizeError.\n    if (offset > length) {\n        throwIndexSizeError(\"can not replace data past the node's length\");\n    }\n    // 3. If offset plus count is greater than length, then set count to length minus offset.\n    if (offset + count > length) {\n        count = length - offset;\n    }\n    // 4. Queue a mutation record of \"characterData\" for node with null, null, node's data, « »,\n    // « », null, and null.\n    queueMutationRecord('characterData', node, {\n        oldValue: node.data\n    });\n    // 5. Insert data into node’s data after offset code units.\n    // 6. Let delete offset be offset + data's length.\n    // 7. Starting from delete offset code units, remove count code units from node’s data.\n    var nodeData = node.data;\n    var newData = nodeData.substring(0, offset) + data + nodeData.substring(offset + count);\n    node._data = newData;\n    var context = getContext(node);\n    context._ranges.forEach(function (range) {\n        // 8. For each live range whose start node is node and start offset is greater than offset\n        // but less than or equal to offset plus count, set its start offset to offset.\n        if (range.startContainer === node &&\n            range.startOffset > offset &&\n            range.startOffset <= offset + count) {\n            range.startOffset = offset;\n        }\n        // 9. For each live range whose end node is node and end offset is greater than offset but\n        // less than or equal to offset plus count, set its end offset to offset.\n        if (range.endContainer === node &&\n            range.endOffset > offset &&\n            range.endOffset <= offset + count) {\n            range.endOffset = offset;\n        }\n        // 10. For each live range whose start node is node and start offset is greater than offset\n        // plus count, increase its start offset by data's length and decrease it by count.\n        if (range.startContainer === node && range.startOffset > offset + count) {\n            range.startOffset = range.startOffset + data.length - count;\n        }\n        // 11. For each live range whose end node is node and end offset is greater than offset plus\n        // count, increase its end offset by data's length and decrease it by count.\n        if (range.endContainer === node && range.endOffset > offset + count) {\n            range.endOffset = range.endOffset + data.length - count;\n        }\n    });\n    // 12. If node is a Text node and its parent is not null, run the child text content change\n    // steps for node’s parent.\n    // (child text content change steps not implemented)\n}\n/**\n * To substring data with node node, offset offset, and count count, run these steps:\n *\n * @param node   The node to get data from\n * @param offset The offset at which to start the substring\n * @param count  The number of code units to include in the substring\n *\n * @return The requested substring\n */\nexport function substringData(node, offset, count) {\n    // Match spec data types\n    offset = asUnsignedLong(offset);\n    count = asUnsignedLong(count);\n    // 1. Let length be node’s length.\n    var length = node.length;\n    // 2. If offset is greater than length, then throw an IndexSizeError.\n    if (offset > length) {\n        throwIndexSizeError(\"can not substring data past the node's length\");\n    }\n    // 3. If offset plus count is greater than length, return a string whose value is the code units\n    // from the offsetth code unit to the end of node’s data, and then return.\n    if (offset + count > length) {\n        return node.data.substring(offset);\n    }\n    // 4. Return a string whose value is the code units from the offsetth code unit to the\n    // offset+countth code unit in node’s data.\n    return node.data.substring(offset, offset + count);\n}\n//# sourceMappingURL=CharacterData.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { replaceData, substringData, default as CharacterData } from './CharacterData';\nimport { getContext } from './context/Context';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport { insertNode } from './util/mutationAlgorithms';\nimport { getNodeIndex } from './util/treeHelpers';\nimport { asUnsignedLong } from './util/typeHelpers';\n/**\n * 3.11. Interface Text\n */\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    // Text\n    /**\n     * Returns a new Text node whose data is data and node document is current global object’s\n     * associated Document.\n     *\n     * @param data     The data for the new text node\n     */\n    function Text(data) {\n        if (data === void 0) { data = ''; }\n        var _this = _super.call(this, data) || this;\n        var context = getContext(_this);\n        _this.ownerDocument = context.document;\n        return _this;\n    }\n    Object.defineProperty(Text.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 3 /* TEXT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"nodeName\", {\n        get: function () {\n            return '#text';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Splits data at the given offset and returns the remainder as Text node.\n     *\n     * @param offset The offset at which to split\n     *\n     * @return a text node containing the second half of the split node's data\n     */\n    Text.prototype.splitText = function (offset) {\n        expectArity(arguments, 1);\n        offset = asUnsignedLong(offset);\n        return splitText(this, offset);\n    };\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    Text.prototype._copy = function (document) {\n        // Set copy’s data, to that of node.\n        var context = getContext(document);\n        var copy = new context.Text(this.data);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return Text;\n}(CharacterData));\nexport default Text;\n/**\n * To split a Text node node with offset offset, run these steps:\n *\n * @param node   The text node to split\n * @param offset The offset to split at\n *\n * @return a text node containing the second half of the split node's data\n */\nfunction splitText(node, offset) {\n    // 1. Let length be node’s length.\n    var length = node.length;\n    // 2. If offset is greater than length, then throw an IndexSizeError.\n    if (offset > length) {\n        throwIndexSizeError(\"can not split past the node's length\");\n    }\n    // 3. Let count be length minus offset.\n    var count = length - offset;\n    // 4. Let new data be the result of substringing data with node node, offset offset, and count\n    // count.\n    var newData = substringData(node, offset, count);\n    // 5. Let new node be a new Text node, with the same node document as node. Set new node’s data\n    // to new data.\n    var context = getContext(node);\n    var newNode = new context.Text(newData);\n    newNode.ownerDocument = node.ownerDocument;\n    // 6. Let parent be node’s parent.\n    var parent = node.parentNode;\n    // 7. If parent is not null, then:\n    if (parent !== null) {\n        // 7.1. Insert new node into parent before node’s next sibling.\n        insertNode(newNode, parent, node.nextSibling);\n        var indexOfNodePlusOne_1 = getNodeIndex(node) + 1;\n        var context_1 = getContext(node);\n        context_1._ranges.forEach(function (range) {\n            // 7.2. For each live range whose start node is node and start offset is greater than\n            // offset, set its start node to new node and decrease its start offset by offset.\n            if (range.startContainer === node && range.startOffset > offset) {\n                range.startContainer = newNode;\n                range.startOffset -= offset;\n            }\n            // 7.3. For each live range whose end node is node and end offset is greater than\n            // offset, set its end node to new node and decrease its end offset by offset.\n            if (range.endContainer === node && range.endOffset > offset) {\n                range.endContainer = newNode;\n                range.endOffset -= offset;\n            }\n            // 7.4. For each live range whose start node is parent and start offset is equal to the\n            // index of node + 1, increase its start offset by one.\n            if (range.startContainer === parent && range.startOffset === indexOfNodePlusOne_1) {\n                range.startOffset += 1;\n            }\n            // 7.5. For each live range whose end node is parent and end offset is equal to the\n            // index of node + 1, increase its end offset by one.\n            if (range.endContainer === parent && range.endOffset === indexOfNodePlusOne_1) {\n                range.endOffset += 1;\n            }\n        });\n    }\n    // 8. Replace data with node node, offset offset, count count, and data the empty string.\n    replaceData(node, offset, count, '');\n    // 9. Return new node.\n    return newNode;\n}\n//# sourceMappingURL=Text.js.map","import { throwInvalidCharacterError, throwNamespaceError } from './errorHelpers';\n// 1.5. Namespaces\nexport var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nexport var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n/*\n// NAME_REGEX_XML_1_0_FOURTH_EDITION generated using regenerate:\nvar regenerate = require(\"regenerate\");\n\nconst productions = {\n    NameChar: \"Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender\",\n    Letter: \"BaseChar | Ideographic\",\n    BaseChar: \"[#x0041-#x005A] | [#x0061-#x007A] | [#x00C0-#x00D6] | [#x00D8-#x00F6] |\n    [#x00F8-#x00FF] | [#x0100-#x0131] | [#x0134-#x013E] | [#x0141-#x0148] | [#x014A-#x017E] |\n    [#x0180-#x01C3] | [#x01CD-#x01F0] | [#x01F4-#x01F5] | [#x01FA-#x0217] | [#x0250-#x02A8] |\n    [#x02BB-#x02C1] | #x0386 | [#x0388-#x038A] | #x038C | [#x038E-#x03A1] | [#x03A3-#x03CE] |\n    [#x03D0-#x03D6] | #x03DA | #x03DC | #x03DE | #x03E0 | [#x03E2-#x03F3] | [#x0401-#x040C] |\n    [#x040E-#x044F] | [#x0451-#x045C] | [#x045E-#x0481] | [#x0490-#x04C4] | [#x04C7-#x04C8] |\n    [#x04CB-#x04CC] | [#x04D0-#x04EB] | [#x04EE-#x04F5] | [#x04F8-#x04F9] | [#x0531-#x0556] | #x0559\n    | [#x0561-#x0586] | [#x05D0-#x05EA] | [#x05F0-#x05F2] | [#x0621-#x063A] | [#x0641-#x064A] |\n    [#x0671-#x06B7] | [#x06BA-#x06BE] | [#x06C0-#x06CE] | [#x06D0-#x06D3] | #x06D5 | [#x06E5-#x06E6]\n    | [#x0905-#x0939] | #x093D | [#x0958-#x0961] | [#x0985-#x098C] | [#x098F-#x0990] |\n    [#x0993-#x09A8] | [#x09AA-#x09B0] | #x09B2 | [#x09B6-#x09B9] | [#x09DC-#x09DD] | [#x09DF-#x09E1]\n    | [#x09F0-#x09F1] | [#x0A05-#x0A0A] | [#x0A0F-#x0A10] | [#x0A13-#x0A28] | [#x0A2A-#x0A30] |\n    [#x0A32-#x0A33] | [#x0A35-#x0A36] | [#x0A38-#x0A39] | [#x0A59-#x0A5C] | #x0A5E | [#x0A72-#x0A74]\n    | [#x0A85-#x0A8B] | #x0A8D | [#x0A8F-#x0A91] | [#x0A93-#x0AA8] | [#x0AAA-#x0AB0] |\n    [#x0AB2-#x0AB3] | [#x0AB5-#x0AB9] | #x0ABD | #x0AE0 | [#x0B05-#x0B0C] | [#x0B0F-#x0B10] |\n    [#x0B13-#x0B28] | [#x0B2A-#x0B30] | [#x0B32-#x0B33] | [#x0B36-#x0B39] | #x0B3D | [#x0B5C-#x0B5D]\n    | [#x0B5F-#x0B61] | [#x0B85-#x0B8A] | [#x0B8E-#x0B90] | [#x0B92-#x0B95] | [#x0B99-#x0B9A] |\n    #x0B9C | [#x0B9E-#x0B9F] | [#x0BA3-#x0BA4] | [#x0BA8-#x0BAA] | [#x0BAE-#x0BB5] | [#x0BB7-#x0BB9]\n    | [#x0C05-#x0C0C] | [#x0C0E-#x0C10] | [#x0C12-#x0C28] | [#x0C2A-#x0C33] | [#x0C35-#x0C39] |\n    [#x0C60-#x0C61] | [#x0C85-#x0C8C] | [#x0C8E-#x0C90] | [#x0C92-#x0CA8] | [#x0CAA-#x0CB3] |\n    [#x0CB5-#x0CB9] | #x0CDE | [#x0CE0-#x0CE1] | [#x0D05-#x0D0C] | [#x0D0E-#x0D10] | [#x0D12-#x0D28]\n    | [#x0D2A-#x0D39] | [#x0D60-#x0D61] | [#x0E01-#x0E2E] | #x0E30 | [#x0E32-#x0E33] |\n    [#x0E40-#x0E45] | [#x0E81-#x0E82] | #x0E84 | [#x0E87-#x0E88] | #x0E8A | #x0E8D | [#x0E94-#x0E97]\n    | [#x0E99-#x0E9F] | [#x0EA1-#x0EA3] | #x0EA5 | #x0EA7 | [#x0EAA-#x0EAB] | [#x0EAD-#x0EAE] |\n    #x0EB0 | [#x0EB2-#x0EB3] | #x0EBD | [#x0EC0-#x0EC4] | [#x0F40-#x0F47] | [#x0F49-#x0F69] |\n    [#x10A0-#x10C5] | [#x10D0-#x10F6] | #x1100 | [#x1102-#x1103] | [#x1105-#x1107] | #x1109 |\n    [#x110B-#x110C] | [#x110E-#x1112] | #x113C | #x113E | #x1140 | #x114C | #x114E | #x1150 |\n    [#x1154-#x1155] | #x1159 | [#x115F-#x1161] | #x1163 | #x1165 | #x1167 | #x1169 | [#x116D-#x116E]\n    | [#x1172-#x1173] | #x1175 | #x119E | #x11A8 | #x11AB | [#x11AE-#x11AF] | [#x11B7-#x11B8] |\n    #x11BA | [#x11BC-#x11C2] | #x11EB | #x11F0 | #x11F9 | [#x1E00-#x1E9B] | [#x1EA0-#x1EF9] |\n    [#x1F00-#x1F15] | [#x1F18-#x1F1D] | [#x1F20-#x1F45] | [#x1F48-#x1F4D] | [#x1F50-#x1F57] | #x1F59\n    | #x1F5B | #x1F5D | [#x1F5F-#x1F7D] | [#x1F80-#x1FB4] | [#x1FB6-#x1FBC] | #x1FBE |\n    [#x1FC2-#x1FC4] | [#x1FC6-#x1FCC] | [#x1FD0-#x1FD3] | [#x1FD6-#x1FDB] | [#x1FE0-#x1FEC] |\n    [#x1FF2-#x1FF4] | [#x1FF6-#x1FFC] | #x2126 | [#x212A-#x212B] | #x212E | [#x2180-#x2182] |\n    [#x3041-#x3094] | [#x30A1-#x30FA] | [#x3105-#x312C] | [#xAC00-#xD7A3]\", Ideographic:\n    \"[#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]\", CombiningChar: \"[#x0300-#x0345] | [#x0360-#x0361]\n    | [#x0483-#x0486] | [#x0591-#x05A1] | [#x05A3-#x05B9] | [#x05BB-#x05BD] | #x05BF |\n    [#x05C1-#x05C2] | #x05C4 | [#x064B-#x0652] | #x0670 | [#x06D6-#x06DC] | [#x06DD-#x06DF] |\n    [#x06E0-#x06E4] | [#x06E7-#x06E8] | [#x06EA-#x06ED] | [#x0901-#x0903] | #x093C | [#x093E-#x094C]\n    | #x094D | [#x0951-#x0954] | [#x0962-#x0963] | [#x0981-#x0983] | #x09BC | #x09BE | #x09BF |\n    [#x09C0-#x09C4] | [#x09C7-#x09C8] | [#x09CB-#x09CD] | #x09D7 | [#x09E2-#x09E3] | #x0A02 | #x0A3C\n    | #x0A3E | #x0A3F | [#x0A40-#x0A42] | [#x0A47-#x0A48] | [#x0A4B-#x0A4D] | [#x0A70-#x0A71] |\n    [#x0A81-#x0A83] | #x0ABC | [#x0ABE-#x0AC5] | [#x0AC7-#x0AC9] | [#x0ACB-#x0ACD] | [#x0B01-#x0B03]\n    | #x0B3C | [#x0B3E-#x0B43] | [#x0B47-#x0B48] | [#x0B4B-#x0B4D] | [#x0B56-#x0B57] |\n    [#x0B82-#x0B83] | [#x0BBE-#x0BC2] | [#x0BC6-#x0BC8] | [#x0BCA-#x0BCD] | #x0BD7 | [#x0C01-#x0C03]\n    | [#x0C3E-#x0C44] | [#x0C46-#x0C48] | [#x0C4A-#x0C4D] | [#x0C55-#x0C56] | [#x0C82-#x0C83] |\n    [#x0CBE-#x0CC4] | [#x0CC6-#x0CC8] | [#x0CCA-#x0CCD] | [#x0CD5-#x0CD6] | [#x0D02-#x0D03] |\n    [#x0D3E-#x0D43] | [#x0D46-#x0D48] | [#x0D4A-#x0D4D] | #x0D57 | #x0E31 | [#x0E34-#x0E3A] |\n    [#x0E47-#x0E4E] | #x0EB1 | [#x0EB4-#x0EB9] | [#x0EBB-#x0EBC] | [#x0EC8-#x0ECD] | [#x0F18-#x0F19]\n    | #x0F35 | #x0F37 | #x0F39 | #x0F3E | #x0F3F | [#x0F71-#x0F84] | [#x0F86-#x0F8B] |\n    [#x0F90-#x0F95] | #x0F97 | [#x0F99-#x0FAD] | [#x0FB1-#x0FB7] | #x0FB9 | [#x20D0-#x20DC] | #x20E1\n    | [#x302A-#x302F] | #x3099 | #x309A\", Digit: \"[#x0030-#x0039] | [#x0660-#x0669] |\n    [#x06F0-#x06F9] | [#x0966-#x096F] | [#x09E6-#x09EF] | [#x0A66-#x0A6F] | [#x0AE6-#x0AEF] |\n    [#x0B66-#x0B6F] | [#x0BE7-#x0BEF] | [#x0C66-#x0C6F] | [#x0CE6-#x0CEF] | [#x0D66-#x0D6F] |\n    [#x0E50-#x0E59] | [#x0ED0-#x0ED9] | [#x0F20-#x0F29]\", Extender: \"#x00B7 | #x02D0 | #x02D1 |\n    #x0387 | #x0640 | #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] | [#x309D-#x309E] |\n    [#x30FC-#x30FE]\"\n};\n\nfunction createSetRegex (prod, set = regenerate()) {\n    return prod.split(' | ').reduce((set, part) => {\n        let m = part.match(/^\\[#x([0-9A-F]+)-#x([0-9A-F]+)\\]$/);\n        if (m) {\n            return set.addRange(parseInt(m[1], 16), parseInt(m[2], 16));\n        }\n        m = part.match(/^#x([0-9A-F]+)$/);\n        if (m) {\n            return set.add(parseInt(m[1], 16));\n        }\n        m = part.match(/^'(.)'$/);\n        if (m) {\n            return set.add(m[1]);\n        }\n        return createSetRegex(productions[part], set);\n    }, set);\n}\n\n// Name ::= (Letter | '_' | ':') (NameChar)*\n`^(?:${createRegex(\"Letter | '_' | ':'\")})(?:${createRegex('NameChar')})*$`;\n*/\nvar NAME_REGEX_XML_1_0_FOURTH_EDITION = /^(?:[:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3007\\u3021-\\u3029\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3])(?:[\\-\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u02D0\\u02D1\\u0300-\\u0345\\u0360\\u0361\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0483-\\u0486\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u0591-\\u05A1\\u05A3-\\u05B9\\u05BB-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0640-\\u0652\\u0660-\\u0669\\u0670-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5-\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0901-\\u0903\\u0905-\\u0939\\u093C-\\u094D\\u0951-\\u0954\\u0958-\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A02\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A74\\u0A81-\\u0A83\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE0\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3C-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE7-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D60\\u0D61\\u0D66-\\u0D6F\\u0E01-\\u0E2E\\u0E30-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F69\\u0F71-\\u0F84\\u0F86-\\u0F8B\\u0F90-\\u0F95\\u0F97\\u0F99-\\u0FAD\\u0FB1-\\u0FB7\\u0FB9\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u20D0-\\u20DC\\u20E1\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3005\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3041-\\u3094\\u3099\\u309A\\u309D\\u309E\\u30A1-\\u30FA\\u30FC-\\u30FE\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3])*$/;\n/*\n// NAME_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\nconst NameStartChar = regenerate()\n    .add(':')\n    .addRange('A', 'Z')\n    .add('_')\n    .addRange('a', 'z')\n    .addRange(0xC0, 0xD6)\n    .addRange(0xD8, 0xF6)\n    .addRange(0xF8, 0x2FF)\n    .addRange(0x370, 0x37D)\n    .addRange(0x37F, 0x1FFF)\n    .addRange(0x200C, 0x200D)\n    .addRange(0x2070, 0x218F)\n    .addRange(0x2C00, 0x2FEF)\n    .addRange(0x3001, 0xD7FF)\n    .addRange(0xF900, 0xFDCF)\n    .addRange(0xFDF0, 0xFFFD)\n    .addRange(0x10000, 0xEFFFF);\n\nconst NameChar = NameStartChar.clone()\n    .add('-')\n    .add('.')\n    .addRange('0', '9')\n    .add(0xB7)\n    .addRange(0x0300, 0x036F)\n    .addRange(0x203F, 0x2040);\n\nreturn `^(?:${NameStartChar.toString()})(?:${NameChar.toString()})*$`;\n*/\nvar NAME_REGEX_XML_1_0_FIFTH_EDITION = /^(?:[:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(?:[\\-\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n/**\n * Returns true if name matches the Name production.\n *\n * @param name The name to check\n *\n * @return true if name matches Name, otherwise false\n */\nexport function matchesNameProduction(name) {\n    return NAME_REGEX_XML_1_0_FOURTH_EDITION.test(name);\n}\n/**\n * As we're already testing against Name, testing QName validity can be reduced to checking if the\n * name contains at most a single colon which is not at the first or last position.\n *\n * @param name The name to check\n *\n * @return True if the name is a valid QName, provided it is also a valid Name, otherwise false\n */\nfunction isValidQName(name) {\n    var parts = name.split(':');\n    if (parts.length > 2) {\n        return false;\n    }\n    if (parts.length === 1) {\n        return true;\n    }\n    // First part should not be empty, and the second part should be a valid name\n    return parts[0].length > 0 && matchesNameProduction(parts[1]);\n}\n/**\n * To validate a qualifiedName,\n *\n * @param qualifiedName Qualified name to validate\n */\nexport function validateQualifiedName(qualifiedName) {\n    // throw an InvalidCharacterError if qualifiedName does not match the Name or QName production.\n    // (QName is basically (Name without ':') ':' (Name without ':'), so just check the position of\n    // the ':')\n    if (!isValidQName(qualifiedName) || !matchesNameProduction(qualifiedName)) {\n        throwInvalidCharacterError('The qualified name is not a valid Name or QName');\n    }\n}\n/**\n * To validate and extract a namespace and qualifiedName, run these steps:\n *\n * @param namespace     Namespace for the qualified name\n * @param qualifiedName Qualified name to validate and extract the components of\n *\n * @return Namespace, prefix and localName\n */\nexport function validateAndExtract(namespace, qualifiedName) {\n    // 1. If namespace is the empty string, set it to null.\n    if (namespace === '') {\n        namespace = null;\n    }\n    // 2. Validate qualifiedName.\n    validateQualifiedName(qualifiedName);\n    // 3. Let prefix be null.\n    var prefix = null;\n    // 4.  Let localName be qualifiedName.\n    var localName = qualifiedName;\n    // 5. If qualifiedName contains a \":\" (U+003E), then split the string on it and set prefix to\n    // the part before and localName to the part after.\n    var index = qualifiedName.indexOf(':');\n    if (index >= 0) {\n        prefix = qualifiedName.substring(0, index);\n        localName = qualifiedName.substring(index + 1);\n    }\n    // 6. If prefix is non-null and namespace is null, then throw a NamespaceError.\n    if (prefix !== null && namespace === null) {\n        throwNamespaceError('Qualified name with prefix can not have a null namespace');\n    }\n    // 7. If prefix is \"xml\" and namespace is not the XML namespace, then throw a NamespaceError.\n    if (prefix === 'xml' && namespace !== XML_NAMESPACE) {\n        throwNamespaceError('xml prefix can only be used for the XML namespace');\n    }\n    // 8. If either qualifiedName or prefix is \"xmlns\" and namespace is not the XMLNS namespace,\n    // then throw a NamespaceError.\n    if ((qualifiedName === 'xmlns' || prefix === 'xmlns') && namespace !== XMLNS_NAMESPACE) {\n        throwNamespaceError('xmlns prefix or qualifiedName must use the XMLNS namespace');\n    }\n    // 9. If namespace is the XMLNS namespace and neither qualifiedName nor prefix is \"xmlns\", then\n    // throw a NamespaceError.\n    if (namespace === XMLNS_NAMESPACE && qualifiedName !== 'xmlns' && prefix !== 'xmlns') {\n        throwNamespaceError('xmlns prefix or qualifiedName must be used for the XMLNS namespace');\n    }\n    // 10. Return namespace, prefix, and localName.\n    return { namespace: namespace, prefix: prefix, localName: localName };\n}\n/**\n * To locate a namespace prefix for an element using namespace, run these steps:\n *\n * @param element    The element at which to start the lookup\n * @param namespace  Namespace for which to look up the prefix\n *\n * @return The prefix, or null if there isn't one\n */\nexport function locateNamespacePrefix(element, namespace) {\n    // 1. If element’s namespace is namespace and its namespace prefix is not null, then return its\n    // namespace prefix.\n    if (element.namespaceURI === namespace && element.prefix !== null) {\n        return element.prefix;\n    }\n    // 2. If element has an attribute whose namespace prefix is \"xmlns\" and value is namespace, then\n    // return element’s first such attribute’s local name.\n    var attr = Array.from(element.attributes).find(function (attr) { return attr.prefix === 'xmlns' && attr.value === namespace; });\n    if (attr) {\n        return attr.localName;\n    }\n    // 3. If element’s parent element is not null, then return the result of running locate a\n    // namespace prefix on that element using namespace.\n    if (element.parentElement !== null) {\n        return locateNamespacePrefix(element.parentElement, namespace);\n    }\n    // 4. Return null.\n    return null;\n}\n//# sourceMappingURL=namespaceHelpers.js.map","import { XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\n// 3.2.1.1.2 The Namespace Prefix Map\n/**\n * A namespace prefix map is a map that associates namespaceURI and namespace prefix lists, where\n * namespaceURI values are the map's unique keys (which can include the null value representing no\n * namespace), and ordered lists of associated prefix values are the map's key values. The namespace\n * prefix map will be populated by previously seen namespaceURIs and all their previously\n * encountered prefix associations for a given node and its ancestors.\n *\n * NOTE: the last seen prefix for a given namespaceURI is at the end of its respective list. The\n * list is searched to find potentially matching prefixes, and if no matches are found for the given\n * namespaceURI, then the last prefix in the list is used. See copy a namespace prefix map and\n * retrieve a preferred prefix string for additional details.\n */\nvar NamespacePrefixMap = /** @class */ (function () {\n    function NamespacePrefixMap() {\n        this._map = new Map();\n    }\n    /**\n     * To copy a namespace prefix map map means to copy the map's keys into a new empty namespace\n     * prefix map, and to copy each of the values in the namespace prefix list associated with each\n     * keys' value into a new list which should be associated with the respective key in the new\n     * map.\n     *\n     * @return A copy of the namespace prefix map\n     */\n    NamespacePrefixMap.prototype.copy = function () {\n        var copy = new NamespacePrefixMap();\n        // Array.from needed to allow compilation to ES5 targets\n        for (var _i = 0, _a = Array.from(this._map.entries()); _i < _a.length; _i++) {\n            var _b = _a[_i], namespace = _b[0], prefixes = _b[1];\n            copy._map.set(namespace, prefixes.concat());\n        }\n        return copy;\n    };\n    /**\n     * To retrieve a preferred prefix string preferred prefix from the namespace prefix map map\n     * given a namespace ns, the user agent should:\n     *\n     * @param preferredPrefix The prefix to look up\n     * @param ns              The namespace for the prefix\n     *\n     * @return The matching candidate prefix, if found, or null otherwise\n     */\n    NamespacePrefixMap.prototype.retrievePreferredPrefixString = function (preferredPrefix, ns) {\n        // 1. Let candidates list be the result of retrieving a list from map where there exists a\n        // key in map that matches the value of ns or if there is no such key, then stop running\n        // these steps, and return the null value.\n        var candidatesList = this._map.get(ns);\n        if (candidatesList === undefined) {\n            return null;\n        }\n        // 2. Otherwise, for each prefix value prefix in candidates list, iterating from beginning\n        // to end:\n        // NOTE: There will always be at least one prefix value in the list.\n        for (var _i = 0, candidatesList_1 = candidatesList; _i < candidatesList_1.length; _i++) {\n            var prefix = candidatesList_1[_i];\n            // 2.1. If prefix matches preferred prefix, then stop running these steps and return\n            // prefix.\n            if (prefix === preferredPrefix) {\n                return prefix;\n            }\n            // 2.2. If prefix is the last item in the candidates list, then stop running these steps\n            // and return prefix.\n        }\n        return candidatesList[candidatesList.length - 1];\n    };\n    /**\n     * To check if a prefix string prefix is found in a namespace prefix map map given a namespace\n     * ns, the user agent should:\n     *\n     * @param prefix The prefix to check\n     * @param ns     The namespace to check\n     *\n     * @return Whether the combination of prefix and ns is found in the map\n     */\n    NamespacePrefixMap.prototype.checkIfFound = function (prefix, ns) {\n        // 1. Let candidates list be the result of retrieving a list from map where there exists a\n        // key in map that matches the value of ns or if there is no such key, then stop running\n        // these steps, and return false.\n        var candidatesList = this._map.get(ns);\n        if (candidatesList === undefined) {\n            return false;\n        }\n        // If the value of prefix occurs at least once in candidates list, return true, otherwise\n        // return false.\n        return candidatesList.indexOf(prefix) >= 0;\n    };\n    /**\n     * To add a prefix string prefix to the namespace prefix map map given a namespace ns, the user\n     * agent should:\n     *\n     * @param prefix The prefix to add\n     * @param ns     The namespace to add for prefix\n     */\n    NamespacePrefixMap.prototype.add = function (prefix, ns) {\n        // 1. Let candidates list be the result of retrieving a list from map where there exists a\n        // key in map that matches the value of ns or if there is no such key, then let candidates\n        // list be null.\n        // Note: undefined used instead of null for convenience\n        var candidatesList = this._map.get(ns);\n        // 2. If candidates list is null, then create a new list with prefix as the only item in the\n        // list, and associate that list with a new key ns in map.\n        if (candidatesList === undefined) {\n            this._map.set(ns, [prefix]);\n        }\n        else {\n            // 3. Otherwise, append prefix to the end of candidates list.\n            candidatesList.push(prefix);\n        }\n        // NOTE: The steps in retrieve a preferred prefix string use the list to track the most\n        // recently used (MRU) prefix associated with a given namespace, which will be the prefix at\n        // the end of the list. This list may contain duplicates of the same prefix value seen\n        // earlier (and that's OK).\n    };\n    return NamespacePrefixMap;\n}());\nexport { NamespacePrefixMap };\n// 3.2.1.1.1 Recording the namespace\n/**\n * This following algorithm will update the namespace prefix map with any found namespace prefix\n * definitions, add the found prefix definitions to the local prefixes map, and return a local\n * default namespace value defined by a default namespace attribute if one exists. Otherwise it\n * returns null.\n *\n * @param element          Element for which to record namespace information\n * @param map              The namespace prefix map to update\n * @param localPrefixesMap The local prefixes map to update\n *\n * @return The local default namespace value for element, or null if element does not define one\n */\nexport function recordNamespaceInformation(element, map, localPrefixesMap) {\n    // 1. Let default namespace attr value be null.\n    var defaultNamespaceAttrValue = null;\n    // 2. Main: For each attribute attr in element's attributes, in the order they are specified in\n    // the element's attribute list:\n    // NOTE: The following conditional steps find namespace prefixes. Only attributes in the XMLNS\n    // namespace are considered (e.g., attributes made to look like namespace declarations via\n    // setAttribute(\"xmlns:pretend-prefix\", \"pretend-namespace\") are not included).\n    for (var _i = 0, _a = element.attributes; _i < _a.length; _i++) {\n        var attr = _a[_i];\n        // 2.1. Let attribute namespace be the value of attr's namespaceURI value.\n        var attributeNamespace = attr.namespaceURI;\n        // 2.2. Let attribute prefix be the value of attr's prefix.\n        var attributePrefix = attr.prefix;\n        // 2.3. If the attribute namespace is the XMLNS namespace, then:\n        if (attributeNamespace === XMLNS_NAMESPACE) {\n            // 2.3.1. If attribute prefix is null, then attr is a default namespace declaration. Set\n            // the default namespace attr value to attr's value and stop running these steps,\n            // returning to Main to visit the next attribute.\n            if (attributePrefix === null) {\n                defaultNamespaceAttrValue = attr.value;\n                continue;\n            }\n            // 2.3.2. Otherwise, the attribute prefix is not null and attr is a namespace prefix\n            // definition. Run the following steps:\n            // 2.3.2.1. Let prefix definition be the value of attr's localName.\n            var prefixDefinition = attr.localName;\n            // 2.3.2.2. Let namespace definition be the value of attr's value.\n            var namespaceDefinition = attr.value;\n            // 2.3.2.3. If namespace definition is the XML namespace, then stop running these steps,\n            // and return to Main to visit the next attribute.\n            // NOTE: XML namespace definitions in prefixes are completely ignored (in order to avoid\n            // unnecessary work when there might be prefix conflicts). XML namespaced elements are\n            // always handled uniformly by prefixing (and overriding if necessary) the element's\n            // localname with the reserved \"xml\" prefix.\n            if (namespaceDefinition === XML_NAMESPACE) {\n                continue;\n            }\n            // 2.3.2.4. If namespace definition is the empty string (the declarative form of having\n            // no namespace), then let namespace definition be null instead.\n            if (namespaceDefinition === '') {\n                namespaceDefinition = null;\n            }\n            // 2.3.2.5. If prefix definition is found in map given the namespace namespace\n            // definition, then stop running these steps, and return to Main to visit the next\n            // attribute.\n            // NOTE: This step avoids adding duplicate prefix definitions for the same namespace in\n            // the map. This has the side-effect of avoiding later serialization of duplicate\n            // namespace prefix declarations in any descendant nodes.\n            if (map.checkIfFound(prefixDefinition, namespaceDefinition)) {\n                continue;\n            }\n            // 2.3.2.6. Add the prefix prefix definition to map given namespace namespace\n            // definition.\n            map.add(prefixDefinition, namespaceDefinition);\n            // 2.3.2.7. Add the value of prefix definition as a new key to the local prefixes map,\n            // with the namespace definition as the key's value replacing the value of null with the\n            // empty string if applicable.\n            localPrefixesMap[prefixDefinition] =\n                namespaceDefinition === null ? '' : namespaceDefinition;\n        }\n    }\n    // 3. Return the value of default namespace attr value.\n    // NOTE: The empty string is a legitimate return value and is not converted to null.\n    return defaultNamespaceAttrValue;\n}\n//# sourceMappingURL=NamespacePrefixMap.js.map","import { throwInvalidStateError } from '../util/errorHelpers';\nimport { matchesNameProduction, HTML_NAMESPACE, XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\nimport { recordNamespaceInformation, NamespacePrefixMap } from './NamespacePrefixMap';\n/*\n// CHAR_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\nconst Char = regenerate()\n    .add(0x9)\n    .add(0xA)\n    .add(0xD)\n    .addRange(0x20, 0xD7FF)\n    .addRange(0xE000, 0xFFFD)\n    .addRange(0x10000, 0xEFFFF);\n\nreturn `^(${Char.toString()})*$`;\n*/\nvar CHAR_REGEX_XML_1_0_FIFTH_EDITION = /^(?:[\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n/*\n// PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\n// #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]\nconst PubidChar = regenerate()\n    .add(0x20)\n    .add(0xD)\n    .add(0xA)\n    .addRange('a', 'z')\n    .addRange('A', 'Z')\n    .addRange('0', '9')\n    .add(...\"-'()+,./:=?;!*#@$_%\");\n\n`^(${PubidChar.toString()})*$`;\n*/\nvar PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION = /^(?:[\\n\\r !#-%'-;=\\?-Z_a-z])*$/;\nvar HTML_VOID_ELEMENTS = [\n    'area',\n    'base',\n    'basefont',\n    'bgsound',\n    'br',\n    'col',\n    'embed',\n    'frame',\n    'hr',\n    'img',\n    'input',\n    'keygen',\n    'link',\n    'menuitem',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wbr'\n];\n// 3.2. Serializing\n/**\n * The following steps form the fragment serializing algorithm:\n *\n * @param node                The node to serialize\n * @param requireWellFormed   Determines whether the result needs to be well-formed\n * @param withFictionalParent Whether to treat node as a fictional parent with node as its only\n *                            child\n *\n * @return A string representing the serialization of node\n */\nexport function serializeFragment(node, requireWellFormed, withFictionalParent) {\n    // 1. Let context document be the value of node's node document.\n    // 2. If context document is an HTML document, return an HTML serialization of node.\n    // (HTML documents not implemented)\n    if (withFictionalParent === void 0) { withFictionalParent = false; }\n    // 3. Otherwise, context document is an XML document; return an XML serialization of node\n    // passing the flag require well-formed.\n    // Note: if implemented as stated in the spec, this would make innerHTML return the outerHTML\n    // and make outerHTML trigger undefined behavior (the spec doesn't state the type of the\n    // fictional node that acts as a parent). Instead, serialize the children only\n    var childNodes = withFictionalParent ? [node] : node.childNodes;\n    var result = [];\n    for (var _i = 0, childNodes_1 = childNodes; _i < childNodes_1.length; _i++) {\n        var child = childNodes_1[_i];\n        produceXmlSerialization(child, requireWellFormed, result);\n    }\n    return result.join('');\n    // NOTE: The XML serialization defined in this document conforms to the requirements of the XML\n    // fragment serialization algorithm defined in [HTML5].\n}\n/**\n * To produce an XML serialization of a Node node given a flag require well-formed, run the\n * following steps:\n *\n * @param node                The node to serialize\n * @param requireWellFormed   Determines whether the result needs to be well-formed\n * @param result              Array of strings in which to construct the result\n */\nexport function produceXmlSerialization(node, requireWellFormed, result) {\n    // 1. Let namespace be a context namespace with value null. The context namespace tracks the XML\n    // serialization algorithm's current default namespace. The context namespace is changed when\n    // either an Element Node has a default namespace declaration, or the algorithm generates a\n    // default namespace declaration for the Element Node to match its own namespace. The algorithm\n    // assumes no namespace (null) to start.\n    var namespace = null;\n    // 2. Let prefix map be a new namespace prefix map.\n    var prefixMap = new NamespacePrefixMap();\n    // 3. Add the XML namespace with prefix value \"xml\" to prefix map.\n    prefixMap.add('xml', XML_NAMESPACE);\n    // 4. Let prefix index be a generated namespace prefix index with value 1. The generated\n    // namespace prefix index is used to generate a new unique prefix value when no suitable\n    // existing namespace prefix is available to serialize a node's namespaceURI (or the\n    // namespaceURI of one of node's attributes). See the generate a prefix algorithm.\n    var prefixIndex = { value: 1 };\n    // 5. Return the result of running the XML serialization algorithm on node passing the context\n    // namespace namespace, namespace prefix map prefix map, generated namespace prefix index\n    // reference to prefix index, and the flag require well-formed. If an exception occurs during\n    // the execution of the algorithm, then catch that exception and throw an \"InvalidStateError\"\n    // DOMException.\n    try {\n        runXmlSerializationAlgorithm(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n    }\n    catch (error) {\n        return throwInvalidStateError(error.message);\n    }\n}\n/**\n * The XML serialization algorithm produces an XML serialization of an arbitrary DOM node node based\n * on the node's interface type. Each referenced algorithm is to be passed the arguments as they\n * were recieved by the caller and return their result to the caller. Re-throw any exceptions.\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n *\n * @return The serialization of node\n */\nfunction runXmlSerializationAlgorithm(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    // If node's interface is:\n    switch (node.nodeType) {\n        // Element: Run the algorithm for XML serializing an Element node node.\n        case 1 /* ELEMENT_NODE */:\n            serializeElementNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // Document: Run the algorithm for XML serializing a Document node node.\n        case 9 /* DOCUMENT_NODE */:\n            serializeDocumentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // Comment: Run the algorithm for XML serializing a Comment node node.\n        case 8 /* COMMENT_NODE */:\n            serializeCommentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // CDATASection: Run the algorithm for XML serializing a CDATASection node node.\n        // Note: this is currently commented out in the DOM parsing spec, as it is based on the DOM4\n        // spec which removed the CDATASection interface. It seems the interface has been restored\n        // in the DOM living standard, so we'll implement its serialization as specced previously.\n        case 4 /* CDATA_SECTION_NODE */:\n            serializeCDATASectionNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // Text: Run the algorithm for XML serializing a Text node node.\n        case 3 /* TEXT_NODE */:\n            serializeTextNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // DocumentFragment: Run the algorithm for XML serializing a DocumentFragment node node.\n        case 11 /* DOCUMENT_FRAGMENT_NODE */:\n            serializeDocumentFragmentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // DocumentType: Run the algorithm for XML serializing a DocumentType node node.\n        case 10 /* DOCUMENT_TYPE_NODE */:\n            serializeDocumentTypeNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // ProcessingInstruction: Run the algorithm for XML serializing a ProcessingInstruction node\n        // node.\n        case 7 /* PROCESSING_INSTRUCTION_NODE */:\n            serializeProcessingInstructionNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n            return;\n        // An Attr object: Return an empty string.\n        case 2 /* ATTRIBUTE_NODE */:\n            return;\n        // Anything else: Throw a TypeError. Only Nodes and Attr objects can be serialized by this\n        // algorithm.\n        // (not reachable from public API)\n        /* istanbul ignore next */\n        default:\n            throw new TypeError('Only Nodes and Attr objects can be serialized by this algorithm.');\n    }\n}\n/**\n * 3.2.1.1 XML serializing an Element node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeElementNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var element = node;\n    // If the require well-formed flag is set (its value is true), and this node's localName\n    // attribute contains the character \":\" (U+003A COLON) or does not match the XML Name\n    // production, then throw an exception; the serialization of this node would not be a\n    // well-formed element.\n    if (requireWellFormed &&\n        (element.localName.indexOf(':') >= 0 || !matchesNameProduction(element.localName))) {\n        throw new Error('The serialization of this node would not be a well-formed element');\n    }\n    // 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n    result.push('<');\n    // 3. Let qualified name be an empty string.\n    var qualifiedName = '';\n    // 4. Let skip end tag be a boolean flag with value false.\n    var skipEndTag = false;\n    // 5. Let ignore namespace definition attribute be a boolean flag with value false.\n    var ignoreNamespaceDefinitionAttribute = false;\n    // 6. Given prefix map, copy a namespace prefix map and let map be the result.\n    var map = prefixMap.copy();\n    // 7. Let local prefixes map be an empty map. The map has unique Node prefix strings as its\n    // keys, with corresponding namespaceURI Node values as the map's key values (in this map, the\n    // null namespace is represented by the empty string).\n    // NOTE: This map is local to each element. It is used to ensure there are no conflicting\n    // prefixes should a new namespace prefix attribute need to be generated. It is also used to\n    // enable skipping of duplicate prefix definitions when writing an element's attributes: the map\n    // allows the algorithm to distinguish between a prefix in the namespace prefix map that might\n    // be locally-defined (to the current Element) and one that is not.\n    var localPrefixesMap = {};\n    // 8. Let local default namespace be the result of recording the namespace information for node\n    // given map and local prefixes map.\n    // NOTE: The above step will update map with any found namespace prefix definitions, add the\n    // found prefix definitions to the local prefixes map and return a local default namespace value\n    // defined by a default namespace attribute if one exists. Otherwise it returns null.\n    var localDefaultNamespace = recordNamespaceInformation(element, map, localPrefixesMap);\n    // 9. Let inherited ns be a copy of namespace.\n    var inheritedNs = namespace;\n    // 10. Let ns be the value of node's namespaceURI attribute.\n    var ns = element.namespaceURI;\n    // 11. If inherited ns is equal to ns, then:\n    if (inheritedNs === ns) {\n        // 11.1. If local default namespace is not null, then set ignore namespace definition\n        // attribute to true.\n        if (localDefaultNamespace !== null) {\n            ignoreNamespaceDefinitionAttribute = true;\n        }\n        // 11.2. If ns is the XML namespace, then append to qualified name the concatenation of the\n        // string \"xml:\" and the value of node's localName.\n        if (ns === XML_NAMESPACE) {\n            qualifiedName += 'xml:' + element.localName;\n        }\n        else {\n            // 11.3. Otherwise, append to qualified name the value of node's localName. The node's\n            // prefix if it exists, is dropped.\n            qualifiedName += element.localName;\n        }\n        // 11.4. Append the value of qualified name to markup.\n        result.push(qualifiedName);\n    }\n    else {\n        // 12. Otherwise, inherited ns is not equal to ns (the node's own namespace is different\n        // from the context namespace of its parent). Run these sub-steps:\n        // 12.1. Let prefix be the value of node's prefix attribute.\n        var prefix = element.prefix;\n        // 12.2. Let candidate prefix be the result of retrieving a preferred prefix string prefix\n        // from map given namespace ns.\n        // NOTE: The above may return null if no namespace key ns exists in map.\n        var candidatePrefix = map.retrievePreferredPrefixString(prefix, ns);\n        // 12.3. If the value of prefix matches \"xmlns\", then run the following steps:\n        if (prefix === 'xmlns') {\n            // 12.3.1. If the require well-formed flag is set, then throw an error. An Element with\n            // prefix \"xmlns\" will not legally round-trip in a conforming XML parser.\n            if (requireWellFormed) {\n                throw new Error('An Element with prefix \"xmlns\" will not legally round-trip in a conforming ' +\n                    'XML parser');\n            }\n            // 12.3.2. Let candidate prefix be the value of prefix.\n            candidatePrefix = prefix;\n        }\n        // 12.4. Found a suitable namespace prefix: if candidate prefix is not null (a namespace\n        // prefix is defined which maps to ns), then:\n        if (candidatePrefix !== null) {\n            // NOTE: The following may serialize a different prefix than the Element's existing\n            // prefix if it already had one. However, the retrieving a preferred prefix string\n            // algorithm already tried to match the existing prefix if possible.\n            // 12.4.1. Append to qualified name the concatenation of candidate prefix, \":\" (U+003A\n            // COLON), and node's localName. There exists on this node or the node's ancestry a\n            // namespace prefix definition that defines the node's namespace.\n            qualifiedName += candidatePrefix + ':' + element.localName;\n            // 12.4.2. If the local default namespace is not null (there exists a locally-defined\n            // default namespace declaration attribute) and its value is not the XML namespace, then\n            // let inherited ns get the value of local default namespace unless the local default\n            // namespace is the empty string in which case let it get null (the context namespace is\n            // changed to the declared default, rather than this node's own namespace).\n            // NOTE: Any default namespace definitions or namespace prefixes that define the XML\n            // namespace are omitted when serializing this node's attributes.\n            if (localDefaultNamespace !== null && localDefaultNamespace !== XML_NAMESPACE) {\n                inheritedNs = localDefaultNamespace === '' ? null : localDefaultNamespace;\n            }\n            // 12.4.3. Append the value of qualified name to markup.\n            result.push(qualifiedName);\n        }\n        else if (prefix !== null) {\n            // 12.5. Otherwise, if prefix is not null, then:\n            // NOTE: By this step, there is no namespace or prefix mapping declaration in this node\n            // (or any parent node visited by this algorithm) that defines prefix otherwise the step\n            // labelled Found a suitable namespace prefix would have been followed. The sub-steps\n            // that follow will create a new namespace prefix declaration for prefix and ensure that\n            // prefix does not conflict with an existing namespace prefix declaration of the same\n            // localName in node's attribute list.\n            // 12.5.1. If the local prefixes map contains a key matching prefix, then let prefix be\n            // the result of generating a prefix providing as input map, ns, and prefix index.\n            if (prefix in localPrefixesMap) {\n                prefix = generatePrefix(map, ns, prefixIndex);\n            }\n            // 12.5.2. Add prefix to map given namespace ns.\n            map.add(prefix, ns);\n            // 12.5.3. Append to qualified name the concatenation of prefix, \":\" (U+003A COLON), and\n            // node's localName.\n            qualifiedName += prefix + ':' + element.localName;\n            // 12.5.4. Append the value of qualified name to markup.\n            result.push(qualifiedName);\n            // 12.5.5. Append the following to markup, in the order listed:\n            // NOTE: The following serializes a namespace prefix declaration for prefix which was\n            // just added to the map.\n            // 12.5.5.1. \" \" (U+0020 SPACE);\n            // 12.5.5.2. The string \"xmlns:\";\n            // 12.5.5.3. The value of prefix;\n            // 12.5.5.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n            // 12.5.5.5. The result of serializing an attribute value given ns and the require\n            // well-formed flag as input;\n            // 12.5.5.6. \"\"\" (U+0022 QUOTATION MARK).\n            result.push(' xmlns:', prefix, '=\"', serializeAttributeValue(ns, requireWellFormed), '\"');\n            // 12.5.5.7. If local default namespace is not null (there exists a locally-defined\n            // default namespace declaration attribute), then let inherited ns get the value of\n            // local default namespace unless the local default namespace is the empty string in\n            // which case let it get null.\n            if (localDefaultNamespace !== null) {\n                inheritedNs = localDefaultNamespace === '' ? null : localDefaultNamespace;\n            }\n        }\n        else if (localDefaultNamespace === null ||\n            (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {\n            // 12.6. Otherwise, if local default namespace is null, or local default namespace is\n            // not null and its value is not equal to ns, then:\n            // NOTE: At this point, the namespace for this node still needs to be serialized, but\n            // there's no prefix (or candidate prefix) availble; the following uses the default\n            // namespace declaration to define the namespace --optionally replacing an existing\n            // default declaration if present.\n            // 12.6.1. Set the ignore namespace definition attribute flag to true.\n            ignoreNamespaceDefinitionAttribute = true;\n            // 12.6.2. Append to qualified name the value of node's localName.\n            qualifiedName += element.localName;\n            // 12.6.3. Let the value of inherited ns be ns.\n            // NOTE: The new default namespace will be used in the serialization to define this\n            // node's namespace and act as the context namespace for its children.\n            inheritedNs = ns;\n            // 12.6.4. Append the value of qualified name to markup.\n            result.push(qualifiedName);\n            // 12.6.5. Append the following to markup, in the order listed:\n            // NOTE: The following serializes the new (or replacement) default namespace definition.\n            // 12.6.5.1. \" \" (U+0020 SPACE);\n            // 12.6.5.2. The string \"xmlns\";\n            // 12.6.5.3. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n            // 12.6.5.4. The result of serializing an attribute value given ns and the require\n            // well-formed flag as input;\n            // 12.6.5.5. \"\"\" (U+0022 QUOTATION MARK).\n            result.push(' xmlns=\"', serializeAttributeValue(ns, requireWellFormed), '\"');\n        }\n        else {\n            // 12.7. Otherwise, the node has a local default namespace that matches ns. Append to\n            // qualified name the value of node's localName, let the value of inherited ns be ns,\n            // and append the value of qualified name to markup.\n            qualifiedName += element.localName;\n            inheritedNs = ns;\n            result.push(qualifiedName);\n        }\n        // NOTE: All of the combinations where ns is not equal to inherited ns are handled above\n        // such that node will be serialized preserving its original namespaceURI.\n    }\n    // 13. Append to markup the result of the XML serialization of node's attributes given map,\n    // prefix index, local prefixes map, ignore namespace definition attribute flag, and require\n    // well-formed flag.\n    serializeAttributes(element, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, result);\n    // 14. If ns is the HTML namespace, and the node's list of children is empty, and the node's\n    // localName matches any one of the following void elements: \"area\", \"base\", \"basefont\",\n    // \"bgsound\", \"br\", \"col\", \"embed\", \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\",\n    // \"meta\", \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup, in the order\n    // listed:\n    if (ns === HTML_NAMESPACE &&\n        !element.hasChildNodes() &&\n        HTML_VOID_ELEMENTS.indexOf(element.localName) >= 0) {\n        // 14.1. \" \" (U+0020 SPACE);\n        // 14.2. \"/\" (U+002F SOLIDUS).\n        result.push(' /');\n        // and set the skip end tag flag to true.\n        skipEndTag = true;\n    }\n    // 15. If ns is not the HTML namespace, and the node's list of children is empty, then append\n    // \"/\" (U+002F SOLIDUS) to markup and set the skip end tag flag to true.\n    if (ns !== HTML_NAMESPACE && !element.hasChildNodes()) {\n        result.push('/');\n        skipEndTag = true;\n    }\n    // 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n    result.push('>');\n    // 17. If the value of skip end tag is true, then return the value of markup and skip the\n    // remaining steps. The node is a leaf-node.\n    if (skipEndTag) {\n        return;\n    }\n    // 18. If ns is the HTML namespace, and the node's localName matches the string \"template\", then\n    // this is a template element. Append to markup the result of XML serializing a DocumentFragment\n    // node given the template element's template contents (a DocumentFragment), providing inherited\n    // ns, map, prefix index, and the require well-formed flag.\n    // NOTE: This allows template content to round-trip , given the rules for parsing XHTML\n    // documents.\n    // (HTML documents not implemented)\n    // 19. Otherwise, append to markup the result of running the XML serialization algorithm on each\n    // of node's children, in tree order, providing inherited ns, map, prefix index, and the require\n    // well-formed flag.\n    for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {\n        var child = _a[_i];\n        runXmlSerializationAlgorithm(child, inheritedNs, map, prefixIndex, requireWellFormed, result);\n    }\n    // 20. Append the following to markup, in the order listed:\n    // 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n    // 20.2. The value of qualified name;\n    // 20.3. \">\" (U+003E GREATER-THAN SIGN).\n    result.push('</', qualifiedName, '>');\n    // 21. Return the value of markup.\n}\n// 3.2.1.1.3 Serializing an Element's attributes\n/**\n * The XML serialization of the attributes of an Element element together with a namespace prefix\n * map map, a generated namespace prefix index prefix index reference, a local prefixes map, a\n * ignore namespace definition attribute flag, and a require well-formed flag, is the result of the\n * following algorithm:\n *\n * @param element                            The element for which to serialize attributes\n * @param prefixMap                          The namespace prefix map\n * @param prefixIndex                        The generated namespace prefix index, by reference\n * @param localPrefixesMap                   The local prefixes map\n * @param ignoreNamespaceDefinitionAttribute The ignore namespace definition attribute flag\n * @param requireWellFormed                  The require well-formed flag\n * @param result                             Array of strings in which to construct the result\n */\nfunction serializeAttributes(element, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed, result) {\n    // 1. Let result be the empty string.\n    // (result constructed in-place in argument)\n    // 2. Let localname set be a new empty namespace localname set. This localname set will contain\n    // tuples of unique attribute namespaceURI and localName pairs, and is populated as each attr is\n    // processed. This set is used to [optionally] enforce the well-formed constraint that an\n    // element cannot have two attributes with the same namespaceURI and localName. This can occur\n    // when two otherwise identical attributes on the same element differ only by their prefix\n    // values.\n    var localNameSet = [];\n    var _loop_1 = function (attr) {\n        // 3.1. If the require well-formed flag is set (its value is true), and the localname set\n        // contains a tuple whose values match those of a new tuple consisting of attr's\n        // namespaceURI attribute and localName attribute, then throw an exception; the\n        // serialization of this attr would fail to produce a well-formed element serialization.\n        if (requireWellFormed &&\n            localNameSet.find(function (tuple) {\n                return tuple.localName === attr.localName && tuple.namespaceURI === attr.namespaceURI;\n            })) {\n            throw new Error('The serialization of this attr would fail to produce a well-formed element ' +\n                'serialization');\n        }\n        // 3.2. Create a new tuple consisting of attr's namespaceURI attribute and localName\n        // attribute, and add it to the localname set.\n        localNameSet.push({ namespaceURI: attr.namespaceURI, localName: attr.localName });\n        // 3.3. Let attribute namespace be the value of attr's namespaceURI value.\n        var attributeNamespace = attr.namespaceURI;\n        // 3.4. Let candidate prefix be null.\n        var candidatePrefix = null;\n        // 3.5. If attribute namespace is not null, then run these sub-steps:\n        if (attributeNamespace !== null) {\n            // 3.5.1. Let candidate prefix be the result of retrieving a preferred prefix string\n            // from map given namespace attribute namespace with preferred prefix being attr's\n            // prefix value.\n            candidatePrefix = map.retrievePreferredPrefixString(attr.prefix, attributeNamespace);\n            // 3.5.2. If the value of attribute namespace is the XMLNS namespace, then run these\n            // steps:\n            if (attributeNamespace === XMLNS_NAMESPACE) {\n                // 3.5.2.1. If any of the following are true, then stop running these steps and goto\n                // Loop to visit the next attribute:\n                // - the attr's value is the XML namespace;\n                // NOTE: The XML namespace cannot be redeclared and survive round-tripping (unless\n                // it defines the prefix \"xml\"). To avoid this problem, this algorithm always\n                // prefixes elements in the XML namespace with \"xml\" and drops any related\n                // definitions as seen in the above condition.\n                if (attr.value === XML_NAMESPACE) {\n                    return \"continue\";\n                }\n                // - the attr's prefix is null and the ignore namespace definition attribute flag is\n                // true (the Element's default namespace attribute should be skipped);\n                if (attr.prefix === null && ignoreNamespaceDefinitionAttribute) {\n                    return \"continue\";\n                }\n                // - the attr's prefix is not null and either\n                //   - the attr's localName is not a key contained in the local prefixes map, or\n                //   - the attr's localName is present in the local prefixes map but the value of\n                //     the key does not match attr's value\n                if (attr.prefix !== null &&\n                    (!(attr.localName in localPrefixesMap) ||\n                        localPrefixesMap[attr.localName] !== attr.value)) {\n                    return \"continue\";\n                }\n                // 3.5.2.2. If the require well-formed flag is set (its value is true), and the\n                // value of attr's value attribute matches the XMLNS namespace, then throw an\n                // exception; the serialization of this attribute would produce invalid XML because\n                // the XMLNS namespace is reserved and cannot be applied as an element's namespace\n                // via XML parsing.\n                // NOTE: DOM APIs do allow creation of elements in the XMLNS namespace but with\n                // strict qualifications.\n                if (requireWellFormed && attr.value === XMLNS_NAMESPACE) {\n                    throw new Error('The serialization of this attribute would produce invalid XML because ' +\n                        'the XMLNS namespace is reserved and cannot be applied as an ' +\n                        \"element's namespace via XML parsing\");\n                }\n                // 3.5.2.3. If the require well-formed flag is set (its value is true), and the\n                // value of attr's value attribute is the empty string, then throw an exception;\n                // namespace prefix declarations cannot be used to undeclare a namespace (use a\n                // default namespace declaration instead).\n                if (requireWellFormed && attr.value === '') {\n                    throw new Error('Namespace prefix declarations cannot be used to undeclare a namespace ' +\n                        '(use a default namespace declaration instead)');\n                }\n                // 3.5.2.4. the attr's prefix matches the string \"xmlns\", then let candidate prefix\n                // be the string \"xmlns\".\n                if (attr.prefix === 'xmlns') {\n                    candidatePrefix = 'xmlns';\n                }\n            }\n            else {\n                // 3.5.3. Otherwise, the attribute namespace in not the XMLNS namespace. Run these\n                // steps:\n                // Note: we deviate from the spec here, as implementing as specified would generate\n                // prefixes for all namespaced attributes.\n                if (candidatePrefix === null) {\n                    if (attr.prefix === null || attr.prefix in localPrefixesMap) {\n                        // 3.5.3.1. Let candidate prefix be the result of generating a prefix\n                        // providing map, attribute namespace, and prefix index as input.\n                        candidatePrefix = generatePrefix(map, attributeNamespace, prefixIndex);\n                    }\n                    else {\n                        candidatePrefix = attr.prefix;\n                    }\n                    // Update the local and aggregate prefixes to account for the new declaration.\n                    map.add(candidatePrefix, attr.namespaceURI);\n                    localPrefixesMap[candidatePrefix] = attr.namespaceURI;\n                    // 3.5.3.2. Append the following to result, in the order listed:\n                    // 3.5.3.2.1. \" \" (U+0020 SPACE);\n                    // 3.5.3.2.2. The string \"xmlns:\";\n                    // 3.5.3.2.3. The value of candidate prefix;\n                    // 3.5.3.2.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n                    // 3.5.3.2.5. The result of serializing an attribute value given attribute\n                    // namespace and the require well-formed flag as input;\n                    // 3.5.3.2.7. \"\"\" (U+0022 QUOTATION MARK).\n                    result.push(' xmlns:', candidatePrefix, '=\"', serializeAttributeValue(attributeNamespace, requireWellFormed), '\"');\n                }\n            }\n        }\n        // 3.6. Append a \" \" (U+0020 SPACE) to result.\n        result.push(' ');\n        // 3.7. If candidate prefix is not null, then append to result the concatenation of\n        // candidate prefix with \":\" (U+003A COLON).\n        if (candidatePrefix !== null) {\n            result.push(candidatePrefix, ':');\n        }\n        // 3.8. If the require well-formed flag is set (its value is true), and this attr's\n        // localName attribute contains the character \":\" (U+003A COLON) or does not match the XML\n        // Name production or equals \"xmlns\" and attribute namespace is null, then throw an\n        // exception; the serialization of this attr would not be a well-formed attribute.\n        if (requireWellFormed &&\n            (attr.localName.indexOf(':') >= 0 ||\n                !matchesNameProduction(attr.localName) ||\n                (attr.localName === 'xmlns' && attributeNamespace === null))) {\n            throw new Error('The serialization of this attr would not be a well-formed attribute');\n        }\n        // 3.9. Append the following strings to result, in the order listed:\n        // 3.9.1. The value of attr's localName;\n        // 3.9.2. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n        // 3.9.3. The result of serializing an attribute value given attr's value attribute and the\n        // require well-formed flag as input;\n        // 3.9.4. \"\"\" (U+0022 QUOTATION MARK).\n        result.push(attr.localName, '=\"', serializeAttributeValue(attr.value, requireWellFormed), '\"');\n    };\n    // 3. Loop: For each attribute attr in element's attributes, in the order they are specified in\n    // the element's attribute list:\n    for (var _i = 0, _a = element.attributes; _i < _a.length; _i++) {\n        var attr = _a[_i];\n        _loop_1(attr);\n    }\n    // 4. Return the value of result.\n}\n/**\n * When serializing an attribute value given an attribute value and require well-formed flag, the\n * user agent must run the following steps:\n *\n * @param attributeValue    The attribute value to serialize\n * @param requireWellFormed Determines whether the result needs to be well-formed\n *\n * @return The serialized attribute value\n */\nfunction serializeAttributeValue(attributeValue, requireWellFormed) {\n    // 1. If the require well-formed flag is set (its value is true), and attribute value contains\n    // characters that are not matched by the XML Char production, then throw an exception; the\n    // serialization of this attribute value would fail to produce a well-formed element\n    // serialization.\n    if (requireWellFormed &&\n        attributeValue !== null &&\n        !CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(attributeValue)) {\n        throw new Error('The serialization of this attribute value would fail to produce a well-formed ' +\n            'element serialization');\n    }\n    // 2. If attribute value is null, then return the empty string.\n    if (attributeValue === null) {\n        return '';\n    }\n    // 3. Otherwise, attribute value is a string. Return the value of attribute value, first\n    // replacing any occurrences of the following:\n    return (attributeValue\n        // 3.1. \"&\" with \"&amp;\"\n        .replace(/&/g, '&amp;')\n        // 3.2. \"\"\" with \"&quot;\"\n        .replace(/\"/g, '&quot;')\n        // 3.3. \"<\" with \"&lt;\"\n        .replace(/</g, '&lt;')\n        // 3.4. \">\" with \"&gt;\"\n        .replace(/>/g, '&gt;'));\n    // NOTE: This matches behavior present in browsers, and goes above and beyond the grammar\n    // requirement in the XML specification's AttValue production by also replacing \">\" characters.\n}\n// 3.2.1.1.4 Generating namespace prefixes\n/**\n * To generate a prefix given a namespace prefix map map, a string new namespace, and a reference to\n * a generated namespace prefix index prefix index, the user agent must run the following steps:\n *\n * @param map          The namespace prefix map\n * @param newNamespace The new namespace to generate a prefix for\n * @param prefixIndex  The reference to the generated namespace prefix index\n *\n * @return The generated prefix for the new namespace\n */\nfunction generatePrefix(map, newNamespace, prefixIndex) {\n    // 1. Let generated prefix be the concatenation of the string \"ns\" and the current numerical\n    // value of prefix index.\n    var generatedPrefix = 'ns' + prefixIndex.value;\n    // 2. Let the value of prefix index be incremented by one.\n    prefixIndex.value += 1;\n    // 3. Add to map the generated prefix given the new namespace namespace.\n    map.add(generatedPrefix, newNamespace);\n    // 4. Return the value of generated prefix.\n    return generatedPrefix;\n}\n/**\n * 3.2.1.2 XML serializing a Document node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeDocumentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var document = node;\n    // 1. If the require well-formed flag is set (its value is true), and this node has no\n    // documentElement (the documentElement attribute's value is null), then throw an exception; the\n    // serialization of this node would not be a well-formed document.\n    if (requireWellFormed && document.documentElement === null) {\n        throw new Error('The serialization of this node would not be a well-formed document');\n    }\n    // 2. Otherwise, run the following steps:\n    // 2.1. Let serialized document be an empty string.\n    // (constructed in-place in result argument)\n    // 2.2. For each child child of node, in tree order, run the XML serialization algorithm on the\n    // child passing along the provided arguments, and append the result to serialized document.\n    // NOTE: This will serialize any number of ProcessingInstruction and Comment nodes both before\n    // and after the Document's documentElement node, including at most one DocumentType node. (Text\n    // nodes are not allowed as children of the Document.)\n    for (var _i = 0, _a = document.childNodes; _i < _a.length; _i++) {\n        var child = _a[_i];\n        runXmlSerializationAlgorithm(child, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n    }\n    // 2.3. Return the value of serialized document.\n}\n/**\n * 3.2.1.3 XML serializing a Comment node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeCommentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var comment = node;\n    // 1. If the require well-formed flag is set (its value is true), and node's data contains\n    // characters that are not matched by the XML Char production or contains \"--\" (two adjacent\n    // U+002D HYPHEN-MINUS characters) or that ends with a \"-\" (U+002D HYPHEN-MINUS) character, then\n    // throw an exception; the serialization of this node's data would not be well-formed.\n    if (requireWellFormed &&\n        (!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(comment.data) ||\n            comment.data.indexOf('--') >= 0 ||\n            comment.data.endsWith('-'))) {\n        throw new Error(\"The serialization of this node's data would not be well-formed\");\n    }\n    // 2. Otherwise, return the concatenation of \"<!--\", node's data, and \"-->\".\n    result.push('<!--', comment.data, '-->');\n}\n/**\n * (not currently in spec) XML serializing a CDATASection node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeCDATASectionNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var cs = node;\n    // 1. Let markup be the concatenation of \"<![CDATA[\", node's data, and \"]]>\".\n    result.push('<![CDATA[', cs.data, ']]>');\n    // 2. Return the value of markup.\n}\n/**\n * 3.2.1.4 XML serializing a Text node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeTextNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var text = node;\n    // 1. If the require well-formed flag is set (its value is true), and node's data contains\n    // characters that are not matched by the XML Char production, then throw an exception; the\n    // serialization of this node's data would not be well-formed.\n    if (requireWellFormed && !CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(text.data)) {\n        throw new Error(\"The serialization of this node's data would not be well-formed\");\n    }\n    // 2. Let markup be the value of node's data.\n    var markup = text.data;\n    // 3. Replace any occurrences of \"&\" in markup by \"&amp;\".\n    markup = markup.replace(/&/g, '&amp;');\n    // 4. Replace any occurrences of \"<\" in markup by \"&lt;\".\n    markup = markup.replace(/</g, '&lt;');\n    // 5. Replace any occurrences of \">\" in markup by \"&gt;\".\n    markup = markup.replace(/>/g, '&gt;');\n    // 6. Return the value of markup.\n    result.push(markup);\n}\n/**\n * 3.2.1.5 XML serializing a DocumentFragment node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeDocumentFragmentNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    // 1. Let markup the empty string.\n    // (constructed in-place in result argument)\n    // 2. For each child child of node, in tree order, run the XML serialization algorithm on the\n    // child given namespace, prefix map, a reference to prefix index, and flag require well-formed.\n    // Concatenate the result to markup.\n    for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {\n        var child = _a[_i];\n        runXmlSerializationAlgorithm(child, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n    }\n    // 3. Return the value of markup.\n}\n/**\n * 3.2.1.6 XML serializing a DocumentType node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeDocumentTypeNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var dt = node;\n    // 1. If the require well-formed flag is true and the node's publicId attribute contains\n    // characters that are not matched by the XML PubidChar production, then throw an exception; the\n    // serialization of this node would not be a well-formed document type declaration.\n    if (requireWellFormed && !PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION.test(dt.publicId)) {\n        throw new Error('The serialization of this node would not be a well-formed document type declaration');\n    }\n    // 2. If the require well-formed flag is true and the node's systemId attribute contains\n    // characters that are not matched by the XML Char production or that contains both a \"\"\"\n    // (U+0022 QUOTATION MARK) and a \"'\" (U+0027 APOSTROPHE), then throw an exception; the\n    // serialization of this node would not be a well-formed document type declaration.\n    if (requireWellFormed &&\n        (!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(dt.systemId) ||\n            (dt.systemId.indexOf('\"') >= 0 && dt.systemId.indexOf(\"'\") >= 0))) {\n        throw new Error('The serialization of this node would not be a well-formed document type declaration');\n    }\n    // 3. Let markup be an empty string.\n    // (constructed in-place in result argument)\n    // 4. Append the string \"<!DOCTYPE\" to markup.\n    result.push('<!DOCTYPE');\n    // 5. Append \" \" (U+0020 SPACE) to markup.\n    result.push(' ');\n    // 6. Append the value of the node's name attribute to markup. For a node belonging to an HTML\n    // document, the value will be all lowercase.\n    // (HTML documents not implemented)\n    result.push(dt.name);\n    // 7. If the node's publicId is not the empty string then append the following, in the order\n    // listed, to markup:\n    if (dt.publicId !== '') {\n        // 7.1. \" \" (U+0020 SPACE);\n        // 7.2. The string \"PUBLIC\";\n        // 7.3. \" \" (U+0020 SPACE);\n        // 7.4. \"\"\" (U+0022 QUOTATION MARK);\n        // 7.5. The value of the node's publicId attribute;\n        // 7.6. \"\"\" (U+0022 QUOTATION MARK).\n        result.push(' PUBLIC \"', dt.publicId, '\"');\n    }\n    // 8. If the node's systemId is not the empty string and the node's publicId is set to the empty\n    // string, then append the following, in the order listed, to markup:\n    if (dt.systemId !== '' && dt.publicId === '') {\n        // 8.1. \" \" (U+0020 SPACE);\n        // 8.2. The string \"SYSTEM\".\n        result.push(' SYSTEM');\n    }\n    // 9. If the node's systemId is not the empty string then append the following, in the order\n    // listed, to markup:\n    if (dt.systemId !== '') {\n        // 9.1. \" \" (U+0020 SPACE);\n        // 9.2. \"\"\" (U+0022 QUOTATION MARK);\n        // 9.3. The value of the node's systemId attribute;\n        // 9.4. \"\"\" (U+0022 QUOTATION MARK).\n        result.push(' \"', dt.systemId, '\"');\n    }\n    // 10. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n    result.push('>');\n    // 11. Return the value of markup.\n}\n/**\n * 3.2.1.7 XML serializing a ProcessingInstruction node\n *\n * @param node              The node to serializer\n * @param namespace         The context namespace\n * @param prefixMap         The namespace prefix map\n * @param prefixIndex       A reference to the generated namespace prefix index\n * @param requireWellFormed Determines whether the result needs to be well-formed\n * @param result            Array of strings in which to construct the result\n */\nfunction serializeProcessingInstructionNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result) {\n    var pi = node;\n    // 1. If the require well-formed flag is set (its value is true), and node's target contains a\n    // \":\" (U+003A COLON) character or is an ASCII case-insensitive match for the string \"xml\", then\n    // throw an exception; the serialization of this node's target would not be well-formed.\n    if (requireWellFormed && (pi.target.indexOf(':') >= 0 || pi.target.toLowerCase() === 'xml')) {\n        throw new Error(\"The serialization of this node's target would not be well-formed\");\n    }\n    // 2. If the require well-formed flag is set (its value is true), and node's data contains\n    // characters that are not matched by the XML Char production or contains the string \"?>\"\n    // (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN), then throw an exception; the serialization\n    // of this node's data would not be well-formed.\n    if (requireWellFormed &&\n        (!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(pi.data) || pi.data.indexOf('?>') >= 0)) {\n        throw new Error(\"The serialization of this node's data would not be well-formed\");\n    }\n    // 3. Let markup be the concatenation of the following, in the order listed:\n    // 3.1. \"<?\" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);\n    // 3.2. The value of node's target;\n    // 3.3. \" \" (U+0020 SPACE);\n    // 3.4. The value of node's data;\n    // 3.5. \"?>\" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).\n    result.push('<?', pi.target, ' ', pi.data, '?>');\n    // 4. Return the value of markup.\n}\n//# sourceMappingURL=serializationAlgorithms.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getChildren, getPreviousElementSibling, getNextElementSibling } from './mixins';\nimport Attr from './Attr';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { serializeFragment } from './dom-parsing/serializationAlgorithms';\nimport { appendAttribute, changeAttribute, removeAttribute, replaceAttribute } from './util/attrMutations';\nimport { expectArity, throwInUseAttributeError, throwInvalidCharacterError, throwNotFoundError } from './util/errorHelpers';\nimport { matchesNameProduction, validateAndExtract, locateNamespacePrefix, XMLNS_NAMESPACE } from './util/namespaceHelpers';\nimport { asNullableString, asObject } from './util/typeHelpers';\n/**\n * 3.9. Interface Element\n */\nvar Element = /** @class */ (function (_super) {\n    __extends(Element, _super);\n    /**\n     * (non-standard) Use Document#createElement or Document#createElementNS to create an Element.\n     *\n     * @param namespace Namespace for the element\n     * @param prefix    Prefix for the element\n     * @param localName Local name for the element\n     */\n    function Element(namespace, prefix, localName) {\n        var _this = _super.call(this) || this;\n        _this.firstElementChild = null;\n        _this.lastElementChild = null;\n        _this.childElementCount = 0;\n        /**\n         * The attributes for the element.\n         *\n         * Non-standard: the spec defines this as a NamedNodeMap, while this implementation uses an\n         * array.\n         */\n        _this.attributes = [];\n        _this.namespaceURI = namespace;\n        _this.prefix = prefix;\n        _this.localName = localName;\n        _this.tagName = prefix === null ? localName : prefix + \":\" + localName;\n        return _this;\n    }\n    Object.defineProperty(Element.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 1 /* ELEMENT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"nodeName\", {\n        get: function () {\n            return this.tagName;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"nodeValue\", {\n        get: function () {\n            return null;\n        },\n        set: function (newValue) {\n            // Do nothing.\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Element.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        namespace = asNullableString(namespace);\n        // 1. If namespace is null or the empty string, then return null.\n        if (namespace === null || namespace === '') {\n            return null;\n        }\n        // 2. Switch on the context object:\n        // Element - Return the result of locating a namespace prefix for it using namespace.\n        return locateNamespacePrefix(this, namespace);\n    };\n    Element.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        prefix = asNullableString(prefix);\n        // 1. If prefix is the empty string, then set it to null.\n        if (prefix === '') {\n            prefix = null;\n        }\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: Element\n        // 1. If its namespace is not null and its namespace prefix is prefix, then return\n        // namespace.\n        if (this.namespaceURI !== null && this.prefix === prefix) {\n            return this.namespaceURI;\n        }\n        // 2. If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is\n        // \"xmlns\", and local name is prefix, or if prefix is null and it has an attribute whose\n        // namespace is the XMLNS namespace, namespace prefix is null, and local name is \"xmlns\",\n        // then return its value if it is not the empty string, and null otherwise.\n        var ns = null;\n        if (prefix !== null) {\n            var attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, prefix);\n            if (attr && attr.prefix === 'xmlns') {\n                ns = attr.value;\n            }\n        }\n        else {\n            var attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, 'xmlns');\n            if (attr && attr.prefix === null) {\n                ns = attr.value;\n            }\n        }\n        if (ns !== null) {\n            return ns !== '' ? ns : null;\n        }\n        // 3. If its parent element is null, then return null.\n        var parentElement = this.parentElement;\n        if (parentElement === null) {\n            return null;\n        }\n        // 4. Return the result of running locate a namespace on its parent element using prefix.\n        return parentElement.lookupNamespaceURI(prefix);\n    };\n    Object.defineProperty(Element.prototype, \"children\", {\n        // ParentNode\n        get: function () {\n            return getChildren(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"previousElementSibling\", {\n        // NonDocumentTypeChildNode\n        get: function () {\n            return getPreviousElementSibling(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"nextElementSibling\", {\n        get: function () {\n            return getNextElementSibling(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns whether the element has any attributes.\n     *\n     * @return True if the element has attributes, otherwise false\n     */\n    Element.prototype.hasAttributes = function () {\n        return this.attributes.length > 0;\n    };\n    /**\n     * Get the value of the specified attribute.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     *\n     * @return The value of the attribute, or null if no such attribute exists\n     */\n    Element.prototype.getAttribute = function (qualifiedName) {\n        expectArity(arguments, 1);\n        qualifiedName = String(qualifiedName);\n        // 1. Let attr be the result of getting an attribute given qualifiedName and the context\n        // object.\n        var attr = getAttributeByName(qualifiedName, this);\n        // 2. If attr is null, return null.\n        if (attr === null) {\n            return null;\n        }\n        // 3. Return attr’s value.\n        return attr.value;\n    };\n    /**\n     * Get the value of the specified attribute.\n     *\n     * @param namespace The namespace of the attribute\n     * @param localName The local name of the attribute\n     *\n     * @return The value of the attribute, or null if no such attribute exists\n     */\n    Element.prototype.getAttributeNS = function (namespace, localName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        localName = String(localName);\n        // 1. Let attr be the result of getting an attribute given namespace, localName, and the\n        // context object.\n        var attr = getAttributeByNamespaceAndLocalName(namespace, localName, this);\n        // 2. If attr is null, return null.\n        if (attr === null) {\n            return null;\n        }\n        // 3. Return attr’s value.\n        return attr.value;\n    };\n    /**\n     * Sets the value of the specified attribute.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     * @param value         The new value for the attribute\n     */\n    Element.prototype.setAttribute = function (qualifiedName, value) {\n        expectArity(arguments, 2);\n        qualifiedName = String(qualifiedName);\n        value = String(value);\n        // 1. If qualifiedName does not match the Name production in XML, then throw an\n        // InvalidCharacterError.\n        if (!matchesNameProduction(qualifiedName)) {\n            throwInvalidCharacterError('The qualified name does not match the Name production');\n        }\n        // 2. If the context object is in the HTML namespace and its node document is an HTML\n        // document, then set qualifiedName to qualifiedName in ASCII lowercase.\n        // (html documents not implemented)\n        // 3. Let attribute be the first attribute in context object’s attribute list whose\n        // qualified name is qualifiedName, and null otherwise.\n        var attribute = getAttributeByName(qualifiedName, this);\n        // 4. If attribute is null, create an attribute whose local name is qualifiedName, value is\n        // value, and node document is context object’s node document, then append this attribute to\n        // context object, and then return.\n        if (attribute === null) {\n            var context = getContext(this);\n            var attribute_1 = new context.Attr(null, null, qualifiedName, value, this);\n            attribute_1.ownerDocument = this.ownerDocument;\n            appendAttribute(attribute_1, this);\n            return;\n        }\n        // 5. Change attribute from context object to value.\n        changeAttribute(attribute, this, value);\n    };\n    /**\n     * Sets the value of the specified attribute.\n     *\n     * @param namespace     The namespace of the attribute\n     * @param qualifiedName The qualified name of the attribute\n     * @param value         The value for the attribute\n     */\n    Element.prototype.setAttributeNS = function (namespace, qualifiedName, value) {\n        expectArity(arguments, 3);\n        namespace = asNullableString(namespace);\n        qualifiedName = String(qualifiedName);\n        value = String(value);\n        // 1. Let namespace, prefix, and localName be the result of passing namespace and\n        // qualifiedName to validate and extract.\n        var _a = validateAndExtract(namespace, qualifiedName), validatedNamespace = _a.namespace, prefix = _a.prefix, localName = _a.localName;\n        // 2. Set an attribute value for the context object using localName, value, and also prefix\n        // and namespace.\n        setAttributeValue(this, localName, value, prefix, validatedNamespace);\n    };\n    /**\n     * Removes the specified attribute.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     */\n    Element.prototype.removeAttribute = function (qualifiedName) {\n        expectArity(arguments, 1);\n        qualifiedName = String(qualifiedName);\n        removeAttributeByName(qualifiedName, this);\n    };\n    /**\n     * Removes the specified attribute.\n     *\n     * @param namespace The namespace of the attribute\n     * @param localName The local name of the attribute\n     */\n    Element.prototype.removeAttributeNS = function (namespace, localName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        localName = String(localName);\n        removeAttributeByNamespaceAndLocalName(namespace, localName, this);\n    };\n    /**\n     * If force is not given, \"toggles\" qualifiedName, removing it if it is present and adding it if\n     * it is not present. If force is true, adds qualifiedName. If force is false, removes\n     * qualifiedName.\n     *\n     * Returns true if qualifiedName is now present, and false otherwise.\n     *\n     * @param qualifiedName\n     * @param force\n     */\n    Element.prototype.toggleAttribute = function (qualifiedName, force) {\n        // 1. If qualifiedName does not match the Name production in XML, then throw an\n        // \"InvalidCharacterError\" DOMException.\n        if (!matchesNameProduction(qualifiedName)) {\n            throwInvalidCharacterError('The qualified name does not match the Name production');\n        }\n        // 2. If the context object is in the HTML namespace and its node document is an HTML\n        // document, then set qualifiedName to qualifiedName in ASCII lowercase.\n        // (html documents not implemented)\n        // 3. Let attribute be the first attribute in the context object’s attribute list whose\n        // qualified name is qualifiedName, and null otherwise.\n        var attribute = getAttributeByName(qualifiedName, this);\n        // 4. If attribute is null, then:\n        if (attribute === null) {\n            // 4.1. If force is not given or is true,\n            if (force === undefined || force === true) {\n                // ...create an attribute whose local name is qualifiedName, value is the empty\n                // string, and node document is the context object’s node document,\n                var context = getContext(this);\n                var attribute_2 = new context.Attr(null, null, qualifiedName, '', this);\n                attribute_2.ownerDocument = this.ownerDocument;\n                // ...then append this attribute to the context object,\n                appendAttribute(attribute_2, this);\n                // ...and then return true.\n                return true;\n            }\n            // 4.2. Return false.\n            return false;\n        }\n        // 5. Otherwise, if force is not given or is false,\n        if (force === undefined || force === false) {\n            // ...remove an attribute given qualifiedName and the context object,\n            removeAttributeByName(qualifiedName, this);\n            // ...and then return false.\n            return false;\n        }\n        // 6. Return true.\n        return true;\n    };\n    /**\n     * Returns true if the specified attribute exists and false otherwise.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     */\n    Element.prototype.hasAttribute = function (qualifiedName) {\n        expectArity(arguments, 1);\n        qualifiedName = String(qualifiedName);\n        // 1. If the context object is in the HTML namespace and its node document is an HTML\n        // document, then set qualifiedName to qualifiedName in ASCII lowercase.\n        // (html documents not implemented)\n        // 2. Return true if the context object has an attribute whose qualified name is\n        // qualifiedName, and false otherwise.\n        return getAttributeByName(qualifiedName, this) !== null;\n    };\n    /**\n     * Returns true if the specified attribute exists and false otherwise.\n     *\n     * @param namespace The namespace of the attribute\n     * @param localName The local name of the attribute\n     */\n    Element.prototype.hasAttributeNS = function (namespace, localName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        localName = String(localName);\n        // 1. If namespace is the empty string, set it to null.\n        // (handled by getAttributeByNamespaceAndLocalName, called below)\n        // 2. Return true if the context object has an attribute whose namespace is namespace and\n        // local name is localName, and false otherwise.\n        return getAttributeByNamespaceAndLocalName(namespace, localName, this) !== null;\n    };\n    /**\n     * Returns the specified attribute node, or null if no such attribute exists.\n     *\n     * @param qualifiedName The qualified name of the attribute\n     *\n     * @return The attribute, or null if no such attribute exists\n     */\n    Element.prototype.getAttributeNode = function (qualifiedName) {\n        expectArity(arguments, 1);\n        qualifiedName = String(qualifiedName);\n        return getAttributeByName(qualifiedName, this);\n    };\n    /**\n     * Returns the specified attribute node, or null if no such attribute exists.\n     *\n     * @param namespace The namespace of the attribute\n     * @param localName The local name of the attribute\n     *\n     * @return The attribute, or null if no such attribute exists\n     */\n    Element.prototype.getAttributeNodeNS = function (namespace, localName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        localName = String(localName);\n        return getAttributeByNamespaceAndLocalName(namespace, localName, this);\n    };\n    /**\n     * Sets an attribute given its node\n     *\n     * @param attr The attribute node to set\n     *\n     * @return The previous attribute node for the attribute\n     */\n    Element.prototype.setAttributeNode = function (attr) {\n        expectArity(arguments, 1);\n        attr = asObject(attr, Attr);\n        return setAttribute(attr, this);\n    };\n    /**\n     * Sets an attribute given its node\n     *\n     * @param attr The attribute node to set\n     *\n     * @return The previous attribute node for the attribute\n     */\n    Element.prototype.setAttributeNodeNS = function (attr) {\n        expectArity(arguments, 1);\n        attr = asObject(attr, Attr);\n        return setAttribute(attr, this);\n    };\n    /**\n     * Removes an attribute given its node\n     *\n     * @param attr The attribute node to remove\n     *\n     * @return The removed attribute node\n     */\n    Element.prototype.removeAttributeNode = function (attr) {\n        expectArity(arguments, 1);\n        attr = asObject(attr, Attr);\n        // 1. If context object’s attribute list does not contain attr, then throw a NotFoundError.\n        if (this.attributes.indexOf(attr) < 0) {\n            throwNotFoundError('the specified attribute does not exist');\n        }\n        // 2. Remove attr from context object.\n        removeAttribute(attr, this);\n        // 3. Return attr.\n        return attr;\n    };\n    /**\n     * (non-standard) Creates a copy of the given node\n     *\n     * @param document The node document to associate with the copy\n     * @param other    The node to copy\n     *\n     * @return A shallow copy of the node\n     */\n    Element.prototype._copy = function (document) {\n        // 2.1. Let copy be the result of creating an element, given document, node’s local name,\n        // node’s namespace, node’s namespace prefix, and the value of node’s is attribute if\n        // present (or null if not). The synchronous custom elements flag should be unset.\n        var copyElement = createElement(document, this.localName, this.namespaceURI, this.prefix);\n        // 2.2. For each attribute in node’s attribute list:\n        for (var _i = 0, _a = this.attributes; _i < _a.length; _i++) {\n            var attr = _a[_i];\n            // 2.2.1. Let copyAttribute be a clone of attribute.\n            var copyAttribute = attr._copy(document);\n            // 2.2.2. Append copyAttribute to copy.\n            copyElement.setAttributeNode(copyAttribute);\n        }\n        return copyElement;\n    };\n    Object.defineProperty(Element.prototype, \"innerHTML\", {\n        // From the DOM Parsing and Serialization spec\n        /**\n         * Returns a fragment of HTML or XML that represents the element's contents.\n         */\n        get: function () {\n            // Return the result of invoking the fragment serializing algorithm on the context object\n            // providing true for the require well-formed flag (this might throw an exception instead of\n            // returning a string).\n            return serializeFragment(this, true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"outerHTML\", {\n        /**\n         * Returns a fragment of HTML or XML that represents the element and its contents.\n         */\n        get: function () {\n            // Return the result of invoking the fragment serializing algorithm on a fictional node\n            // whose only child is the context object providing true for the require well-formed flag\n            // (this might throw an exception instead of returning a string).\n            return serializeFragment(this, true, true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Element;\n}(Node));\nexport default Element;\n/**\n * To create an element, given a document, localName, namespace, and optional prefix, is, and\n * synchronous custom elements flag, run these steps:\n *\n * @param document  The node document for the new element\n * @param localName The local name for the new element\n * @param namespace The namespace URI for the new element, or null for the null namespace\n * @param prefix    The prefix for the new element, or null for no prefix\n *\n * @return The new element\n */\nexport function createElement(document, localName, namespace, prefix) {\n    // 1. If prefix was not given, let prefix be null.\n    // (handled by default)\n    if (prefix === void 0) { prefix = null; }\n    // 2. If is was not given, let is be null.\n    // (custom elements not implemented)\n    // 3. Let result be null.\n    var result = null;\n    // 4. Let definition be the result of looking up a custom element definition given document,\n    // namespace, localName, and is.\n    // (custom elements not implemented)\n    // 5. If definition is non-null, and definition’s name is not equal to its local name (i.e.,\n    // definition represents a customized built-in element), then:\n    // 5.1. Let interface be the element interface for localName and the HTML namespace.\n    // 5.2. Set result to a new element that implements interface, with no attributes, namespace set\n    // to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom\n    // element state set to \"undefined\", custom element definition set to null, is value set to is,\n    // and node document set to document.\n    // 5.3. If the synchronous custom elements flag is set, upgrade element using definition.\n    // 5.4. Otherwise, enqueue a custom element upgrade reaction given result and definition.\n    // (custom elements not implemented)\n    // 6. Otherwise, if definition is non-null, then:\n    // 6.1. If the synchronous custom elements flag is set, then run these steps while catching any\n    // exceptions:\n    // 6.1.1. Let C be definition’s constructor.\n    // 6.1.2. Set result to the result of constructing C, with no arguments.\n    // 6.1.3. If result does not implement the HTMLElement interface, then throw a TypeError.\n    // This is meant to be a brand check to ensure that the object was allocated by the HTML element\n    // constructor. See webidl #97 about making this more precise.\n    // If this check passes, then result will already have its custom element state and custom\n    // element definition initialized.\n    // 6.1.4. If result’s attribute list is not empty, then throw a NotSupportedError.\n    // 6.1.5. If result has children, then throw a NotSupportedError.\n    // 6.1.6. If result’s parent is not null, then throw a NotSupportedError.\n    // 6.1.7. If result’s node document is not document, then throw a NotSupportedError.\n    // 6.1.8. If result’s namespace is not the HTML namespace, then throw a NotSupportedError.\n    // As of the time of this writing, every element that implements the HTMLElement interface is\n    // also in the HTML namespace, so this check is currently redundant with the above brand check.\n    // However, this is not guaranteed to be true forever in the face of potential specification\n    // changes, such as converging certain SVG and HTML interfaces.\n    // 6.1.9. If result’s local name is not equal to localName, then throw a NotSupportedError.\n    // 6.1.10. Set result’s namespace prefix to prefix.\n    // 6.1.11. Set result’s is value to null.\n    // If any of these steps threw an exception, then:\n    // 6.1.catch.1. Report the exception.\n    // 6.1.catch.2. Set result to a new element that implements the HTMLUnknownElement interface,\n    // with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix,\n    // local name set to localName, custom element state set to \"failed\", custom element definition\n    // set to null, is value set to null, and node document set to document.\n    // 6.2. Otherwise:\n    // 6.2.1. Set result to a new element that implements the HTMLElement interface, with no\n    // attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name\n    // set to localName, custom element state set to \"undefined\", custom element definition set to\n    // null, is value set to null, and node document set to document.\n    // 6.2.2. Enqueue a custom element upgrade reaction given result and definition.\n    // (custom elements not implemented)\n    // 7. Otherwise:\n    // 7.1. Let interface be the element interface for localName and namespace.\n    // (interfaces other than Element not implemented)\n    // 7.2. Set result to a new element that implements interface, with no attributes, namespace set\n    // to namespace, namespace prefix set to prefix, local name set to localName, custom element\n    // state set to \"uncustomized\", custom element definition set to null, is value set to is, and\n    // node document set to document.\n    var context = getContext(document);\n    result = new context.Element(namespace, prefix, localName);\n    result.ownerDocument = document;\n    // If namespace is the HTML namespace, and either localName is a valid custom element name or is\n    // is non-null, then set result’s custom element state to \"undefined\".\n    // (custom elements not implemented)\n    // Return result.\n    return result;\n}\n/**\n * To get an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName The qualified name of the attribute to get\n * @param element       The element to get the attribute on\n *\n * @return The first matching attribute, or null otherwise\n */\nfunction getAttributeByName(qualifiedName, element) {\n    // 1. If element is in the HTML namespace and its node document is an HTML document, then set\n    // qualifiedName to qualifiedName in ASCII lowercase.\n    // (html documents not implemented)\n    // 2. Return the first attribute in element’s attribute list whose qualified name is\n    // qualifiedName, and null otherwise.\n    return element.attributes.find(function (attr) { return attr.name === qualifiedName; }) || null;\n}\n/**\n * To get an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace Namespace for the attribute\n * @param localName Local name for the attribute\n * @param element   The element to get the attribute on\n *\n * @return The first matching attribute, or null otherwise\n */\nfunction getAttributeByNamespaceAndLocalName(namespace, localName, element) {\n    // 1. If namespace is the empty string, set it to null.\n    if (namespace === '') {\n        namespace = null;\n    }\n    // 2. Return the attribute in element’s attribute list whose namespace is namespace and local\n    // name is localName, if any, and null otherwise.\n    return (element.attributes.find(function (attr) { return attr.namespaceURI === namespace && attr.localName === localName; }) || null);\n}\n/**\n * To set an attribute given an attr and element, run these steps:\n *\n * @param attr    The new attribute to set\n * @param element The element to set attr on\n *\n * @return The previous attribute with attr's namespace and local name, or null if there was no such\n *         attribute\n */\nfunction setAttribute(attr, element) {\n    // 1. If attr’s element is neither null nor element, throw an InUseAttributeError.\n    if (attr.ownerElement !== null && attr.ownerElement !== element) {\n        throwInUseAttributeError('attribute is in use by another element');\n    }\n    // 2. Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local\n    // name, and element.\n    var oldAttr = getAttributeByNamespaceAndLocalName(attr.namespaceURI, attr.localName, element);\n    // 3. If oldAttr is attr, return attr.\n    if (oldAttr === attr) {\n        return attr;\n    }\n    // 4. If oldAttr is non-null, replace it by attr in element.\n    if (oldAttr !== null) {\n        replaceAttribute(oldAttr, attr, element);\n    }\n    else {\n        // 5. Otherwise, append attr to element.\n        appendAttribute(attr, element);\n    }\n    // 6. Return oldAttr.\n    return oldAttr;\n}\n/**\n * To set an attribute value for an element element using a localName and value, and an optional\n * prefix, and namespace, run these steps:\n *\n * @param element   Element to set the attribute value on\n * @param localName Local name of the attribute\n * @param value     New value of the attribute\n * @param prefix    Prefix of the attribute\n * @param namespace Namespace of the attribute\n */\nfunction setAttributeValue(element, localName, value, prefix, namespace) {\n    // 1. If prefix is not given, set it to null.\n    // 2. If namespace is not given, set it to null.\n    // (handled by default values)\n    // 3. Let attribute be the result of getting an attribute given namespace, localName, and\n    // element.\n    var attribute = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n    // 4. If attribute is null, create an attribute whose namespace is namespace, namespace prefix\n    // is prefix, local name is localName, value is value, and node document is element’s node\n    // document, then append this attribute to element, and then return.\n    if (attribute === null) {\n        var context = getContext(element);\n        var attribute_3 = new context.Attr(namespace, prefix, localName, value, element);\n        attribute_3.ownerDocument = element.ownerDocument;\n        appendAttribute(attribute_3, element);\n        return;\n    }\n    // 5. Change attribute from element to value.\n    changeAttribute(attribute, element, value);\n}\n/**\n * To remove an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName Qualified name of the attribute\n * @param element       The element to remove the attribute from\n *\n * @return The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByName(qualifiedName, element) {\n    // 1. Let attr be the result of getting an attribute given qualifiedName and element.\n    var attr = getAttributeByName(qualifiedName, element);\n    // 2. If attr is non-null, remove it from element.\n    if (attr !== null) {\n        removeAttribute(attr, element);\n    }\n    // 3. Return attr.\n    return attr;\n}\n/**\n * To remove an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace The namespace of the attribute\n * @param localName The local name of the attribute\n * @param element   The element to remove the attribute from\n *\n * @return The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByNamespaceAndLocalName(namespace, localName, element) {\n    // 1. Let attr be the result of getting an attribute given namespace, localName, and element.\n    var attr = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n    // 2. If attr is non-null, remove it from element.\n    if (attr !== null) {\n        removeAttribute(attr, element);\n    }\n    // 3. Return attr.\n    return attr;\n}\n//# sourceMappingURL=Element.js.map","import { createElement } from '../Element';\nimport { validateAndExtract } from './namespaceHelpers';\n// 3.5. Interface Document\n/**\n * The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as\n * follows:\n *\n * @param document      The node document for the new element\n * @param namespace     The namespace for the new element\n * @param qualifiedName The qualified name for the new element\n *\n * @return The new element\n */\nexport default function createElementNS(document, namespace, qualifiedName) {\n    // 1. Let namespace, prefix, and localName be the result of passing namespace and qualifiedName\n    // to validate and extract.\n    var _a = validateAndExtract(namespace, qualifiedName), validatedNamespace = _a.namespace, prefix = _a.prefix, localName = _a.localName;\n    // 2. Let is be the value of is member of options, or null if no such member exists.\n    // (custom elements not implemented)\n    // 3. Let element be the result of creating an element given document, localName, namespace,\n    // prefix, is, and with the synchronous custom elements flag set.\n    var element = createElement(document, localName, validatedNamespace, prefix);\n    // 4. If is is non-null, then set an attribute value for element using \"is\" and is.\n    // (custom elements not implemented)\n    // 5. Return element.\n    return element;\n}\n//# sourceMappingURL=createElementNS.js.map","import Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity, throwIndexSizeError, throwInvalidNodeTypeError, throwNotSupportedError, throwWrongDocumentError } from './util/errorHelpers';\nimport { isNodeOfType } from './util/NodeType';\nimport { determineLengthOfNode, getInclusiveAncestors, getNodeIndex, getRootOfNode } from './util/treeHelpers';\nimport { asObject, asUnsignedLong } from './util/typeHelpers';\n/**\n * A range is collapsed if its start node is its end node and its start offset is its end offset.\n *\n * @param range\n */\nfunction isCollapsed(range) {\n    return range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n}\n/**\n * Interface Range\n *\n * Objects implementing the Range interface are known as live ranges.\n */\nvar Range = /** @class */ (function () {\n    /**\n     * The Range() constructor, when invoked, must return a new live range with (current global\n     * object’s associated Document, 0) as its start and end.\n     */\n    function Range() {\n        var context = getContext(this);\n        this.startContainer = context.document;\n        this.startOffset = 0;\n        this.endContainer = context.document;\n        this.endOffset = 0;\n        context._ranges.push(this);\n    }\n    Object.defineProperty(Range.prototype, \"collapsed\", {\n        get: function () {\n            return isCollapsed(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Range.prototype, \"commonAncestorContainer\", {\n        /**\n         * Get the common ancestor of the range's boundary position nodes.\n         *\n         * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n         */\n        get: function () {\n            var ancestors1 = getInclusiveAncestors(this.startContainer);\n            var ancestors2 = getInclusiveAncestors(this.endContainer);\n            var commonAncestorContainer = ancestors1[0];\n            var i = 0;\n            while (i < ancestors1.length && i < ancestors2.length) {\n                if (ancestors1[i] !== ancestors2[i]) {\n                    break;\n                }\n                commonAncestorContainer = ancestors1[i];\n                ++i;\n            }\n            return commonAncestorContainer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the start boundary point of the range.\n     *\n     * @param node   The new start container\n     * @param offset The new start offset\n     */\n    Range.prototype.setStart = function (node, offset) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        offset = asUnsignedLong(offset);\n        // 1. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Can not set a range under a doctype node');\n        }\n        // 2. If offset is greater than node’s length, then throw an IndexSizeError.\n        if (offset > determineLengthOfNode(node)) {\n            throwIndexSizeError('Can not set a range past the end of the node');\n        }\n        // 3. Let bp be the boundary point (node, offset).\n        // 4.a. If these steps were invoked as \"set the start\"\n        // 4.a.1. If bp is after the range’s end, or if range’s root is not equal to node’s root,\n        // set range’s end to bp.\n        var rootOfNode = getRootOfNode(node);\n        var rootOfRange = getRootOfRange(this);\n        if (rootOfNode !== rootOfRange ||\n            compareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n                POSITION_AFTER) {\n            this.endContainer = node;\n            this.endOffset = offset;\n        }\n        // 4.a.2. Set range’s start to bp.\n        this.startContainer = node;\n        this.startOffset = offset;\n        // 4.b. If these steps were invoked as \"set the end\"\n        // 4.b.1. If bp is before the range’s start, or if range’s root is not equal to node’s root,\n        // set range’s start to bp.\n        // 4.b.2. Set range’s end to bp.\n        // (see Range#setEnd for this branch)\n    };\n    /**\n     * Sets the end boundary point of the range.\n     *\n     * @param node   The new end container\n     * @param offset The new end offset\n     */\n    Range.prototype.setEnd = function (node, offset) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        offset = asUnsignedLong(offset);\n        // 1. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Can not set a range under a doctype node');\n        }\n        // 2. If offset is greater than node’s length, then throw an IndexSizeError.\n        if (offset > determineLengthOfNode(node)) {\n            throwIndexSizeError('Can not set a range past the end of the node');\n        }\n        // 3. Let bp be the boundary point (node, offset).\n        // 4.a. If these steps were invoked as \"set the start\"\n        // 4.a.1. If bp is after the range’s end, or if range’s root is not equal to node’s root,\n        // set range’s end to bp.\n        // 4.a.2. Set range’s start to bp.\n        // (see Range#setStart for this branch)\n        // 4.b. If these steps were invoked as \"set the end\"\n        // 4.b.1. If bp is before the range’s start, or if range’s root is not equal to node’s root,\n        // set range’s start to bp.\n        var rootOfNode = getRootOfNode(node);\n        var rootOfRange = getRootOfRange(this);\n        if (rootOfNode !== rootOfRange ||\n            compareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n                POSITION_BEFORE) {\n            this.startContainer = node;\n            this.startOffset = offset;\n        }\n        // 4.b.2. Set range’s end to bp.\n        this.endContainer = node;\n        this.endOffset = offset;\n    };\n    /**\n     * Sets the start boundary point of the range to the position just before the given node.\n     *\n     * @param node The node to set the range's start before\n     */\n    Range.prototype.setStartBefore = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not set range before node without a parent');\n        }\n        // 3. Set the start of the context object to boundary point (parent, node’s index).\n        this.setStart(parent, getNodeIndex(node));\n    };\n    /**\n     * Sets the start boundary point of the range to the position just after the given node.\n     *\n     * @param node The node to set the range's start before\n     */\n    Range.prototype.setStartAfter = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not set range before node without a parent');\n        }\n        // 3. Set the start of the context object to boundary point (parent, node’s index plus one).\n        this.setStart(parent, getNodeIndex(node) + 1);\n    };\n    /**\n     * Sets the end boundary point of the range to the position just before the given node.\n     *\n     * @param node The node to set the range's end before\n     */\n    Range.prototype.setEndBefore = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not set range before node without a parent');\n        }\n        // 3. Set the end of the context object to boundary point (parent, node’s index).\n        this.setEnd(parent, getNodeIndex(node));\n    };\n    /**\n     * Sets the end boundary point of the range to the position just after the given node.\n     *\n     * @param node The node to set the range's end before\n     */\n    Range.prototype.setEndAfter = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not set range before node without a parent');\n        }\n        // 3. Set the end of the context object to boundary point (parent, node’s index plus one).\n        this.setEnd(parent, getNodeIndex(node) + 1);\n    };\n    /**\n     * Sets the range's boundary points to the same position.\n     *\n     * @param toStart If true, set both points to the start of the range, otherwise set them to the\n     *                end\n     */\n    Range.prototype.collapse = function (toStart) {\n        if (toStart === void 0) { toStart = false; }\n        if (toStart) {\n            this.endContainer = this.startContainer;\n            this.endOffset = this.startOffset;\n        }\n        else {\n            this.startContainer = this.endContainer;\n            this.startOffset = this.endOffset;\n        }\n    };\n    Range.prototype.selectNode = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 2. If parent is null, then throw an InvalidNodeTypeError.\n        if (parent === null) {\n            return throwInvalidNodeTypeError('Can not select node with null parent');\n        }\n        // 3. Let index be node’s index.\n        var index = getNodeIndex(node);\n        // 4. Set range’s start to boundary point (parent, index).\n        this.startContainer = parent;\n        this.startOffset = index;\n        // 5. Set range’s end to boundary point (parent, index plus one).\n        this.endContainer = parent;\n        this.endOffset = index + 1;\n    };\n    Range.prototype.selectNodeContents = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Can not place range inside a doctype node');\n        }\n        // 2. Let length be the length of node.\n        var length = determineLengthOfNode(node);\n        // 3. Set start to the boundary point (node, 0).\n        this.startContainer = node;\n        this.startOffset = 0;\n        // 4. Set end to the boundary point (node, length).\n        this.endContainer = node;\n        this.endOffset = length;\n    };\n    Range.prototype.compareBoundaryPoints = function (how, sourceRange) {\n        expectArity(arguments, 2);\n        sourceRange = asObject(sourceRange, Range);\n        // 1. If how is not one of START_TO_START, START_TO_END, END_TO_END, and END_TO_START, then\n        // throw a NotSupportedError.\n        if (how !== Range.START_TO_START &&\n            how !== Range.START_TO_END &&\n            how !== Range.END_TO_END &&\n            how !== Range.END_TO_START) {\n            throwNotSupportedError('Unsupported comparison type');\n        }\n        // 2. If context object’s root is not the same as sourceRange’s root, then throw a\n        // WrongDocumentError.\n        if (getRootOfRange(this) !== getRootOfRange(sourceRange)) {\n            throwWrongDocumentError('Can not compare positions of ranges in different trees');\n        }\n        // 3. If how is:\n        switch (how) {\n            // START_TO_START:\n            case Range.START_TO_START:\n                // Let this point be the context object’s start. Let other point be sourceRange’s\n                // start.\n                return compareBoundaryPointPositions(\n                // this point\n                this.startContainer, this.startOffset, \n                // other point\n                sourceRange.startContainer, sourceRange.startOffset);\n            // START_TO_END:\n            case Range.START_TO_END:\n                // Let this point be the context object’s end. Let other point be sourceRange’s\n                // start.\n                return compareBoundaryPointPositions(\n                // this point\n                this.endContainer, this.endOffset, \n                // other point\n                sourceRange.startContainer, sourceRange.startOffset);\n            // END_TO_END:\n            case Range.END_TO_END:\n                // Let this point be the context object’s end. Let other point be sourceRange’s end.\n                return compareBoundaryPointPositions(\n                // this point\n                this.endContainer, this.endOffset, \n                // other point\n                sourceRange.endContainer, sourceRange.endOffset);\n            // END_TO_START:\n            default:\n                // Let this point be the context object’s start. Let other point be sourceRange’s\n                // end.\n                return compareBoundaryPointPositions(\n                // this point\n                this.startContainer, this.startOffset, \n                // other point,\n                sourceRange.endContainer, sourceRange.endOffset);\n        }\n        // 4. If the position of this point relative to other point is\n        // before: Return −1.\n        // equal: Return 0.\n        // after: Return 1.\n        // (handled in switch above)\n    };\n    /**\n     * Returns a range with the same start and end as the context object.\n     *\n     * @return A copy of the context object\n     */\n    Range.prototype.cloneRange = function () {\n        var context = getContext(this);\n        var range = new context.Range();\n        range.startContainer = this.startContainer;\n        range.startOffset = this.startOffset;\n        range.endContainer = this.endContainer;\n        range.endOffset = this.endOffset;\n        return range;\n    };\n    /**\n     * Stops tracking the range.\n     *\n     * (non-standard) According to the spec, this method must do nothing. However, as it is not\n     * possible to rely on garbage collection to determine when to stop updating a range for node\n     * mutations, this implementation requires calling detach to stop such updates from affecting\n     * the range.\n     */\n    Range.prototype.detach = function () {\n        var context = getContext(this);\n        var index = context._ranges.indexOf(this);\n        if (index >= 0) {\n            context._ranges.splice(index, 1);\n        }\n    };\n    /**\n     * Returns true if the given point is after or equal to the start point and before or equal to\n     * the end point of the context object.\n     *\n     * @param node   Node of point to check\n     * @param offset Offset of point to check\n     *\n     * @return Whether the point is in the range\n     */\n    Range.prototype.isPointInRange = function (node, offset) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        offset = asUnsignedLong(offset);\n        // 1. If node’s root is different from the context object’s root, return false.\n        if (getRootOfNode(node) !== getRootOfRange(this)) {\n            return false;\n        }\n        // 2. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Point can not be under a doctype');\n        }\n        // 3. If offset is greater than node’s length, then throw an IndexSizeError.\n        if (offset > determineLengthOfNode(node)) {\n            throwIndexSizeError('Offset should not be past the end of node');\n        }\n        // 4. If (node, offset) is before start or after end, return false.\n        if (compareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n            POSITION_BEFORE ||\n            compareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n                POSITION_AFTER) {\n            return false;\n        }\n        // 5. Return true.\n        return true;\n    };\n    /**\n     * Compares the given point to the range's boundary points.\n     *\n     * @param node   Node of point to check\n     * @param offset Offset of point to check\n     *\n     * @return -1, 0 or 1 depending on whether the point is before, inside or after the range,\n     *         respectively\n     */\n    Range.prototype.comparePoint = function (node, offset) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        offset = asUnsignedLong(offset);\n        // 1. If node’s root is different from the context object’s root, then throw a\n        // WrongDocumentError.\n        if (getRootOfNode(node) !== getRootOfRange(this)) {\n            throwWrongDocumentError('Can not compare point to range in different trees');\n        }\n        // 2. If node is a doctype, then throw an InvalidNodeTypeError.\n        if (isNodeOfType(node, 10 /* DOCUMENT_TYPE_NODE */)) {\n            throwInvalidNodeTypeError('Point can not be under a doctype');\n        }\n        // 3. If offset is greater than node’s length, then throw an IndexSizeError.\n        if (offset > determineLengthOfNode(node)) {\n            throwIndexSizeError('Offset should not be past the end of node');\n        }\n        // 4. If (node, offset) is before start, return −1.\n        if (compareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n            POSITION_BEFORE) {\n            return -1;\n        }\n        // 5. If (node, offset) is after end, return 1.\n        if (compareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n            POSITION_AFTER) {\n            return 1;\n        }\n        // 6. Return 0.\n        return 0;\n    };\n    /**\n     * Returns true if range overlaps the range from before node to after node.\n     *\n     * @param node The node to check\n     *\n     * @return Whether the range intersects node\n     */\n    Range.prototype.intersectsNode = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. If node’s root is different from the context object’s root, return false.\n        if (getRootOfNode(node) !== getRootOfRange(this)) {\n            return false;\n        }\n        // 2. Let parent be node’s parent.\n        var parent = node.parentNode;\n        // 3. If parent is null, return true.\n        if (parent === null) {\n            return true;\n        }\n        // 4. Let offset be node’s index.\n        var offset = getNodeIndex(node);\n        // 5. If (parent, offset) is before end and (parent, offset + 1) is after start, return\n        // true.\n        // 6. Return false.\n        return (compareBoundaryPointPositions(parent, offset, this.endContainer, this.endOffset) ===\n            POSITION_BEFORE &&\n            compareBoundaryPointPositions(parent, offset + 1, this.startContainer, this.startOffset) === POSITION_AFTER);\n    };\n    Range.START_TO_START = 0;\n    Range.START_TO_END = 1;\n    Range.END_TO_END = 2;\n    Range.END_TO_START = 3;\n    return Range;\n}());\nexport default Range;\nvar POSITION_BEFORE = -1;\nvar POSITION_EQUAL = 0;\nvar POSITION_AFTER = 1;\n/**\n * If the two nodes of boundary points (node A, offset A) and (node B, offset B) have the same root,\n * the position of the first relative to the second is either before, equal, or after.\n *\n * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n *\n * This implementation assumes it is called on nodes under the same root.\n *\n * @param nodeA   First boundary point's node\n * @param offsetA First boundary point's offset\n * @param nodeB   Second boundary point's node\n * @param offsetB Second boundary point's offset\n *\n * @return -1, 0 or 1, depending on the boundary points' relative positions\n */\nfunction compareBoundaryPointPositions(nodeA, offsetA, nodeB, offsetB) {\n    if (nodeA !== nodeB) {\n        var ancestors1 = getInclusiveAncestors(nodeA);\n        var ancestors2 = getInclusiveAncestors(nodeB);\n        // Skip common parents\n        while (ancestors1[0] && ancestors2[0] && ancestors1[0] === ancestors2[0]) {\n            ancestors1.shift();\n            ancestors2.shift();\n        }\n        // Compute offsets at the level under the last common parent. Add 0.5 to bias positions\n        // inside the parent vs. those before or after.\n        if (ancestors1.length) {\n            offsetA = getNodeIndex(ancestors1[0]) + 0.5;\n        }\n        if (ancestors2.length) {\n            offsetB = getNodeIndex(ancestors2[0]) + 0.5;\n        }\n    }\n    // Compare positions at this level\n    if (offsetA === offsetB) {\n        return POSITION_EQUAL;\n    }\n    return offsetA < offsetB ? POSITION_BEFORE : POSITION_AFTER;\n}\n/**\n * The root of a range is the root of its start node.\n *\n * @param range The range to get the root of\n *\n * @return The root of range\n */\nfunction getRootOfRange(range) {\n    return getRootOfNode(range.startContainer);\n}\n//# sourceMappingURL=Range.js.map","/**\n * A registered observer consists of an observer (a MutationObserver object) and options (a\n * MutationObserverInit dictionary).\n *\n * A transient registered observer is a registered observer that also consists of a source (a\n * registered observer).\n *\n * Transient registered observers are used to track mutations within a given node’s descendants\n * after node has been removed so they do not get lost when subtree is set to true on node’s parent.\n */\nvar RegisteredObserver = /** @class */ (function () {\n    /**\n     * @param observer The observer being registered\n     * @param node     The node being observed\n     * @param options  Options for the registration\n     * @param source   If not null, creates a transient registered observer for the given registered\n     *                 observer\n     */\n    function RegisteredObserver(observer, node, options, source) {\n        /**\n         * A transient observer is an observer that has a source which is an observer.\n         */\n        this.source = null;\n        this.observer = observer;\n        this.node = node;\n        this.options = options;\n        this.source = source || null;\n        if (source) {\n            observer._transients.push(this);\n        }\n    }\n    /**\n     * Adds the given mutationRecord to the NotifyList of the registered MutationObserver. It only\n     * adds the record when it's type isn't blocked by one of the flags of this registered\n     * MutationObserver options (formally the MutationObserverInit object).\n     *\n     * @param type                The type of mutation record to queue\n     * @param target              The target node\n     * @param data                The data for the mutation record\n     * @param interestedObservers Array of mutation observer objects to append to\n     * @param pairedStrings       Paired strings for the mutation observer objects\n     */\n    RegisteredObserver.prototype.collectInterestedObservers = function (type, target, data, interestedObservers, pairedStrings) {\n        // (continued from RegisteredObservers#queueMutationRecord)\n        // 3.1. Let options be registered's options.\n        // 3.2. If none of the following are true\n        // node is not target and options’ subtree is false\n        if (this.node !== target && !this.options.subtree) {\n            return;\n        }\n        // type is \"attributes\" and options’ attributes is not true\n        if (type === 'attributes' && !this.options.attributes) {\n            return;\n        }\n        // type is \"attributes\", options’ attributeFilter is present, and options’ attributeFilter\n        // does not contain name or namespace is non-null\n        // (attributeFilter not implemented)\n        // type is \"characterData\" and options’ characterData is not true\n        if (type === 'characterData' && !this.options.characterData) {\n            return;\n        }\n        // type is \"childList\" and options’ childList is false\n        if (type === 'childList' && !this.options.childList) {\n            return;\n        }\n        // then:\n        // 3.2.1. Let mo be registered's observer.\n        // 3.2.2. If interestedObservers[mo] does not exist, then set interestedObservers[mo] to\n        // null\n        var index = interestedObservers.indexOf(this.observer);\n        if (index < 0) {\n            index = interestedObservers.length;\n            interestedObservers.push(this.observer);\n            pairedStrings.push(undefined);\n        }\n        // 3.2.3. If either type is \"attributes\" and options’ attributeOldValue is true, or type is\n        // \"characterData\" and options’ characterDataOldValue is true, then set\n        // interestedObservers[mo] to oldValue.\n        if ((type === 'attributes' && this.options.attributeOldValue) ||\n            (type === 'characterData' && this.options.characterDataOldValue)) {\n            pairedStrings[index] = data.oldValue;\n        }\n    };\n    return RegisteredObserver;\n}());\nexport default RegisteredObserver;\n//# sourceMappingURL=RegisteredObserver.js.map","/**\n * 3.3.3. Interface MutationRecord\n *\n * A helper class which describes a specific mutation as it is observed by a MutationObserver.\n */\nvar MutationRecord = /** @class */ (function () {\n    /**\n     * (non-standard) Constructs a MutationRecord\n     *\n     * @param type   The value for the type property\n     * @param target The value for the target property\n     */\n    function MutationRecord(type, target) {\n        /**\n         * Children of target added in this mutation.\n         *\n         * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n         * array.\n         */\n        this.addedNodes = [];\n        /**\n         * Children of target removed in this mutation.\n         *\n         * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n         * array.\n         */\n        this.removedNodes = [];\n        /**\n         * The previous sibling of the added or removed nodes, or null otherwise.\n         */\n        this.previousSibling = null;\n        /**\n         * The next sibling Node of the added or removed nodes, or null otherwise.\n         */\n        this.nextSibling = null;\n        /**\n         * The local name of the changed attribute, or null otherwise.\n         */\n        this.attributeName = null;\n        /**\n         * The namespace of the changed attribute, or null otherwise.\n         */\n        this.attributeNamespace = null;\n        /**\n         * The return value depends on type. For \"attributes\", it is the value of the changed attribute\n         * before the change. For \"characterData\", it is the data of the changed node before the change.\n         * For \"childList\", it is null.\n         */\n        this.oldValue = null;\n        this.type = type;\n        this.target = target;\n    }\n    return MutationRecord;\n}());\nexport default MutationRecord;\n//# sourceMappingURL=MutationRecord.js.map","import { getContext } from './context/Context';\nimport RegisteredObservers from './mutation-observer/RegisteredObservers';\nimport cloneNode from './util/cloneNode';\nimport { expectArity } from './util/errorHelpers';\nimport { preInsertNode, appendNode, replaceChildWithNode, preRemoveChild, removeNode } from './util/mutationAlgorithms';\nimport { isNodeOfType } from './util/NodeType';\nimport { getNodeDocument } from './util/treeHelpers';\nimport { asNullableObject, asNullableString, asObject } from './util/typeHelpers';\n/**\n * 3.4. Interface Node\n */\nvar Node = /** @class */ (function () {\n    function Node() {\n        /**\n         * A reference to the Document node in which the current node resides.\n         */\n        this.ownerDocument = null;\n        /**\n         * The parent node of the current node.\n         */\n        this.parentNode = null;\n        /**\n         * The node's children.\n         *\n         * Non-standard: implemented as an array rather than a NodeList.\n         */\n        this.childNodes = [];\n        /**\n         * The first child node of the current node, or null if it has no children.\n         */\n        this.firstChild = null;\n        /**\n         * The last child node of the current node, or null if it has no children.\n         */\n        this.lastChild = null;\n        /**\n         * The first preceding sibling of the current node, or null if it has none.\n         */\n        this.previousSibling = null;\n        /**\n         * The first following sibling of the current node, or null if it has none.\n         */\n        this.nextSibling = null;\n        /**\n         * (non-standard)\n         * Each node has a registered observer list of zero or more registered observers, which is\n         * initially empty.\n         */\n        this._registeredObservers = new RegisteredObservers(this);\n    }\n    Object.defineProperty(Node.prototype, \"parentElement\", {\n        /**\n         * The parent if it is an element, or null otherwise.\n         */\n        get: function () {\n            return this.parentNode && isNodeOfType(this.parentNode, 1 /* ELEMENT_NODE */)\n                ? this.parentNode\n                : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns true if the context object has children, and false otherwise.\n     */\n    Node.prototype.hasChildNodes = function () {\n        return !!this.childNodes.length;\n    };\n    /**\n     * Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized\n     * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.\n     */\n    Node.prototype.normalize = function () {\n        var _this = this;\n        // for each descendant exclusive Text node node of context object:\n        var node = this.firstChild;\n        var index = 0;\n        var document = getNodeDocument(this);\n        var _loop_1 = function () {\n            var nextNode = node.nextSibling;\n            if (!isNodeOfType(node, 3 /* TEXT_NODE */)) {\n                // Process descendants\n                node.normalize();\n                node = nextNode;\n                return \"continue\";\n            }\n            var textNode = node;\n            // 1. Let length be node’s length.\n            var length = textNode.length;\n            // 2. If length is zero, then remove node and continue with the next exclusive Text\n            // node, if any.\n            if (length === 0) {\n                removeNode(node, this_1);\n                --index;\n                node = nextNode;\n                return \"continue\";\n            }\n            // 3. Let data be the concatenation of the data of node’s contiguous exclusive Text\n            // nodes (excluding itself), in tree order.\n            var data = '';\n            var siblingsToRemove = [];\n            for (var sibling = textNode.nextSibling; sibling && isNodeOfType(sibling, 3 /* TEXT_NODE */); sibling = sibling.nextSibling) {\n                data += sibling.data;\n                siblingsToRemove.push(sibling);\n            }\n            // 4. Replace data with node node, offset length, count 0, and data data.\n            if (data) {\n                textNode.replaceData(length, 0, data);\n            }\n            // 5. Let currentNode be node’s next sibling.\n            // 6. While currentNode is an exclusive Text node:\n            var context = getContext(this_1);\n            var _loop_2 = function (i, l) {\n                var currentNode = siblingsToRemove[i];\n                var currentNodeIndex = index + i + 1;\n                context._ranges.forEach(function (range) {\n                    // 6.1. For each live range whose start node is currentNode, add length to its\n                    // start offset and set its start node to node.\n                    if (range.startContainer === currentNode) {\n                        range.startOffset += length;\n                        range.startContainer = textNode;\n                    }\n                    // 6.2. For each live range whose end node is currentNode, add length to its end\n                    // offset and set its end node to node.\n                    if (range.endContainer === currentNode) {\n                        range.endOffset += length;\n                        range.endContainer = textNode;\n                    }\n                    // 6.3. For each live range whose start node is currentNode’s parent and start\n                    // offset is currentNode’s index, set its start node to node and its start\n                    // offset to length.\n                    if (range.startContainer === _this && range.startOffset === currentNodeIndex) {\n                        range.startContainer = textNode;\n                        range.startOffset = length;\n                    }\n                    // 6.4. For each live range whose end node is currentNode’s parent and end\n                    // offset is currentNode’s index, set its end node to node and its end offset to\n                    // length.\n                    if (range.endContainer === _this && range.endOffset === currentNodeIndex) {\n                        range.endContainer = textNode;\n                        range.endOffset = length;\n                    }\n                });\n                // 6.5. Add currentNode’s length to length.\n                length += currentNode.length;\n            };\n            for (var i = 0, l = siblingsToRemove.length; i < l; ++i) {\n                _loop_2(i, l);\n            }\n            // 7. Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.\n            while (siblingsToRemove.length) {\n                removeNode(siblingsToRemove.shift(), this_1);\n            }\n            // Move to next node\n            node = node.nextSibling;\n            ++index;\n        };\n        var this_1 = this;\n        while (node) {\n            _loop_1();\n        }\n        // Note: normalize() does not need to run any child text content change steps, since\n        // although it messes with Text nodes extensively, it does so specifically in a way that\n        // preserves the child text content.\n    };\n    /**\n     * Returns a copy of the current node.\n     *\n     * @param deep Whether to also clone the node's descendants\n     *\n     * @return A copy of the current node\n     */\n    Node.prototype.cloneNode = function (deep) {\n        if (deep === void 0) { deep = false; }\n        return cloneNode(this, deep);\n    };\n    /**\n     * Returns true if other is an inclusive descendant of context object, and false otherwise\n     * (including when other is null).\n     *\n     * @param childNode Node to check\n     *\n     * @return Whether childNode is an inclusive descendant of the current node\n     */\n    Node.prototype.contains = function (other) {\n        expectArity(arguments, 1);\n        other = asNullableObject(other, Node);\n        while (other && other != this) {\n            other = other.parentNode;\n        }\n        return other === this;\n    };\n    /**\n     * Return true if defaultNamespace is the same as namespace, and false otherwise.\n     *\n     * @param namespace The namespace to check\n     *\n     * @return Whether namespace is the default namespace\n     */\n    Node.prototype.isDefaultNamespace = function (namespace) {\n        expectArity(arguments, 1);\n        namespace = asNullableString(namespace);\n        // 1. If namespace is the empty string, then set it to null.\n        if (namespace === '') {\n            namespace = null;\n        }\n        // 2. Let defaultNamespace be the result of running locate a namespace for context object\n        // using null.\n        var defaultNamespace = this.lookupNamespaceURI(null);\n        // 3. Return true if defaultNamespace is the same as namespace, and false otherwise.\n        return defaultNamespace === namespace;\n    };\n    /**\n     * Inserts the specified node before child within context object.\n     *\n     * If child is null, the new node is appended after the last child node of the current node.\n     *\n     * @param node  Node to insert\n     * @param child Childnode of the current node before which to insert, or null to append newNode\n     *              at the end\n     *\n     * @return The node that was inserted\n     */\n    Node.prototype.insertBefore = function (node, child) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        child = asNullableObject(child, Node);\n        return preInsertNode(node, this, child);\n    };\n    /**\n     * Adds node to the end of the list of children of the context object.\n     *\n     * If the node already exists it is removed from its current parent node, then added.\n     *\n     * @param node Node to append\n     *\n     * @return The node that was inserted\n     */\n    Node.prototype.appendChild = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        return appendNode(node, this);\n    };\n    /**\n     * Replaces child with node within context object and returns child.\n     *\n     * @param node  Node to insert\n     * @param child Node to remove\n     *\n     * @return The node that was removed\n     */\n    Node.prototype.replaceChild = function (node, child) {\n        expectArity(arguments, 2);\n        node = asObject(node, Node);\n        child = asObject(child, Node);\n        return replaceChildWithNode(child, node, this);\n    };\n    /**\n     * Removes child from context object and returns the removed node.\n     *\n     * @param child Child of the current node to remove\n     *\n     * @return The node that was removed\n     */\n    Node.prototype.removeChild = function (child) {\n        expectArity(arguments, 1);\n        child = asObject(child, Node);\n        return preRemoveChild(child, this);\n    };\n    Node.ELEMENT_NODE = 1 /* ELEMENT_NODE */;\n    Node.ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;\n    Node.TEXT_NODE = 3 /* TEXT_NODE */;\n    Node.CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;\n    Node.ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */; // historical\n    Node.ENTITY_NODE = 6 /* ENTITY_NODE */; // historical\n    Node.PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;\n    Node.COMMENT_NODE = 8 /* COMMENT_NODE */;\n    Node.DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;\n    Node.DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;\n    Node.DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;\n    Node.NOTATION_NODE = 12 /* NOTATION_NODE */; // historical\n    return Node;\n}());\nexport default Node;\nNode.prototype.ELEMENT_NODE = 1 /* ELEMENT_NODE */;\nNode.prototype.ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;\nNode.prototype.TEXT_NODE = 3 /* TEXT_NODE */;\nNode.prototype.CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;\nNode.prototype.ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */; // historical\nNode.prototype.ENTITY_NODE = 6 /* ENTITY_NODE */; // historical\nNode.prototype.PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;\nNode.prototype.COMMENT_NODE = 8 /* COMMENT_NODE */;\nNode.prototype.DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;\nNode.prototype.DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;\nNode.prototype.DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;\nNode.prototype.NOTATION_NODE = 12 /* NOTATION_NODE */; // historical\n//# sourceMappingURL=Node.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Text from './Text';\nimport { getContext } from './context/Context';\nvar CDATASection = /** @class */ (function (_super) {\n    __extends(CDATASection, _super);\n    // CDATASection\n    /**\n     * (non-standard) use Document#createCDATASection to create a CDATA section.\n     *\n     * @param data The data for the node\n     */\n    function CDATASection(data) {\n        return _super.call(this, data) || this;\n    }\n    Object.defineProperty(CDATASection.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 4 /* CDATA_SECTION_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CDATASection.prototype, \"nodeName\", {\n        get: function () {\n            return '#cdata-section';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    CDATASection.prototype._copy = function (document) {\n        // Set copy’s data, to that of node.\n        var context = getContext(document);\n        var copy = new context.CDATASection(this.data);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return CDATASection;\n}(Text));\nexport default CDATASection;\n//# sourceMappingURL=CDATASection.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport CharacterData from './CharacterData';\nimport { getContext } from './context/Context';\nvar Comment = /** @class */ (function (_super) {\n    __extends(Comment, _super);\n    // Comment\n    /**\n     * Returns a new Comment node whose data is data and node document is current global object’s\n     * associated Document.\n     *\n     * @param data The data for the new comment\n     */\n    function Comment(data) {\n        if (data === void 0) { data = ''; }\n        var _this = _super.call(this, data) || this;\n        var context = getContext(_this);\n        _this.ownerDocument = context.document;\n        return _this;\n    }\n    Object.defineProperty(Comment.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 8 /* COMMENT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Comment.prototype, \"nodeName\", {\n        get: function () {\n            return '#comment';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    Comment.prototype._copy = function (document) {\n        // Set copy’s data, to that of node.\n        var context = getContext(document);\n        var copy = new context.Comment(this.data);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return Comment;\n}(CharacterData));\nexport default Comment;\n//# sourceMappingURL=Comment.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nvar DocumentType = /** @class */ (function (_super) {\n    __extends(DocumentType, _super);\n    /**\n     * (non-standard) Use DOMImplementation#createDocumentType instead.\n     *\n     * @param name     The name of the doctype\n     * @param publicId The public ID of the doctype\n     * @param systemId The system ID of the doctype\n     */\n    function DocumentType(name, publicId, systemId) {\n        if (publicId === void 0) { publicId = ''; }\n        if (systemId === void 0) { systemId = ''; }\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this.publicId = publicId;\n        _this.systemId = systemId;\n        return _this;\n    }\n    Object.defineProperty(DocumentType.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 10 /* DOCUMENT_TYPE_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentType.prototype, \"nodeName\", {\n        get: function () {\n            return this.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentType.prototype, \"nodeValue\", {\n        get: function () {\n            return null;\n        },\n        set: function (newValue) {\n            // Do nothing.\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentType.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to return value)\n        // 2. Switch on the context object:\n        // DocumentType - Return null\n        return null;\n    };\n    DocumentType.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to return value)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: DocumentType\n        // Return null.\n        return null;\n    };\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    DocumentType.prototype._copy = function (document) {\n        // Set copy’s name, public ID, and system ID, to those of node.\n        var context = getContext(document);\n        var copy = new context.DocumentType(this.name, this.publicId, this.systemId);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return DocumentType;\n}(Node));\nexport default DocumentType;\n//# sourceMappingURL=DocumentType.js.map","import DocumentType from './DocumentType';\nimport { createElement } from './Element';\nimport { getContext } from './context/Context';\nimport createElementNS from './util/createElementNS';\nimport { expectArity } from './util/errorHelpers';\nimport { HTML_NAMESPACE, validateQualifiedName } from './util/namespaceHelpers';\nimport { asNullableObject, asNullableString, treatNullAsEmptyString } from './util/typeHelpers';\nvar DOMImplementation = /** @class */ (function () {\n    /**\n     * (non-standard) Use Document#implementation to access instances of this class\n     *\n     * @param document The document to associate with this instance\n     */\n    function DOMImplementation(document) {\n        this._document = document;\n    }\n    /**\n     * Returns a doctype, with the given qualifiedName, publicId, and systemId.\n     *\n     * @param qualifiedName Qualified name for the doctype\n     * @param publicId      Public ID for the doctype\n     * @param systemId      System ID for the doctype\n     *\n     * @return The new doctype node\n     */\n    DOMImplementation.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {\n        expectArity(arguments, 3);\n        qualifiedName = String(qualifiedName);\n        publicId = String(publicId);\n        systemId = String(systemId);\n        // 1. Validate qualifiedName.\n        validateQualifiedName(qualifiedName);\n        // 2. Return a new doctype, with qualifiedName as its name, publicId as its public ID, and\n        // systemId as its system ID, and with its node document set to the associated document of\n        // the context object.\n        var context = getContext(this._document);\n        var doctype = new context.DocumentType(qualifiedName, publicId, systemId);\n        doctype.ownerDocument = this._document;\n        return doctype;\n    };\n    /**\n     * Returns an XMLDocument, with a document element whose local name is qualifiedName and whose\n     * namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is\n     * given, as its doctype.\n     *\n     * @param namespace     The namespace for the root element\n     * @param qualifiedName The qualified name for the root element, or empty string to not create a\n     *                      root element\n     * @param doctype       The doctype for the new document, or null to not add a doctype\n     *\n     * @return The new XMLDocument\n     */\n    DOMImplementation.prototype.createDocument = function (namespace, qualifiedName, doctype) {\n        if (doctype === void 0) { doctype = null; }\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        // [TreatNullAs=EmptyString] for qualifiedName\n        qualifiedName = treatNullAsEmptyString(qualifiedName);\n        doctype = asNullableObject(doctype, DocumentType);\n        // 1. Let document be a new XMLDocument.\n        var context = getContext(this._document);\n        var document = new context.XMLDocument();\n        // 2. Let element be null.\n        var element = null;\n        // 3. If qualifiedName is not the empty string, then set element to the result of running\n        // the internal createElementNS steps, given document, namespace, qualifiedName, and an\n        // empty dictionary.\n        if (qualifiedName !== '') {\n            element = createElementNS(document, namespace, qualifiedName);\n        }\n        // 4. If doctype is non-null, append doctype to document.\n        if (doctype) {\n            document.appendChild(doctype);\n        }\n        // 5. If element is non-null, append element to document.\n        if (element) {\n            document.appendChild(element);\n        }\n        // 6. document’s origin is context object’s associated document’s origin.\n        // (origin not implemented)\n        // 7. document’s content type is determined by namespace:\n        // HTML namespace: application/xhtml+xml\n        // SVG namespace: image/svg+xml\n        // Any other namespace: application/xml\n        // (content type not implemented)\n        // 8. Return document.\n        return document;\n    };\n    /**\n     * Returns a HTML document with a basic tree already constructed.\n     *\n     * @param title Optional title for the new HTML document\n     *\n     * @return The new document\n     */\n    DOMImplementation.prototype.createHTMLDocument = function (title) {\n        title = asNullableString(title);\n        // 1. Let doc be a new document that is an HTML document.\n        var context = getContext(this._document);\n        var doc = new context.Document();\n        // 2. Set doc’s content type to \"text/html\".\n        // (content type not implemented)\n        // 3. Append a new doctype, with \"html\" as its name and with its node document set to doc,\n        // to doc.\n        var doctype = new context.DocumentType('html');\n        doctype.ownerDocument = doc;\n        doc.appendChild(doctype);\n        // 4. Append the result of creating an element given doc, html, and the HTML namespace, to\n        // doc.\n        var htmlElement = createElement(doc, 'html', HTML_NAMESPACE);\n        doc.appendChild(htmlElement);\n        // 5. Append the result of creating an element given doc, head, and the HTML namespace, to\n        // the html element created earlier.\n        var headElement = createElement(doc, 'head', HTML_NAMESPACE);\n        htmlElement.appendChild(headElement);\n        // 6. If title is given:\n        if (title !== null) {\n            // 6.1. Append the result of creating an element given doc, title, and the HTML\n            // namespace, to the head element created earlier.\n            var titleElement = createElement(doc, 'title', HTML_NAMESPACE);\n            headElement.appendChild(titleElement);\n            // 6.2. Append a new Text node, with its data set to title (which could be the empty\n            // string) and its node document set to doc, to the title element created earlier.\n            titleElement.appendChild(doc.createTextNode(title));\n        }\n        // 7. Append the result of creating an element given doc, body, and the HTML namespace, to\n        // the html element created earlier.\n        htmlElement.appendChild(createElement(doc, 'body', HTML_NAMESPACE));\n        // 8. doc’s origin is context object’s associated document’s origin.\n        // (origin not implemented)\n        // 9. Return doc.\n        return doc;\n    };\n    return DOMImplementation;\n}());\nexport default DOMImplementation;\n//# sourceMappingURL=DOMImplementation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getChildren } from './mixins';\nimport DOMImplementation from './DOMImplementation';\nimport { createElement } from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport cloneNode from './util/cloneNode';\nimport createElementNS from './util/createElementNS';\nimport { expectArity, throwInvalidCharacterError, throwNotSupportedError } from './util/errorHelpers';\nimport { adoptNode } from './util/mutationAlgorithms';\nimport { isNodeOfType } from './util/NodeType';\nimport { matchesNameProduction, validateAndExtract } from './util/namespaceHelpers';\nimport { asNullableString, asObject } from './util/typeHelpers';\n/**\n * 3.5. Interface Document\n */\nvar Document = /** @class */ (function (_super) {\n    __extends(Document, _super);\n    /**\n     * Creates a new Document.\n     *\n     * Note: Unlike DOMImplementation#createDocument(), this constructor does not return an\n     * XMLDocument object, but a document (Document object).\n     */\n    function Document() {\n        var _this = _super.call(this) || this;\n        _this.firstElementChild = null;\n        _this.lastElementChild = null;\n        _this.childElementCount = 0;\n        // Document\n        /**\n         * Returns a reference to the DOMImplementation object associated with the document.\n         */\n        _this.implementation = new DOMImplementation(_this);\n        /**\n         * The doctype, or null if there is none.\n         */\n        _this.doctype = null;\n        /**\n         * The document element, or null if there is none.\n         */\n        _this.documentElement = null;\n        return _this;\n    }\n    Object.defineProperty(Document.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 9 /* DOCUMENT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Document.prototype, \"nodeName\", {\n        get: function () {\n            return '#document';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Document.prototype, \"nodeValue\", {\n        get: function () {\n            return null;\n        },\n        set: function (newValue) {\n            // Do nothing.\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Document.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to recursion)\n        // 2. Switch on the context object:\n        // Document - Return the result of locating a namespace prefix for its document element, if\n        // its document element is non-null, and null otherwise.\n        if (this.documentElement !== null) {\n            return this.documentElement.lookupPrefix(namespace);\n        }\n        return null;\n    };\n    Document.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to recursion)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: Document\n        // 1. If its document element is null, then return null.\n        if (this.documentElement === null) {\n            return null;\n        }\n        // 2. Return the result of running locate a namespace on its document element using prefix.\n        return this.documentElement.lookupNamespaceURI(prefix);\n    };\n    Object.defineProperty(Document.prototype, \"children\", {\n        // ParentNode\n        get: function () {\n            return getChildren(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a new element in the null namespace.\n     *\n     * @param localName Local name of the element\n     *\n     * @return The new element\n     */\n    Document.prototype.createElement = function (localName) {\n        expectArity(arguments, 1);\n        localName = String(localName);\n        // 1. If localName does not match the Name production, then throw an InvalidCharacterError.\n        if (!matchesNameProduction(localName)) {\n            throwInvalidCharacterError('The local name is not a valid Name');\n        }\n        // 2. If the context object is an HTML document, then set localName to localName in ASCII\n        // lowercase.\n        // (html documents not implemented)\n        // 3. Let is be the value of is member of options, or null if no such member exists.\n        // (custom elements not implemented)\n        // 4. Let namespace be the HTML namespace, if the context object is an HTML document or\n        // context object’s content type is \"application/xhtml+xml\", and null otherwise.\n        // (html documents not implemented)\n        var namespace = null;\n        // 5. Let element be the result of creating an element given the context object, localName,\n        // namespace, null, is, and with the synchronous custom elements flag set.\n        var element = createElement(this, localName, namespace, null);\n        // 6. If is is non-null, then set an attribute value for element using \"is\" and is.\n        // (custom elements not implemented)\n        // 7. Return element.\n        return element;\n    };\n    /**\n     * Creates a new element in the given namespace.\n     *\n     * @param namespace     Namespace URI for the new element\n     * @param qualifiedName Qualified name for the new element\n     *\n     * @return The new element\n     */\n    Document.prototype.createElementNS = function (namespace, qualifiedName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        qualifiedName = String(qualifiedName);\n        // return the result of running the internal createElementNS steps, given context object,\n        // namespace, qualifiedName, and options.\n        return createElementNS(this, namespace, qualifiedName);\n    };\n    /**\n     * Returns a new DocumentFragment node with its node document set to the context object.\n     *\n     * @return The new document fragment\n     */\n    Document.prototype.createDocumentFragment = function () {\n        var context = getContext(this);\n        var documentFragment = new context.DocumentFragment();\n        documentFragment.ownerDocument = this;\n        return documentFragment;\n    };\n    /**\n     * Returns a new Text node with its data set to data and node document set to the context\n     * object.\n     *\n     * @param data Data for the new text node\n     *\n     * @return The new text node\n     */\n    Document.prototype.createTextNode = function (data) {\n        expectArity(arguments, 1);\n        data = String(data);\n        var context = getContext(this);\n        var text = new context.Text(data);\n        text.ownerDocument = this;\n        return text;\n    };\n    /**\n     * Returns a new CDATA section with the given data and node document set to the context object.\n     *\n     * @param data Data for the new CDATA section\n     *\n     * @return The new CDATA section\n     */\n    Document.prototype.createCDATASection = function (data) {\n        expectArity(arguments, 1);\n        data = String(data);\n        // 1. If context object is an HTML document, then throw a NotSupportedError.\n        // (html documents not implemented)\n        // 2. If data contains the string \"]]>\", then throw an InvalidCharacterError.\n        if (data.indexOf(']]>') >= 0) {\n            throwInvalidCharacterError('Data must not contain the string \"]]>\"');\n        }\n        // 3. Return a new CDATASection node with its data set to data and node document set to the\n        // context object.\n        var context = getContext(this);\n        var cdataSection = new context.CDATASection(data);\n        cdataSection.ownerDocument = this;\n        return cdataSection;\n    };\n    /**\n     * Returns a new Comment node with its data set to data and node document set to the context\n     * object.\n     *\n     * @param data Data for the new comment\n     *\n     * @return The new comment node\n     */\n    Document.prototype.createComment = function (data) {\n        expectArity(arguments, 1);\n        data = String(data);\n        var context = getContext(this);\n        var comment = new context.Comment(data);\n        comment.ownerDocument = this;\n        return comment;\n    };\n    /**\n     * Creates a new processing instruction node, with target set to target, data set to data, and\n     * node document set to the context object.\n     *\n     * @param target Target for the new processing instruction\n     * @param data   Data for the new processing instruction\n     *\n     * @return The new processing instruction\n     */\n    Document.prototype.createProcessingInstruction = function (target, data) {\n        expectArity(arguments, 2);\n        target = String(target);\n        data = String(data);\n        // 1. If target does not match the Name production, then throw an InvalidCharacterError.\n        if (!matchesNameProduction(target)) {\n            throwInvalidCharacterError('The target is not a valid Name');\n        }\n        // 2. If data contains the string \"?>\", then throw an InvalidCharacterError.\n        if (data.indexOf('?>') >= 0) {\n            throwInvalidCharacterError('Data must not contain the string \"?>\"');\n        }\n        // 3. Return a new ProcessingInstruction node, with target set to target, data set to data,\n        // and node document set to the context object.\n        var context = getContext(this);\n        var pi = new context.ProcessingInstruction(target, data);\n        pi.ownerDocument = this;\n        return pi;\n        // Note: No check is performed that target contains \"xml\" or \":\", or that data contains\n        // characters that match the Char production.\n    };\n    /**\n     * Creates a copy of a node from an external document that can be inserted into the current\n     * document.\n     *\n     * @param node The node to import\n     * @param deep Whether to also import node's children\n     */\n    Document.prototype.importNode = function (node, deep) {\n        if (deep === void 0) { deep = false; }\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. If node is a document or shadow root, then throw a NotSupportedError.\n        if (isNodeOfType(node, 9 /* DOCUMENT_NODE */)) {\n            throwNotSupportedError('importing a Document node is not supported');\n        }\n        // 2. Return a clone of node, with context object and the clone children flag set if deep is\n        // true.\n        return cloneNode(node, deep, this);\n    };\n    /**\n     * Adopts a node. The node and its subtree is removed from the document it's in (if any), and\n     * its ownerDocument is changed to the current document. The node can then be inserted into the\n     * current document.\n     *\n     * @param node The node to adopt\n     */\n    Document.prototype.adoptNode = function (node) {\n        expectArity(arguments, 1);\n        node = asObject(node, Node);\n        // 1. If node is a document, then throw a NotSupportedError.\n        if (isNodeOfType(node, 9 /* DOCUMENT_NODE */)) {\n            throwNotSupportedError('adopting a Document node is not supported');\n        }\n        // 2. If node is a shadow root, then throw a HierarchyRequestError.\n        // (shadow dom not implemented)\n        // 3. Adopt node into the context object.\n        adoptNode(node, this);\n        // 4. Return node.\n        return node;\n    };\n    /**\n     * Creates a new attribute node with the null namespace and given local name.\n     *\n     * @param localName The local name of the attribute\n     *\n     * @return The new attribute node\n     */\n    Document.prototype.createAttribute = function (localName) {\n        expectArity(arguments, 1);\n        localName = String(localName);\n        // 1. If localName does not match the Name production in XML, then throw an\n        // InvalidCharacterError.\n        if (!matchesNameProduction(localName)) {\n            throwInvalidCharacterError('The local name is not a valid Name');\n        }\n        // 2. If the context object is an HTML document, then set localName to localName in ASCII\n        // lowercase.\n        // (html documents not implemented)\n        // 3. Return a new attribute whose local name is localName and node document is context\n        // object.\n        var context = getContext(this);\n        var attr = new context.Attr(null, null, localName, '', null);\n        attr.ownerDocument = this;\n        return attr;\n    };\n    /**\n     * Creates a new attribute node with the given namespace and qualified name.\n     *\n     * @param namespace     Namespace URI for the new attribute, or null for the null namespace\n     * @param qualifiedName Qualified name for the new attribute\n     *\n     * @return The new attribute node\n     */\n    Document.prototype.createAttributeNS = function (namespace, qualifiedName) {\n        expectArity(arguments, 2);\n        namespace = asNullableString(namespace);\n        qualifiedName = String(qualifiedName);\n        // 1. Let namespace, prefix, and localName be the result of passing namespace and\n        // qualifiedName to validate and extract.\n        var _a = validateAndExtract(namespace, qualifiedName), validatedNamespace = _a.namespace, prefix = _a.prefix, localName = _a.localName;\n        // 2. Return a new attribute whose namespace is namespace, namespace prefix is prefix, local\n        // name is localName, and node document is context object.\n        var context = getContext(this);\n        var attr = new context.Attr(validatedNamespace, prefix, localName, '', null);\n        attr.ownerDocument = this;\n        return attr;\n    };\n    /**\n     * Creates a new live Range, initially positioned at the root of this document.\n     *\n     * @return The new Range\n     */\n    Document.prototype.createRange = function () {\n        var context = getContext(this);\n        var range = new context.Range();\n        range.startContainer = this;\n        range.startOffset = 0;\n        range.endContainer = this;\n        range.endOffset = 0;\n        return range;\n    };\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    Document.prototype._copy = function (document) {\n        // Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n        // (properties not implemented)\n        var context = getContext(document);\n        return new context.Document();\n    };\n    return Document;\n}(Node));\nexport default Document;\n//# sourceMappingURL=Document.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { getChildren } from './mixins';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nvar DocumentFragment = /** @class */ (function (_super) {\n    __extends(DocumentFragment, _super);\n    /**\n     * Return a new DocumentFragment node whose node document is current global object’s associated\n     * Document.\n     */\n    function DocumentFragment() {\n        var _this = _super.call(this) || this;\n        _this.firstElementChild = null;\n        _this.lastElementChild = null;\n        _this.childElementCount = 0;\n        var context = getContext(_this);\n        _this.ownerDocument = context.document;\n        return _this;\n    }\n    Object.defineProperty(DocumentFragment.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 11 /* DOCUMENT_FRAGMENT_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentFragment.prototype, \"nodeName\", {\n        get: function () {\n            return '#document-fragment';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentFragment.prototype, \"nodeValue\", {\n        get: function () {\n            return null;\n        },\n        set: function (newValue) {\n            // Do nothing.\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentFragment.prototype.lookupPrefix = function (namespace) {\n        expectArity(arguments, 1);\n        // 1. If namespace is null or the empty string, then return null.\n        // (not necessary due to return value)\n        // 2. Switch on the context object:\n        // DocumentFragment - Return null\n        return null;\n    };\n    DocumentFragment.prototype.lookupNamespaceURI = function (prefix) {\n        expectArity(arguments, 1);\n        // 1. If prefix is the empty string, then set it to null.\n        // (not necessary due to return value)\n        // 2. Return the result of running locate a namespace for the context object using prefix.\n        // To locate a namespace for a node using prefix, switch on node: DocumentFragment\n        // Return null.\n        return null;\n    };\n    Object.defineProperty(DocumentFragment.prototype, \"children\", {\n        // ParentNode\n        get: function () {\n            return getChildren(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    DocumentFragment.prototype._copy = function (document) {\n        var context = getContext(document);\n        var copy = new context.DocumentFragment();\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return DocumentFragment;\n}(Node));\nexport default DocumentFragment;\n//# sourceMappingURL=DocumentFragment.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport CharacterData from './CharacterData';\nimport { getContext } from './context/Context';\n/**\n * 3.13. Interface ProcessingInstruction\n */\nvar ProcessingInstruction = /** @class */ (function (_super) {\n    __extends(ProcessingInstruction, _super);\n    /**\n     * (non-standard) Use Document#createProcessingInstruction to create a processing instruction.\n     *\n     * @param target The target of the processing instruction\n     * @param data   The data of the processing instruction\n     */\n    function ProcessingInstruction(target, data) {\n        var _this = _super.call(this, data) || this;\n        _this.target = target;\n        return _this;\n    }\n    Object.defineProperty(ProcessingInstruction.prototype, \"nodeType\", {\n        // Node\n        get: function () {\n            return 7 /* PROCESSING_INSTRUCTION_NODE */;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProcessingInstruction.prototype, \"nodeName\", {\n        get: function () {\n            return this.target;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    ProcessingInstruction.prototype._copy = function (document) {\n        // Set copy’s target and data to those of node.\n        var context = getContext(document);\n        var copy = new context.ProcessingInstruction(this.target, this.data);\n        copy.ownerDocument = document;\n        return copy;\n    };\n    return ProcessingInstruction;\n}(CharacterData));\nexport default ProcessingInstruction;\n//# sourceMappingURL=ProcessingInstruction.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Document from './Document';\nimport { getContext } from './context/Context';\nvar XMLDocument = /** @class */ (function (_super) {\n    __extends(XMLDocument, _super);\n    function XMLDocument() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * (non-standard) Creates a copy of the context object, not including its children.\n     *\n     * @param document The node document to associate with the copy\n     *\n     * @return A shallow copy of the context object\n     */\n    XMLDocument.prototype._copy = function (document) {\n        // Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n        // (properties not implemented)\n        var context = getContext(document);\n        return new context.XMLDocument();\n    };\n    return XMLDocument;\n}(Document));\nexport default XMLDocument;\n//# sourceMappingURL=XMLDocument.js.map","import Node from '../Node';\nimport { asObject } from '../util/typeHelpers';\nimport { produceXmlSerialization } from './serializationAlgorithms';\nvar XMLSerializer = /** @class */ (function () {\n    /**\n     * Constructs a new XMLSerializer object.\n     */\n    function XMLSerializer() {\n    }\n    /**\n     * Serializes root into a string using an XML serialization. Throws a TypeError exception if\n     * root is not a Node.\n     *\n     * @param root The node to serialize\n     *\n     * @return The XML resulting from serialization\n     */\n    XMLSerializer.prototype.serializeToString = function (root) {\n        root = asObject(root, Node);\n        // Produce an XML serialization of root passing a value of false for the require well-formed\n        // parameter, and return the result.\n        var result = [];\n        produceXmlSerialization(root, false, result);\n        return result.join('');\n    };\n    return XMLSerializer;\n}());\nexport default XMLSerializer;\n/**\n * Serializes root into a string using an XML serialization. Throws if the result would not be\n * well-formed XML.\n *\n * Non-standard: the dom-parsing spec does not provide a way to serialize arbitrary nodes while\n * enforcing well-formedness.\n *\n * @param root The node to serialize\n *\n * @return The XML resulting from serialization\n */\nexport function serializeToWellFormedString(root) {\n    root = asObject(root, Node);\n    // Produce an XML serialization of root passing a value of false for the require well-formed\n    // parameter, and return the result.\n    var result = [];\n    produceXmlSerialization(root, true, result);\n    return result.join('');\n}\n//# sourceMappingURL=XMLSerializer.js.map","import Node from '../Node';\nimport { expectArity } from '../util/errorHelpers';\nimport { asObject } from '../util/typeHelpers';\n/**\n * 3.3.1. Interface MutationObserver\n *\n * A MutationObserver object can be used to observe mutations to the tree of nodes.\n */\nvar MutationObserver = /** @class */ (function () {\n    /**\n     * Constructs a MutationObserver object and sets its callback to callback. The callback is\n     * invoked with a list of MutationRecord objects as first argument and the constructed\n     * MutationObserver object as second argument. It is invoked after nodes registered with the\n     * observe() method, are mutated.\n     *\n     * @param callback Function called after mutations have been observed.\n     */\n    function MutationObserver(callback) {\n        /**\n         * The list of nodes on which this observer is a RegisteredObserver's observer.\n         */\n        this._nodes = [];\n        /**\n         * The list of MutationRecord objects collected so far.\n         */\n        this._recordQueue = [];\n        /**\n         * Tracks transient registered observers created for this observer, to simplify their removal.\n         */\n        this._transients = [];\n        expectArity(arguments, 1);\n        callback = asObject(callback, Function);\n        // create a new MutationObserver object with callback set to callback\n        this._callback = callback;\n        // append it to the unit of related similar-origin browsing contexts' list of\n        // MutationObserver objects (for efficiency, this implementation only tracks\n        // MutationObserver objects that have records queued)\n    }\n    /**\n     * Instructs the user agent to observe a given target (a node) and report any mutations based on\n     * the criteria given by options (an object).\n     *\n     * NOTE: Adding an observer to an element is just like addEventListener, if you observe the\n     * element multiple times it does not make a difference. Meaning if you observe element twice,\n     * the observe callback does not fire twice, nor will you have to run disconnect() twice. In\n     * other words, once an element is observed, observing it again with the same will do nothing.\n     * However if the callback object is different it will of course add another observer to it.\n     *\n     * @param target  Node (or root of subtree) to observe\n     * @param options Determines which types of mutations to observe\n     */\n    MutationObserver.prototype.observe = function (target, options) {\n        expectArity(arguments, 2);\n        target = asObject(target, Node);\n        // Defaults from IDL\n        options.childList = !!options.childList;\n        options.subtree = !!options.subtree;\n        // 1. If either options’ attributeOldValue or attributeFilter is present and options’\n        // attributes is omitted, set options’ attributes to true.\n        if (options.attributeOldValue !== undefined && options.attributes === undefined) {\n            options.attributes = true;\n        }\n        // 2. If options’ characterDataOldValue is present and options’ characterData is omitted,\n        // set options’ characterData to true.\n        if (options.characterDataOldValue !== undefined && options.characterData === undefined) {\n            options.characterData = true;\n        }\n        // 3. If none of options’ childList, attributes, and characterData is true, throw a\n        // TypeError.\n        if (!(options.childList || options.attributes || options.characterData)) {\n            throw new TypeError('The options object must set at least one of \"attributes\", \"characterData\", or ' +\n                '\"childList\" to true.');\n        }\n        // 4. If options’ attributeOldValue is true and options’ attributes is false, throw a\n        // TypeError.\n        if (options.attributeOldValue && !options.attributes) {\n            throw new TypeError('The options object may only set \"attributeOldValue\" to true when \"attributes\" ' +\n                'is true or not present.');\n        }\n        // 5. If options’ attributeFilter is present and options’ attributes is false, throw a\n        // TypeError. (attributeFilter not yet implemented)\n        // 6. If options’ characterDataOldValue is true and options’ characterData is false, throw a\n        // TypeError.\n        if (options.characterDataOldValue && !options.characterData) {\n            throw new TypeError('The options object may only set \"characterDataOldValue\" to true when ' +\n                '\"characterData\" is true or not present.');\n        }\n        // 7. For each registered registered of target’s registered observer list, if registered's\n        // observer is the context object:\n        // 7.1. For each node of the context object's node list, remove all transient registered\n        // observers whose source is registered from node's registered observer list.\n        // 7.2. Set registered’s options to options.\n        // 8. Otherwise:\n        // 8.1. Append a new registered observer whose observer is the context object and options is\n        // options to target's registered observer list.\n        // 8.2. Append target to the context object's node list.\n        target._registeredObservers.register(this, options);\n    };\n    /**\n     * Stops the MutationObserver instance from receiving notifications of DOM mutations. Until the\n     * observe() method is used again, observer's callback will not be invoked.\n     */\n    MutationObserver.prototype.disconnect = function () {\n        var _this = this;\n        // 1. For each node of the context object’s node list, remove any registered observer from\n        // node's registered observer list for which the context object is the observer.\n        this._nodes.forEach(function (node) { return node._registeredObservers.removeForObserver(_this); });\n        this._nodes.length = 0;\n        // 2. Empty the context object’s record queue.\n        this._recordQueue.length = 0;\n    };\n    /**\n     * Empties the MutationObserver instance's record queue and returns what was in there.\n     *\n     * @return An Array of MutationRecord objects that were recorded.\n     */\n    MutationObserver.prototype.takeRecords = function () {\n        // 1. Let records be a clone of the context object's record queue.\n        var records = this._recordQueue.concat();\n        // 2. Empty the context object's record queue\n        this._recordQueue.length = 0;\n        // 3. Return records\n        return records;\n    };\n    return MutationObserver;\n}());\nexport default MutationObserver;\n//# sourceMappingURL=MutationObserver.js.map","export { default as Attr } from './Attr';\nexport { default as CDATASection } from './CDATASection';\nexport { default as CharacterData } from './CharacterData';\nexport { default as Comment } from './Comment';\nexport { default as Document } from './Document';\nexport { default as DocumentFragment } from './DocumentFragment';\nexport { default as DocumentType } from './DocumentType';\nexport { default as DOMImplementation } from './DOMImplementation';\nexport { default as Element } from './Element';\nexport { default as Node } from './Node';\nexport { default as ProcessingInstruction } from './ProcessingInstruction';\nexport { default as Range } from './Range';\nexport { default as Text } from './Text';\nexport { default as XMLDocument } from './XMLDocument';\nexport { default as XMLSerializer } from './dom-parsing/XMLSerializer';\nexport { default as MutationObserver } from './mutation-observer/MutationObserver';\nexport { default as MutationRecord } from './mutation-observer/MutationRecord';\n// Standard DOM does not expose a way to serialize arbitrary nodes as well-formed XML\nexport { serializeToWellFormedString } from './dom-parsing/XMLSerializer';\n// Unsafe exports, required for connecting a HTML parser\nexport { unsafeCreateAttribute, unsafeCreateElement, unsafeAppendAttribute } from './unsafe';\n// To avoid cyclic dependencies and enable multiple contexts with their own constructors later,\n// inject all constructors as well as the global document into the default context (i.e., global\n// object) here.\nimport { defaultContext } from './context/Context';\nimport Attr from './Attr';\nimport CDATASection from './CDATASection';\nimport Comment from './Comment';\nimport Document from './Document';\nimport DocumentFragment from './DocumentFragment';\nimport DocumentType from './DocumentType';\nimport DOMImplementation from './DOMImplementation';\nimport Element from './Element';\nimport ProcessingInstruction from './ProcessingInstruction';\nimport Range from './Range';\nimport Text from './Text';\nimport XMLDocument from './XMLDocument';\n// Document to associate with the global object\nexport var document = new Document();\ndefaultContext.document = document;\ndefaultContext.Attr = Attr;\ndefaultContext.CDATASection = CDATASection;\ndefaultContext.Comment = Comment;\ndefaultContext.Document = Document;\ndefaultContext.DocumentFragment = DocumentFragment;\ndefaultContext.DocumentType = DocumentType;\ndefaultContext.DOMImplementation = DOMImplementation;\ndefaultContext.Element = Element;\ndefaultContext.ProcessingInstruction = ProcessingInstruction;\ndefaultContext.Range = Range;\ndefaultContext.Text = Text;\ndefaultContext.XMLDocument = XMLDocument;\n//# sourceMappingURL=index.js.map","import Attr from './Attr';\n/**\n * Create an Attr node without the usual validation of the given names.\n *\n * @param namespace\n * @param prefix\n * @param localName\n * @param value\n * @param element\n */\nexport function unsafeCreateAttribute(namespace, prefix, localName, value, ownerElement) {\n    return new Attr(namespace, prefix, localName, value, ownerElement);\n}\nexport { createElement as unsafeCreateElement } from './Element';\nexport { appendAttribute as unsafeAppendAttribute } from './util/attrMutations';\n//# sourceMappingURL=unsafe.js.map"],"names":["removeTransientRegisteredObserversForObserver","observer","_transients","forEach","transientRegisteredObserver","node","_registeredObservers","removeTransientRegisteredObserver","length","removeTransientRegisteredObserversForSource","source","i","splice","queueCompoundMicrotask","callback","thisArg","args","_i","arguments","Promise","resolve","then","apply","getContext","defaultContext","isNodeOfType","types","some","t","nodeType","determineLengthOfNode","data","childNodes","getInclusiveAncestors","ancestor","ancestors","unshift","parentNode","getNodeDocument","ownerDocument","getNodeIndex","indexOf","getRootOfNode","forEachInclusiveDescendant","child","firstChild","nextSibling","cloneNode","cloneChildren","document","copy","_copy","appendChild","expectArity","minArity","TypeError","expectObject","value","Constructor","name","createDOMException","code","message","err","Error","throwHierarchyRequestError","throwIndexSizeError","throwInUseAttributeError","throwInvalidCharacterError","throwInvalidNodeTypeError","throwInvalidStateError","throwNamespaceError","throwNotFoundError","throwNotSupportedError","throwWrongDocumentError","asParentNode","getChildren","elements","firstElementChild","nextElementSibling","push","asNonDocumentTypeChildNode","getPreviousElementSibling","sibling","previousSibling","getNextElementSibling","insertIntoChildren","parent","referenceChild","lastChild","element","previousElementSibling","siblingNonDocumentTypeChildNode","lastElementChild","childElementCount","parentDocument","documentElement","doctype","removeFromChildren","isElement","queueMutationRecord","type","target","interestedObservers","pairedStrings","collectInterestedObservers","context","index","mappedOldValue","record","MutationRecord","namespace","attributeName","attributeNamespace","oldValue","addedNodes","removedNodes","_notifyList","appendRecord","queueMutationObserverCompoundMicrotask","ensurePreInsertionValidity","contains","fragment","Array","from","preInsertNode","adoptNode","insertNode","suppressObservers","isDocumentFragment","count","childIndex_1","_ranges","range","startContainer","startOffset","endContainer","endOffset","nodes","n","removeNode","appendNode","replaceChildWithNode","preRemoveChild","oldPreviousSibling","oldNextSibling","inclusiveAncestor","appendTransientRegisteredObservers","oldDocument","attr","_a","attributes","asUnsignedLong","number","treatNullAsEmptyString","asObject","asNullableObject","asNullableString","changeAttribute","attribute","localName","namespaceURI","_value","appendAttribute","ownerElement","removeAttribute","replaceAttribute","oldAttr","newAttr","setExistingAttributeValue","replaceData","offset","nodeData","newData","substring","_data","substringData","splitText","newNode","Text","indexOfNodePlusOne_1","context_1","matchesNameProduction","NAME_REGEX_XML_1_0_FOURTH_EDITION","test","isValidQName","parts","split","validateQualifiedName","qualifiedName","validateAndExtract","prefix","locateNamespacePrefix","find","parentElement","recordNamespaceInformation","map","localPrefixesMap","defaultNamespaceAttrValue","attributePrefix","prefixDefinition","namespaceDefinition","checkIfFound","add","serializeFragment","requireWellFormed","withFictionalParent","result","childNodes_1","produceXmlSerialization","join","prefixMap","NamespacePrefixMap","runXmlSerializationAlgorithm","error","prefixIndex","serializeElementNode","serializeDocumentNode","serializeCommentNode","serializeCDATASectionNode","serializeTextNode","serializeDocumentFragmentNode","serializeDocumentTypeNode","serializeProcessingInstructionNode","skipEndTag","ignoreNamespaceDefinitionAttribute","localDefaultNamespace","inheritedNs","ns","candidatePrefix","retrievePreferredPrefixString","serializeAttributeValue","generatePrefix","serializeAttributes","hasChildNodes","HTML_VOID_ELEMENTS","localNameSet","_loop_1","tuple","attributeValue","CHAR_REGEX_XML_1_0_FIFTH_EDITION","replace","newNamespace","generatedPrefix","comment","endsWith","text","markup","dt","PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION","publicId","systemId","pi","toLowerCase","createElement","Element","getAttributeByName","getAttributeByNamespaceAndLocalName","setAttribute","setAttributeValue","attribute_3","Attr","removeAttributeByName","removeAttributeByNamespaceAndLocalName","createElementNS","validatedNamespace","isCollapsed","compareBoundaryPointPositions","nodeA","offsetA","nodeB","offsetB","ancestors1","ancestors2","shift","getRootOfRange","RegisteredObserver","options","prototype","subtree","characterData","childList","attributeOldValue","characterDataOldValue","RegisteredObservers","_node","register","registeredObservers","hasRegisteredObserverForObserver","registered","_nodes","removeForObserver","write","read","l","registeredObserver","registerTransient","NotifyList","_compoundMicrotaskQueued","_recordQueue","_this","_notifyMutationObservers","notifyList","concat","mo","queue","takeRecords","_callback","DefaultContext","Node","Object","defineProperty","get","enumerable","configurable","normalize","nextNode","textNode","this_1","siblingsToRemove","_loop_2","currentNode","currentNodeIndex","deep","other","isDefaultNamespace","defaultNamespace","lookupNamespaceURI","insertBefore","replaceChild","removeChild","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","__extends","extendStatics","d","b","setPrototypeOf","__proto__","p","hasOwnProperty","__","constructor","create","_super","call","set","newValue","lookupPrefix","CharacterData","appendData","insertData","deleteData","CDATASection","Comment","DocumentType","HTML_NAMESPACE","XMLNS_NAMESPACE","_map","Map","entries","_b","prefixes","preferredPrefix","candidatesList","candidatesList_1","tagName","getAttributeNodeNS","hasAttributes","getAttribute","getAttributeNS","attribute_1","setAttributeNS","removeAttributeNS","toggleAttribute","force","attribute_2","hasAttribute","hasAttributeNS","getAttributeNode","setAttributeNode","setAttributeNodeNS","removeAttributeNode","copyElement","copyAttribute","DOMImplementation","_document","createDocumentType","createDocument","XMLDocument","createHTMLDocument","title","doc","Document","htmlElement","headElement","titleElement","createTextNode","implementation","createDocumentFragment","documentFragment","DocumentFragment","createCDATASection","cdataSection","createComment","createProcessingInstruction","ProcessingInstruction","importNode","createAttribute","createAttributeNS","createRange","Range","commonAncestorContainer","setStart","rootOfNode","rootOfRange","POSITION_AFTER","setEnd","POSITION_BEFORE","setStartBefore","setStartAfter","setEndBefore","setEndAfter","collapse","toStart","selectNode","selectNodeContents","compareBoundaryPoints","how","sourceRange","START_TO_START","START_TO_END","END_TO_END","END_TO_START","cloneRange","detach","isPointInRange","comparePoint","intersectsNode","XMLSerializer","serializeToString","root","MutationObserver","Function","observe","disconnect","records"],"mappings":"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"}